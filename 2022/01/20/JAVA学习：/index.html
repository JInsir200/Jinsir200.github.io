<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>java基础 | little_kim</title><meta name="keywords" content="Java"><meta name="author" content="JIn"><meta name="copyright" content="JIn"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="JAVA学习Java小知识之代码优化：​                            代码优化的目标是  减小代码的体积 提高代码运行的效率  ​                 1、尽量重用对象：​           1、特别是String对象的使用，出现字符串连接时应该使用StringBuilder&#x2F;StringBu ffer代替。由于Java虚拟机不仅要花时间生成对象，以后可能还">
<meta property="og:type" content="article">
<meta property="og:title" content="java基础">
<meta property="og:url" content="http://example.com/2022/01/20/JAVA%E5%AD%A6%E4%B9%A0%EF%BC%9A/index.html">
<meta property="og:site_name" content="little_kim">
<meta property="og:description" content="JAVA学习Java小知识之代码优化：​                            代码优化的目标是  减小代码的体积 提高代码运行的效率  ​                 1、尽量重用对象：​           1、特别是String对象的使用，出现字符串连接时应该使用StringBuilder&#x2F;StringBu ffer代替。由于Java虚拟机不仅要花时间生成对象，以后可能还">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://gitee.com/jwz--jwz/cloud-img/raw/master/piggo/202201041355284.jpg">
<meta property="article:published_time" content="2022-01-20T09:10:38.451Z">
<meta property="article:modified_time" content="2022-02-28T10:54:50.863Z">
<meta property="article:author" content="JIn">
<meta property="article:tag" content="Java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://gitee.com/jwz--jwz/cloud-img/raw/master/piggo/202201041355284.jpg"><link rel="shortcut icon" href="/./img/first.png"><link rel="canonical" href="http://example.com/2022/01/20/JAVA%E5%AD%A6%E4%B9%A0%EF%BC%9A/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"bottom-left"},
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'java基础',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-02-28 18:54:50'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    document.addEventListener('pjax:complete', detectApple)})(window)</script><meta name="generator" content="Hexo 5.4.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/./img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">12</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">12</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fas fa-folder-ope"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 我的</span><i class="fas fa-chevron-down expand hide"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://gitee.com/jwz--jwz/cloud-img/raw/master/piggo/202201041355284.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">little_kim</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fas fa-folder-ope"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 我的</span><i class="fas fa-chevron-down expand hide"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">java基础</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-01-20T09:10:38.451Z" title="发表于 2022-01-20 17:10:38">2022-01-20</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-02-28T10:54:50.863Z" title="更新于 2022-02-28 18:54:50">2022-02-28</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java%E5%9F%BA%E7%A1%80/">Java基础</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">18k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>67分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="java基础"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="JAVA学习"><a href="#JAVA学习" class="headerlink" title="JAVA学习"></a>JAVA学习</h2><h3 id="Java小知识之代码优化："><a href="#Java小知识之代码优化：" class="headerlink" title="Java小知识之代码优化："></a>Java小知识之代码优化：</h3><p>​                            代码优化的目标是</p>
<ul>
<li>减小代码的体积</li>
<li>提高代码运行的效率</li>
</ul>
<p>​                </p>
<h5 id="1、尽量重用对象："><a href="#1、尽量重用对象：" class="headerlink" title="1、尽量重用对象："></a>1、尽量重用对象：</h5><p>​           1、特别是String对象的使用，出现字符串连接时应该使用StringBuilder/StringBu ffer代替。由于Java虚拟机不仅要花时间生成对象，以后可能还需要花时间对这些对象进行垃圾回收和处理，因此，生成过多的对象将会给程序的性能带来很大的影响。</p>
<h5 id="2、循环内不要不断创建对象引用"><a href="#2、循环内不要不断创建对象引用" class="headerlink" title="2、循环内不要不断创建对象引用"></a>2、循环内不要不断创建对象引用</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= count; i++) &#123;Object obj = <span class="keyword">new</span> Object(); &#125;</span><br></pre></td></tr></table></figure>

<p>​       这种做法会导致内存中有count份Object对象引用存在，count很大的话，就耗费内存了，建议为改为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object obj = <span class="keyword">null</span>;<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= count; i++) &#123; obj = <span class="keyword">new</span> Object(); &#125;</span><br></pre></td></tr></table></figure>

<p>​         内存中只有一份Object对象引用，每次new Object()的时候，Object对象引用指向不同的Object罢了，但是内存中只有一份，这样就大大节省了内存空间了</p>
<p>​       3、 尽量使用HashMap、ArrayList、StringBuilder，除非线程安全需要，否则不推荐使用Hashtable、Vector、StringBuffer，后三者由于使用 同步机制而导致了性能开销</p>
<p>​       4、实现RandomAccess接口的集合比如ArrayList，应当使用最普通的for循环而不是foreach循环来遍历</p>
<p>这是JDK推荐给用户的。JDK API对于RandomAccess接口的解释是：实现RandomAccess接口用来表明其支持快速随机访问，此接口的主要目的是允许一般的算法更改其行为，从而将其应用到随机或连续访问列表时能提供良好的性能。实际经验表明，实现RandomAccess接口的类实例，假如是随机访问的，使用普通for循环效率将高于使用foreach循环；反过来，如果是顺序访问的，则使用Iterator会效率更高。可以使用类似如下的代码作判断：``</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (list <span class="keyword">instanceof</span> RandomAccess)</span><br><span class="line">&#123; <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++)&#123;&#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">Iterator&lt;?&gt; iterator = list.iterable(); <span class="keyword">while</span> (iterator.hasNext())&#123;iterator.next()&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>foreach循环的底层实现原理就是迭代器Iterator，参见Java语法糖1：可变长度参数以及foreach循环原理。所以后半句”反过来，如果是顺序访问的，则使用Iterator会效率更高”的意思就是顺序访问的那些类实例，使用foreach循环去遍历。</p>
<hr>
<h3 id="Java判断字符串是否为空"><a href="#Java判断字符串是否为空" class="headerlink" title="Java判断字符串是否为空"></a>Java判断字符串是否为空</h3><h4 id="一-空字符串与null区别"><a href="#一-空字符串与null区别" class="headerlink" title="一.空字符串与null区别"></a>一.空字符串与null区别</h4><h5 id="1、类型"><a href="#1、类型" class="headerlink" title="1、类型"></a>1、类型</h5><p>null表示的是一个对象的值，而并不是一个字符串。例如声明一个对象的引用，String a = null ;<br>“”表示的是一个空字符串，也就是说它的长度为0。例如声明一个字符串String str = “” ;</p>
<h5 id="2、内存分配"><a href="#2、内存分配" class="headerlink" title="2、内存分配"></a>2、内存分配</h5><p>String str = null ; 表示声明一个字符串对象的引用，但指向为null，也就是说还没有指向任何的内存空间；<br>String str = “”;    表示声明一个字符串类型的引用，其值为””空字符串，这个str引用指向的是空字符串的内存空间；<br>在java中变量和引用变量是存在栈中（stack），而对象（new产生的）都是存放在堆中（heap）：</p>
<p>就如下：</p>
<p>String str = new String(“abc”) ;</p>
<p>ps：=左边的是存放在栈中（stack），=右边是存放在堆中（heap）。</p>
<h5 id="3、示例程序："><a href="#3、示例程序：" class="headerlink" title="3、示例程序："></a>3、示例程序：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">String_Demo01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;        </span><br><span class="line">        String str1 = <span class="keyword">new</span> String() ;</span><br><span class="line">        String str2 = <span class="keyword">null</span> ;</span><br><span class="line">        String str3 = <span class="string">&quot;&quot;</span> ;</span><br><span class="line">        System.out.println(str1==str2);                <span class="comment">//内存地址的比较，返回false</span></span><br><span class="line">        System.out.println(str1.equals(str2));         <span class="comment">//值的比较，返回false</span></span><br><span class="line">        System.out.println(str2==str3);                <span class="comment">//内存地址的比较，返回false</span></span><br><span class="line">        System.out.println(str3.equals(str2));         <span class="comment">//值的比较，返回false</span></span><br><span class="line">        System.out.println(str1==str3);                <span class="comment">//内存地址的比较，返回false</span></span><br><span class="line">        System.out.println(str1.equals(str3));         <span class="comment">//值的比较，返回true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过如上的程序可以得出如下结论：</p>
<blockquote>
<p>字符串对象与null的值不相等，且内存地址也不相等；<br>空字符串对象与null的值不相等，且内存地址也不相等；<br>new String()创建一个字符串对象的默认值为”” （String类型成员变量的初始值为null）</p>
</blockquote>
<h5 id="4-Java判断字符串常方法"><a href="#4-Java判断字符串常方法" class="headerlink" title="4.Java判断字符串常方法"></a>4.Java判断字符串常方法</h5><p>方法一: 最多人使用的一个方法, 直观, 方便, 但效率很低:</p>
<pre><code>                 if(s == null || s.equals(&quot;&quot;));
</code></pre>
<p>方法二: 比较字符串长度, 效率高, 是我知道的最好一个方法:</p>
<pre><code>                 if(s == null || s.length() == 0);
</code></pre>
<p>方法三: Java SE 6.0 才开始提供的方法, 效率和方法二几乎相等, 但出于兼容性考虑, 推荐使用方法二.</p>
<pre><code>                 if(s == null || s.isEmpty());
</code></pre>
<p>方法四: 这是一种比较直观,简便的方法,而且效率也非常的高,与方法二、三的效率差不多:</p>
<pre><code>                 if (s == null || s == &quot;&quot;);
</code></pre>
<p> 注意:s == null 是有必要存在的.</p>
<p>　　如果 String 类型为null, 而去进行 equals(String) 或 length() 等操作会抛出java.lang.NullPointerException.</p>
<p>　　并且s==null 的顺序必须出现在前面，不然同样会抛出java.lang.NullPointerException.</p>
<p>　　如下Java代码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="keyword">null</span>;</span><br><span class="line">　　<span class="keyword">if</span>(str.equals(<span class="string">&quot;&quot;</span>) || str == <span class="keyword">null</span>)&#123;<span class="comment">//会抛出异常</span></span><br><span class="line">　　          System.out.println(<span class="string">&quot;success&quot;</span>);</span><br><span class="line">　　&#125;</span><br></pre></td></tr></table></figure>

<h5 id="五、StringUtils的isBlank与isEmply"><a href="#五、StringUtils的isBlank与isEmply" class="headerlink" title="五、StringUtils的isBlank与isEmply"></a>五、StringUtils的isBlank与isEmply</h5><h6 id="1-public-static-boolean-isEmpty-String-str"><a href="#1-public-static-boolean-isEmpty-String-str" class="headerlink" title="1.public static boolean isEmpty(String str)"></a>1.public static boolean isEmpty(String str)</h6><p>　　判断某字符串是否为空，为空的标准是 str==null 或 str.length()==0</p>
<p>　　下面是 StringUtils 判断是否为空的示例： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">　　StringUtils.isEmpty(<span class="keyword">null</span>) = <span class="keyword">true</span></span><br><span class="line"></span><br><span class="line">　　StringUtils.isEmpty(<span class="string">&quot;&quot;</span>) = <span class="keyword">true</span></span><br><span class="line"></span><br><span class="line">　　StringUtils.isEmpty(<span class="string">&quot; &quot;</span>) = <span class="keyword">false</span> <span class="comment">//注意在 StringUtils 中空格作非空处理 </span></span><br><span class="line"></span><br><span class="line">　　StringUtils.isEmpty(<span class="string">&quot;   &quot;</span>) = <span class="keyword">false</span></span><br><span class="line"></span><br><span class="line">　　StringUtils.isEmpty(<span class="string">&quot;bob&quot;</span>) = <span class="keyword">false</span></span><br><span class="line"></span><br><span class="line">　　StringUtils.isEmpty(<span class="string">&quot; bob &quot;</span>) = <span class="keyword">false</span></span><br></pre></td></tr></table></figure>

<h6 id="2-public-static-boolean-isNotEmpty-String-str"><a href="#2-public-static-boolean-isNotEmpty-String-str" class="headerlink" title="2.public static boolean isNotEmpty(String str)"></a>2.public static boolean isNotEmpty(String str)</h6><p>　　判断某字符串是否非空，等于 !isEmpty(String str) </p>
<p>　　下面是示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">　　StringUtils.isNotEmpty(<span class="keyword">null</span>) = <span class="keyword">false</span></span><br><span class="line"></span><br><span class="line">　　StringUtils.isNotEmpty(<span class="string">&quot;&quot;</span>) = <span class="keyword">false</span></span><br><span class="line"></span><br><span class="line">　　StringUtils.isNotEmpty(<span class="string">&quot; &quot;</span>) = <span class="keyword">true</span></span><br><span class="line"></span><br><span class="line">　　StringUtils.isNotEmpty(<span class="string">&quot;         &quot;</span>) = <span class="keyword">true</span></span><br><span class="line"></span><br><span class="line">　　StringUtils.isNotEmpty(<span class="string">&quot;bob&quot;</span>) = <span class="keyword">true</span></span><br><span class="line"></span><br><span class="line">　　StringUtils.isNotEmpty(<span class="string">&quot; bob &quot;</span>) = <span class="keyword">true</span></span><br></pre></td></tr></table></figure>

<h6 id="3-pblic-static-boolean-isBlank-String-str"><a href="#3-pblic-static-boolean-isBlank-String-str" class="headerlink" title="3.pblic static boolean isBlank(String str)"></a>3.pblic static boolean isBlank(String str)</h6><p>　　判断某字符串是否为空或长度为0或由空白符(whitespace) 构成 </p>
<p>　　下面是示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">　　StringUtils.isBlank(<span class="keyword">null</span>) = <span class="keyword">true</span></span><br><span class="line"></span><br><span class="line">　　StringUtils.isBlank(<span class="string">&quot;&quot;</span>) = <span class="keyword">true</span></span><br><span class="line"></span><br><span class="line">　　StringUtils.isBlank(<span class="string">&quot; &quot;</span>) = <span class="keyword">true</span></span><br><span class="line"></span><br><span class="line">　　StringUtils.isBlank(<span class="string">&quot;        &quot;</span>) = <span class="keyword">true</span></span><br><span class="line"></span><br><span class="line">　　StringUtils.isBlank(<span class="string">&quot;\t \n \f \r&quot;</span>) = <span class="keyword">true</span>   <span class="comment">//对于制表符、换行符、换页符和回车符</span></span><br><span class="line"></span><br><span class="line">　　StringUtils.isBlank()  <span class="comment">//均识为空白符</span></span><br><span class="line"></span><br><span class="line">　　StringUtils.isBlank(<span class="string">&quot;\b&quot;</span>) = <span class="keyword">false</span>   <span class="comment">//&quot;\b&quot;为单词边界符</span></span><br><span class="line"></span><br><span class="line">　　StringUtils.isBlank(<span class="string">&quot;bob&quot;</span>) = <span class="keyword">false</span></span><br><span class="line"></span><br><span class="line">　　StringUtils.isBlank(<span class="string">&quot; bob &quot;</span>) = <span class="keyword">false</span></span><br></pre></td></tr></table></figure>



<h6 id="4-public-static-boolean-isNotBlank-String-str"><a href="#4-public-static-boolean-isNotBlank-String-str" class="headerlink" title="4.public static boolean isNotBlank(String str)"></a>4.public static boolean isNotBlank(String str)</h6><p>　　判断某字符串是否不为空且长度不为0且不由空白符(whitespace) 构成，等于 !isBlank(String str) </p>
<p>　　下面是示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">　　StringUtils.isNotBlank(<span class="keyword">null</span>) = <span class="keyword">false</span></span><br><span class="line"></span><br><span class="line">　　StringUtils.isNotBlank(<span class="string">&quot;&quot;</span>) = <span class="keyword">false</span></span><br><span class="line"></span><br><span class="line">　　StringUtils.isNotBlank(<span class="string">&quot; &quot;</span>) = <span class="keyword">false</span></span><br><span class="line"></span><br><span class="line">　　StringUtils.isNotBlank(<span class="string">&quot;         &quot;</span>) = <span class="keyword">false</span></span><br><span class="line"></span><br><span class="line">　　StringUtils.isNotBlank(<span class="string">&quot;\t \n \f \r&quot;</span>) = <span class="keyword">false</span></span><br><span class="line"></span><br><span class="line">　　StringUtils.isNotBlank(<span class="string">&quot;\b&quot;</span>) = <span class="keyword">true</span></span><br><span class="line"></span><br><span class="line">　　StringUtils.isNotBlank(<span class="string">&quot;bob&quot;</span>) = <span class="keyword">true</span></span><br><span class="line"></span><br><span class="line">　　StringUtils.isNotBlank(<span class="string">&quot; bob &quot;</span>) = <span class="keyword">true</span></span><br></pre></td></tr></table></figure>

<h3 id="java-list如何进行判断空"><a href="#java-list如何进行判断空" class="headerlink" title="java list如何进行判断空"></a>java list如何进行判断空</h3><h4 id="1、常用表达方式"><a href="#1、常用表达方式" class="headerlink" title="1、常用表达方式"></a>1、常用表达方式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="keyword">null</span> == list || list.size() ==<span class="number">0</span> )&#123;</span><br><span class="line"></span><br><span class="line">　　<span class="comment">//为空的情况</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"></span><br><span class="line">　　<span class="comment">//不为空的情况</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(list!=<span class="keyword">null</span> &amp;&amp; !list.isEmpty())&#123;</span><br><span class="line">　　　<span class="comment">//不为空的情况</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">　　　<span class="comment">//为空的情况</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2、遇到问题"><a href="#2、遇到问题" class="headerlink" title="2、遇到问题"></a>2、遇到问题</h4><h5 id="1、-list-isEmpty-和-list-size-0"><a href="#1、-list-isEmpty-和-list-size-0" class="headerlink" title="1、 list.isEmpty() 和 list.size()==0"></a>1、 list.isEmpty() 和 list.size()==0</h5><p>　　答案：没有区别 。isEmpty()判断有没有元素，而size()返回有几个元素， 如果判断一个集合有无元素 建议用isEmpty()方法.比较符合逻辑用法。</p>
<h5 id="2、-list！-null-跟-！-list-isEmpty"><a href="#2、-list！-null-跟-！-list-isEmpty" class="headerlink" title="2、 list！=null 跟 ！ list.isEmpty()"></a>2、 list！=null 跟 ！ list.isEmpty()</h5><p>　　这就相当与，你要要到商店买东西</p>
<p>　　　　list！=null 首先判断是否有商店</p>
<p>　　　　！list.isEmpty() 没有判断商店是否存在，而是判断商店是否有东西</p>
<h3 id="Java局部变量、成员变量、类变量"><a href="#Java局部变量、成员变量、类变量" class="headerlink" title="Java局部变量、成员变量、类变量"></a>Java局部变量、成员变量、类变量</h3><h4 id="1、实例变量"><a href="#1、实例变量" class="headerlink" title="1、实例变量"></a>1、实例变量</h4><p>  也叫对象变量、类成员变量：从属于类,并由类生生成对象是，才分配存储空间， 能通过对象访问实例变量</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> String nameString;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">int</span> age;</span><br><span class="line">	<span class="keyword">protected</span> <span class="keyword">int</span> priority;</span><br><span class="line">	<span class="comment">//实例方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getNameString</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.nameString;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="类变量："><a href="#类变量：" class="headerlink" title="类变量："></a>类变量：</h4><p>也叫静态变量，是一种比较特殊的实例变量，用static关键字修饰；一个类的静态变量，所有由这类生成的对象都共用这个类变量，类装载时就分配存储空间。一个对象修改了变量，则所以对象中这个变量的值都会发生改变。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类变量（静态变量）</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//实例变量</span></span><br><span class="line">   <span class="keyword">private</span> String nameString;</span><br></pre></td></tr></table></figure>



<h4 id="局部变量："><a href="#局部变量：" class="headerlink" title="局部变量："></a>局部变量：</h4><p>方法中或者某局部中声明定义的变量方法或方法的参数 ,他们只存在创建他们的block里无法再block外面进行任何操作，在Java的多线程中，每个线程都会复制一份局部的变量，可以防止某些同步问题的发生</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//实例变量</span></span><br><span class="line">	<span class="keyword">private</span> String nameString;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="comment">//局部变量</span></span><br><span class="line">		<span class="keyword">int</span> temp = <span class="number">1</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/jwz--jwz/cloud-img/raw/master/image/202201222320395.png" alt="image-20210723003109260"></p>
<h4 id="四、他们的区别"><a href="#四、他们的区别" class="headerlink" title="四、他们的区别"></a>四、他们的区别</h4><h5 id="成员变量和局部变量的区别"><a href="#成员变量和局部变量的区别" class="headerlink" title="成员变量和局部变量的区别"></a>成员变量和局部变量的区别</h5><h6 id="成员变量："><a href="#成员变量：" class="headerlink" title="成员变量："></a>成员变量：</h6><p> ①成员变量定义在类中，在整个类中都可以被访问。</p>
<p>  ②成员变量随着对象的建立而建立，随着对象的消失而消失，存在于对象所在的堆内存中。</p>
<p>  ③成员变量有默认初始化值。</p>
<h6 id="局部变量：-1"><a href="#局部变量：-1" class="headerlink" title="局部变量："></a>局部变量：</h6><p>  ①局部变量只定义在局部范围内，如：函数内，语句内等，只在所属的区域有效。</p>
<p>  ②局部变量存在于栈内存中，作用的范围结束，变量空间会自动释放。</p>
<p>  ③局部变量没有默认初始化值</p>
<p> 在使用变量时需要遵循的原则为：就近原则</p>
<p>  首先在局部范围找，有就使用；接着在成员位置找</p>
<h5 id="b-成员变量和静态变量的区别"><a href="#b-成员变量和静态变量的区别" class="headerlink" title="b 成员变量和静态变量的区别"></a>b 成员变量和静态变量的区别</h5><h6 id="1、两个变量的生命周期不同"><a href="#1、两个变量的生命周期不同" class="headerlink" title="1、两个变量的生命周期不同"></a>1、两个变量的生命周期不同</h6><p>​    成员变量随着对象的创建而存在，随着对象被回收而释放。</p>
<p>​    静态变量随着类的加载而存在，随着类的消失而消失。****</p>
<h6 id="2、调用方式不同"><a href="#2、调用方式不同" class="headerlink" title="2、调用方式不同"></a>2、调用方式不同</h6><p>​    成员变量只能被对象调用。</p>
<p>​    静态变量可以被对象调用，还可以被类名调用。</p>
<h6 id="3、别名不同"><a href="#3、别名不同" class="headerlink" title="3、别名不同"></a>3、别名不同</h6><p>​    成员变量也称为实例变量。</p>
<p>​    静态变量也称为类变量。</p>
<h6 id="4、数据存储位置不同"><a href="#4、数据存储位置不同" class="headerlink" title="4、数据存储位置不同"></a>4、数据存储位置不同</h6><p>​    成员变量存储在堆内存的对象中，所以也叫对象的特有数据。</p>
<p>   静态变量数据存储在方法区（共享数据区）的静态区，所以也叫对象的共享数据。</p>
<p> [java 静态变量生命周期（类生命周期） - HF_Cherish - 博客园 (cnblogs.com)](<a target="_blank" rel="noopener" href="https://www.cnblogs.com/hf-cherish/p/4970267.html#:~:text=%E5%9B%A0%E4%B8%BA%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E8%99%BD%E7%84%B6%E9%95%BF%EF%BC%88%E5%B0%B1%E6%98%AF%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%EF%BC%89%EF%BC%8C%E4%BD%86%E6%98%AF%E5%BD%93%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C%E5%AE%8C%EF%BC%8C%E4%B9%9F%E5%B0%B1%E6%98%AF%E8%AF%A5%E7%B1%BB%E7%9A%84%E6%89%80%E6%9C%89%E5%AF%B9%E8%B1%A1%E9%83%BD%E5%B7%B2%E7%BB%8F%E8%A2%AB%E5%9B%9E%E6%94%B6%EF%BC%8C%E6%88%96%E8%80%85%E5%8A%A0%E8%BD%BD%E7%B1%BB%E7%9A%84ClassLoader%E5%B7%B2%E7%BB%8F%E8%A2%AB%E5%9B%9E%E6%94%B6%EF%BC%8C%E9%82%A3%E4%B9%88%E8%AF%A5%E7%B1%BB%E5%B0%B1%E4%BC%9A%E4%BB%8Ejvm%E7%9A%84%E6%96%B9%E6%B3%95%E5%8C%BA%E5%8D%B8%E8%BD%BD%EF%BC%8C%E5%8D%B3%E7%94%9F%E5%91%BD%E6%9C%9F%E7%BB%88%E6%AD%A2%E3%80%82">https://www.cnblogs.com/hf-cherish/p/4970267.html#:~:text=因为静态变量生命周期虽然长（就是类的生命周期），但是当程序执行完，也就是该类的所有对象都已经被回收，或者加载类的ClassLoader已经被回收，那么该类就会从jvm的方法区卸载，即生命期终止。</a> 更进一步来说，static变量终究是存在jvm的内存中的，jvm下次重新运行时，肯定会清空里边上次运行的内容，包括方法区、常量区的内容。,要实现某些变量在程序多次运行时都可以读取，那么必须要将变量存下来，即存到本地文件中。 常用的数据存取格式：XML、JSON、Propertities类（类似map的键值对）等)</p>
<hr>
<h2 id="java序列化"><a href="#java序列化" class="headerlink" title="java序列化:"></a>java序列化:</h2><h3 id="一、序列化的含义、意义及使用场景："><a href="#一、序列化的含义、意义及使用场景：" class="headerlink" title="一、序列化的含义、意义及使用场景："></a>一、序列化的含义、意义及使用场景：</h3><ul>
<li><p>  序列化：<strong>将对象写入到IO流中</strong></p>
</li>
<li><p>  反序列化：<strong>从IO流中恢复对象</strong></p>
</li>
</ul>
<p> 序列化目的：</p>
<blockquote>
<p> 方便数据的传递以及存储到磁盘上（把一个Java对象写入到硬盘或者传输到网路上面的其它计算机，这时我们就需要将对象转换成字节流才能进行网络传输。对于这种通用的操作，就出现了序列化来统一这些格式）</p>
<p>​     简单来说序列化就是一种用来处理<strong>对象流</strong>的机制。将<strong>对象</strong>转化成<strong>字节序列</strong>后可以保存在磁盘上，或通过网络传输，以达到以后恢复成原来的对象。<strong>序列化机制使得对象可以脱离程序的运行而独立存在</strong>。</p>
</blockquote>
<p>就是说你想要你要传输对象，那么就必须转换字节码传输，传输之后想要还原到原来的样子，就必须是要进行</p>
<p>使用场景:</p>
<ul>
<li>所有可在网络上传输的对象都必须是可序列化的，比如RMI（remote method invoke,即远程方法调用），传入的参数或返回的对象都是可序列化的，否则会出错</li>
<li> 所有需要保存到磁盘的java对象都必须是可序列化的, Redis 将对象当做字符串存储的时候，如果对象实现了序列化，则只需要将对象直接存储即可（java会自动将对象转换成序列化后的字节流）</li>
</ul>
<p><strong>通常建议：程序创建的每个JavaBean类都实现Serializeable接口</strong></p>
<p>转载：</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/9dragon/p/10901448.html">java序列化，看这篇就够了 - 9龙 - 博客园 (cnblogs.com)</a></p>
<h2 id="javaString类型"><a href="#javaString类型" class="headerlink" title="javaString类型"></a>javaString类型</h2><h4 id="关于String-不可以变："><a href="#关于String-不可以变：" class="headerlink" title="关于String 不可以变："></a>关于String 不可以变：</h4><h6 id="什么是不可变？"><a href="#什么是不可变？" class="headerlink" title="什么是不可变？"></a>什么是不可变？</h6><p>​      说String不可以变，那么到底是什么不可以变呢？ 我们可以这样认为，当创建一个对象，不改变他的状态，就是说不能改变他的成员变量，包括基本类型的值不能变，引用类型的不能指向别的对象，它的状态也不能够被改变</p>
<p>  例如一下状态：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="string">&quot;ABCabc&quot;</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;s = &quot;</span> + s);<span class="comment">//ABCabc</span></span><br><span class="line">s = <span class="string">&quot;123456&quot;</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;s = &quot;</span> + s);<span class="comment">//123456</span></span><br></pre></td></tr></table></figure>

<p>不是说不可变了吗，为什么还是变了？</p>
<p>  这个就要注意一下， s只是String对象的一个引用，并不是指对象本身，。对象在内存中是一个内存区，成员变量越多，内存就越大。<strong>引用只是一个四字节的地址，通过该地址可以访问到对象</strong>。所以说 s只是一个引用，它指向了对象所处的地址。代码中，s是同一引用，但是，值在不同的地址中，开始时，引用s 是“ABC”,调用同一个引用，又将s指向的地址改变成了“123456”的值</p>
<p><img src="https://gitee.com/jwz--jwz/cloud-img/raw/master/image/202201222320127.png" alt="image-20210819220635970"></p>
<hr>
<p>在Java中，Java并不能直接操控对象本身，所有的对象都是一个应用的指向，必须通过引用才能访问对象的本身,包括成员变量等，改变对象的成员变量，调用指针的方法等，引用和指针类似，<strong>都是存放的对象在内存中的地址，只是不能够进行指针运算</strong></p>
<p><img src="https://gitee.com/jwz--jwz/cloud-img/raw/master/image/202201222320043.png" alt="image-20210819225848264"></p>
<p><img src="C:\Users\jinweizhuo\AppData\Roaming\Typora\typora-user-images\image-20210819225902697.png" alt="image-20210819225902697"></p>
<p>所以说，一旦创建就不能够修改，而是重新创建一个地址，然后让该引用指向该地址的值，原来的数据并没有变化。而是重新创建了一个新的地址,改变了引用的指向</p>
<p><img src="https://gitee.com/jwz--jwz/cloud-img/raw/master/image/202201222321599.png" alt="image-20210820080154918">//true</p>
<p>上面的结果是true，因为string在创建对象是，在常量池里边，创建一个对象，会自动到常量池里面去找，如果有，改变该引用的指向，否则，重新创建一个对象</p>
<p>==比较的是值是不是相同，这个值分为地址值和数据的值，但它是基本数据类型时（int等 但是并没有对他进行实例化），因为那么就是比较的值，如果两个引用变量，指向同一个地址，采用== 就是ture,</p>
<p>equals 没有重写之前，就是和==一样</p>
<p>打个方，拿string做个比较就是，他重写了equals方法，两个string引用变量去比较，首先比较采用== ，比较地址值，你的地址值指向一样，那值肯定就是相等的</p>
<p>如果在不同的地址，那么引用地址的引用类型就需要重写了，equals来比较是否连个对象中的值相同</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object anObject)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//两个引用指向同一个地址，那么他们的值一定相等</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == anObject) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果在不同的地址之下，就要比较hash是否相同，如果hash值相同，就是说值相等，</span></span><br><span class="line">    <span class="keyword">if</span> (anObject <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">        String anotherString = (String)anObject;</span><br><span class="line">        <span class="keyword">int</span> n = value.length;</span><br><span class="line">        <span class="keyword">if</span> (n == anotherString.value.length) &#123;</span><br><span class="line">            <span class="keyword">char</span> v1[] = value;</span><br><span class="line">            <span class="keyword">char</span> v2[] = anotherString.value;</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (n-- != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (v1[i] != v2[i])</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">    <span class="meta">@org</span>.junit.<span class="function">Test</span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">IntTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">        String integer =<span class="keyword">new</span> String(<span class="string">&quot;7&quot;</span>) ;</span><br><span class="line">        change(integer);</span><br><span class="line">        User user = <span class="keyword">new</span> User(<span class="string">&quot;jin&quot;</span>);</span><br><span class="line">        user.setUserId(<span class="number">288</span>);</span><br><span class="line">        String kk = user.getUserName();</span><br><span class="line"><span class="comment">//       只要是new的对象就在方法区,就不会去常量池中寻找</span></span><br><span class="line">        String name3 =<span class="keyword">new</span> String(<span class="string">&quot;jin&quot;</span>);</span><br><span class="line">        String name= <span class="string">&quot;jin&quot;</span>;</span><br><span class="line"><span class="comment">//       引用地址值不一样，所指向的值一样，但指向不同的方法区</span></span><br><span class="line">        System.out.println(<span class="string">&quot;name3+name =&quot;</span>+(name3==name));<span class="comment">//false</span></span><br><span class="line"><span class="comment">//       == 进行的是值比较，在同一个常量池中，指向的地址一样</span></span><br><span class="line">        System.out.println(<span class="string">&quot;kk==name =&quot;</span>+(kk==name));<span class="comment">//true</span></span><br><span class="line"><span class="comment">//       同上，set方法中对象在常量池中</span></span><br><span class="line">        System.out.println(<span class="string">&quot;name==user.getUserName()=&quot;</span>+(name==user.getUserName()));<span class="comment">//true</span></span><br><span class="line">        User user1 = <span class="keyword">new</span> User();</span><br><span class="line"><span class="comment">//       user方法中初始话使用了new String</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;user1.getName1()==name=&quot;+(user1.getName1()==name));//false</span></span><br><span class="line"><span class="comment">//        user1.setName1(&quot;jin&quot;);</span></span><br><span class="line"><span class="comment">////        再次用set方法赋值时，进入常量池中</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;user1.getName1()==name=&quot;+(user1.getName1()==name));//ture</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//       基本数据类型会进行值比较</span></span><br><span class="line"><span class="comment">//        基本数据的引用类型 Integer 超过了127,就会自动装箱，创建内存地址，此时就是地址不同了</span></span><br><span class="line">        <span class="comment">//        值比较</span></span><br><span class="line">        <span class="keyword">int</span>   id=user.getUserId();</span><br><span class="line"><span class="comment">//        大于127进入堆中，地址值不一样</span></span><br><span class="line">        Integer integer1 =<span class="number">288</span>;</span><br><span class="line">        Integer integer2 = user.getUserId();</span><br><span class="line">        System.out.println(<span class="string">&quot;integer1==integer2 =&quot;</span>+(integer1==integer2));<span class="comment">//false</span></span><br><span class="line">        System.out.println(integer1 == user.getUserId());</span><br><span class="line"><span class="comment">//        超过范围自动装箱变引用，比较的就是一个地址值</span></span><br><span class="line">        System.out.println(id==user.getUserId());</span><br><span class="line">        System.out.println( user.getUserName() == name);</span><br><span class="line">        <span class="keyword">if</span> (user.getUserName().equals(name))&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;ooooooo&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(integer);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;--------------未有重写---------------------&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;1&quot;</span>+<span class="keyword">new</span> User().hashCode());</span><br><span class="line">        System.out.println(<span class="string">&quot;2&quot;</span>+<span class="keyword">new</span> User().hashCode());</span><br><span class="line">        System.out.println(<span class="string">&quot;3&quot;</span>+<span class="keyword">new</span> User().hashCode());</span><br><span class="line">        System.out.println(<span class="string">&quot;4&quot;</span>+<span class="keyword">new</span> User().hashCode());</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/20618891">如何理解 String 类型值的不可变？ - 知乎 (zhihu.com)</a></p>
<h4 id="关于hashcode"><a href="#关于hashcode" class="headerlink" title="关于hashcode ():"></a>关于hashcode ():</h4><h5 id="什么是hash"><a href="#什么是hash" class="headerlink" title="什么是hash :"></a>什么是hash :</h5><p>​        <img src="https://gitee.com/jwz--jwz/cloud-img/raw/master/image/202201222321069.png" alt="image-20210820123558804"></p>
<ul>
<li><strong>不同关键字经过散列算法变换后可能得到同一个散列地址，这种现象称为碰撞</strong></li>
<li><strong>如果两个Hash值不同（前提是同一Hash算法），那么这两个Hash值对应的原始输入必定不同</strong></li>
</ul>
<h5 id="HashCode："><a href="#HashCode：" class="headerlink" title="HashCode："></a>HashCode：</h5><p>1、HashCode的存在主要是为了查找的快捷性，HashCode是用来在散列存储结构中确定对象的存储地址的</p>
<p>2、如果两个对象equals相等，那么这两个对象的HashCode一定也相同</p>
<p>3、如果对象的equals方法被重写，那么对象的HashCode方法也尽量重写</p>
<p>4、如果两个对象的HashCode相同，不代表两个对象就相同，只能说明这两个对象在散列存储结构中，存放于同一个位置</p>
<h5 id="HashCode有什么用"><a href="#HashCode有什么用" class="headerlink" title="HashCode有什么用"></a><strong>HashCode有什么用</strong></h5><p>回到最关键的问题，HashCode有什么用？不妨举个例子：</p>
<p>1、假设内存中有0 1 2 3 4 5 6 7 8这9个位置，如果我有个字段叫做ID，那么我要把这个字段存放在以上9个位置之一，如果不用HashCode而任意存放，那么当查找时就需要到8个位置中去挨个查找</p>
<p>2、使用HashCode则效率会快很多，把ID的HashCode % 9，然后把ID存放在取得余数的那个位置，然后每次查找该类的时候都可以通过ID的HashCode % 9求余数直接找到存放的位置了</p>
<p>3、如果ID的HashCode % 9算出来的位置上本身已经有数据了怎么办？这就取决于算法的实现了，比如ThreadLocal中的做法就是从算出来的位置向后查找第一个为空的位置，放置数据；HashMap的做法就是通过链式结构连起来。反正，只要保证放的时候和取的时候的算法一致就行了。</p>
<p>4、如果ID的HashCode % 9相等怎么办（这种对应的是第三点说的链式结构的场景）？这时候就需要定义equals了。先通过HashCode%8来判断类在哪一个位置，再通过equals来在这个位置上寻找需要的类。对比两个类的时候也差不多，先通过HashCode比较，假如HashCode相等再判断equals。<strong>如果两个类的HashCode都不相同，那么这两个类必定是不同的</strong>。</p>
<h6 id="举个实际的例子Set："><a href="#举个实际的例子Set：" class="headerlink" title="举个实际的例子Set："></a>举个实际的例子Set：</h6><p>我们知道Set里面的元素是不可以重复的，那么如何做到？Set是根据equals()方法来判断两个元素是否相等的。比方说Set里面已经有1000个元素了，那么第1001个元素进来的时候，最多可能调用1000次equals方法，如果equals方法写得复杂，对比的东西特别多，那么效率会大大降低。使用HashCode就不一样了，比方说HashSet，底层是基于HashMap实现的，先通过HashCode取一个模，这样一下子就固定到某个位置了，如果这个位置上没有元素，那么就可以肯定HashSet中必定没有和新添加的元素equals的元素，就可以直接存放了，都不需要比较；如果这个位置上有元素了，逐一比较，比较的时候先比较HashCode，HashCode都不同接下去都不用比了，肯定不一样，HashCode相等，再equals比较，没有相同的元素就存，有相同的元素就不存。如果原来的Set里面有相同的元素，只要HashCode的生成方式定义得好（不重复），不管Set里面原来有多少元素，只需要执行一次的equals就可以了。这样一来，实际调用equals方法的次数大大降低，提高了效率。</p>
<h5 id="为什么要重写hashcode"><a href="#为什么要重写hashcode" class="headerlink" title="为什么要重写hashcode"></a>为什么要重写hashcode</h5><p>[讲讲HashCode的作用 - 五月的仓颉 - 博客园 (cnblogs.com)](<a target="_blank" rel="noopener" href="https://www.cnblogs.com/xrq730/p/4842028.html#:~:text=HashCode">https://www.cnblogs.com/xrq730/p/4842028.html#:~:text=HashCode</a>. 然后讲下什么是HashCode，总结几个关键点：.,1、HashCode的存在主要是为了查找的快捷性，HashCode是用来在散列存储结构中确定对象的存储地址的. 2、如果两个对象equals相等，那么这两个对象的HashCode一定也相同. 3、如果对象的equals方法被重写，那么对象的HashCode方法也尽量重写.)</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_44259720/article/details/88414828">(6条消息) 为什么重写equals()方法时，必须要求重写hashCode()方法？_IT无知君的博客-CSDN博客</a></p>
<p>保证成员变量都相等的情况下，他们的hashcode都相等的，重写equals方法必须尽量要重写hashCode方法的原因</p>
<p> <strong>1.equals()相等的两个对象他们的hashCode()肯定相等，也就是用equals()对比是绝对可靠的。</strong></p>
<p> <strong>2.hashCode()相等的两个对象他们的equals()不一定相等，也就是hashCode()不是绝对可靠的。</strong></p>
<pre><code>  所有对于需要大量并且快速的对比的话如果都用equals()去做显然效率太低，所以解决方式是，每当需要对比的时候，首先用hashCode()去对比，如果hashCode()不一样，则表示这两个对象肯定不相等（也就是不必再用equals()去再对比了）,如果hashCode()相同，此时再对比他们的equals()，如果equals()也相同，则表示这两个对象是真的相同了，这样既能大大提高了效率也保证了对比的绝对正确性！
</code></pre>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h = hash;<span class="comment">//默认是0</span></span><br><span class="line">    <span class="keyword">if</span> (h == <span class="number">0</span> &amp;&amp; value.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">char</span> val[] = value;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; value.length; i++) &#123;</span><br><span class="line">            h = <span class="number">31</span> * h + val[i];</span><br><span class="line">        &#125;</span><br><span class="line">        hash = h;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="java关键字"><a href="#java关键字" class="headerlink" title="java关键字"></a>java关键字</h2><h3 id="1、instanceof"><a href="#1、instanceof" class="headerlink" title="1、instanceof"></a>1、instanceof</h3><h4 id="1、instanceof用法详解："><a href="#1、instanceof用法详解：" class="headerlink" title="1、instanceof用法详解："></a>1、instanceof用法详解：</h4><p>instanceof严格上来说是一个双目运算符，用来测试一个类是否是一个类的实例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> result = obj <span class="keyword">instanceof</span> Class</span><br></pre></td></tr></table></figure>

<ul>
<li>类的实例包含本身的实例，以及所有直接或间接子类的实例</li>
<li>instanceof左边显式声明的类型与右边操作元必须是同种类或存在继承关系，也就是说需要位于同一个继承树，否则会编译错误</li>
</ul>
<h4 id="2、instanceof用法："><a href="#2、instanceof用法：" class="headerlink" title="2、instanceof用法："></a>2、instanceof用法：</h4><ul>
<li>左边的实例对象不能为基本数据类型</li>
</ul>
<p><img src="https://gitee.com/jwz--jwz/cloud-img/raw/master/image/202201222321095.png" alt="image-20210811170323344"></p>
<ul>
<li>左边的实例与右边的类不在同一个继承树上</li>
</ul>
<p><img src="https://gitee.com/jwz--jwz/cloud-img/raw/master/image/202201222321781.png" alt="image-20210811170424784"></p>
<ul>
<li>obj 为 null ，跟任何类型比较时都是false</li>
</ul>
<p><img src="https://gitee.com/jwz--jwz/cloud-img/raw/master/image/202201222321577.png" alt="image-20210811171114568"></p>
<p><img src="https://gitee.com/jwz--jwz/cloud-img/raw/master/image/202201222321868.png" alt="image-20210811171124133"></p>
<ul>
<li><h3 id="obj-为-class-接口的实现类"><a href="#obj-为-class-接口的实现类" class="headerlink" title="obj 为 class 接口的实现类"></a>obj 为 class 接口的实现类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure>

<p>instanceof 运算符判断 某个对象是否是 List 接口的实现类，如果是返回 true，否则返回 false</p>
<p><img src="https://gitee.com/jwz--jwz/cloud-img/raw/master/image/202201222321729.png" alt="image-20210811171507254"></p>
<h3 id="obj-为-class-类的直接或间接子类"><a href="#obj-为-class-类的直接或间接子类" class="headerlink" title="obj 为 class 类的直接或间接子类"></a>obj 为 class 类的直接或间接子类</h3></li>
</ul>
<p><img src="https://gitee.com/jwz--jwz/cloud-img/raw/master/image/202201222321719.png" alt="image-20210811171217018"></p>
<h4 id="3、原理使用伪代码表示为："><a href="#3、原理使用伪代码表示为：" class="headerlink" title="3、原理使用伪代码表示为："></a>3、原理使用伪代码表示为：</h4><p><img src="https://gitee.com/jwz--jwz/cloud-img/raw/master/image/202201222321514.png" alt="image-20210811172228543"></p>
<p>表达式必须是null或者是引用类型，否则会返回false</p>
<p><strong>如果 obj 不为 null 并且 (T) obj 不抛 ClassCastException 异常则该表达式值为 true ，否则值为 false 。</strong></p>
<h4 id="4、应用场景："><a href="#4、应用场景：" class="headerlink" title="4、应用场景："></a>4、应用场景：</h4><p>​            对象类型强制转换：</p>
<p><img src="https://gitee.com/jwz--jwz/cloud-img/raw/master/image/202201222321259.png" alt="image-20210811172552838"></p>
<p><img src="https://gitee.com/jwz--jwz/cloud-img/raw/master/image/202201222321793.png" alt="image-20210811172603353"></p>
<h3 id="final关键字："><a href="#final关键字：" class="headerlink" title="final关键字："></a>final关键字：</h3><p>[浅析Java中的final关键字 - Matrix海子 - 博客园 (cnblogs.com)](<a target="_blank" rel="noopener" href="https://www.cnblogs.com/dolphin0520/p/3736238.html#:~:text=%E4%B8%80.final%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95">https://www.cnblogs.com/dolphin0520/p/3736238.html#:~:text=一.final关键字的基本用法</a>. 在Java中，final关键字可以用来修饰类、方法和变量（包括成员变量和局部变量）。. 下面就从这三个方面来了解一下final关键字的基本用法。. 当用final修饰一个类时，表明这个类不能被继承。.,也就是说，如果一个类你永远不会让他被继承，就可以用final进行修饰。. final类中的成员变量可以根据需要设为final，但是要注意final类中的所有成员方法都会被隐式地指定为final方法。. 在使用final修饰类的时候，要注意谨慎选择，除非这个类真的在以后不会用来继承或者出于安全的考虑，尽量不要将类设计为final类。. 下面这段话摘自《Java编程思想》第四版第143页：.)</p>
<h3 id="static-关键字："><a href="#static-关键字：" class="headerlink" title="static 关键字："></a>static 关键字：</h3><h4 id="目的："><a href="#目的：" class="headerlink" title="目的："></a>目的：</h4><ul>
<li><p>​    当只想用一个内存区去保存一个特定的数据（无论创建多少个对象，甚至根本不用去创建对象）</p>
</li>
<li><p>​     与该类没有任何的对象的关联，即使没有创建对象，也能够调用方法</p>
</li>
</ul>
<h4 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h4><ul>
<li><p> static修饰的代码块、变量、方法内部类在类加载的期间就已经完成了初始化，存储在堆中的静态存储区，static优于对象而存在</p>
</li>
<li><p>static修饰的（变量和成员方法）被所有的对象所共享，也叫静态变量或静态方法</p>
</li>
</ul>
<h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景:"></a>使用场景:</h4><p>static 是一个修饰符，常常用来修饰变量和方法，如在开发过程中常常static 来进行修饰，如 工具类的方法，如DateUtils,StringUtils这类的工具方法会用到static来进行修饰</p>
<p>static 变量</p>
<p>static 方法</p>
<p>static 代码块</p>
<p>static  内部类</p>
<p>static  包内导入</p>
<h5 id="static变量："><a href="#static变量：" class="headerlink" title="static变量："></a>static变量：</h5><p>随着类的加载而存在，随着类的消失而消失，当类被加载的时候，就会在Java heap中分配内存空间，静态变量被所有的 对象 进行共享，一个值改动，就会改变另一个对象的取值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> eyeNum;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> legNum = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getEyeNum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> eyeNum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setEyeNum</span><span class="params">(<span class="keyword">int</span> eyeNum)</span> </span>&#123;</span><br><span class="line">        Person.eyeNum = eyeNum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Person person = <span class="keyword">new</span> Person();</span><br><span class="line">    person.setEyeNum(<span class="number">25</span>);</span><br><span class="line"></span><br><span class="line">    Person person1 = <span class="keyword">new</span> Person();</span><br><span class="line">    person1.setEyeNum(<span class="number">28</span>);</span><br><span class="line">    System.out.println(person.getEyeNum());<span class="comment">//28</span></span><br><span class="line">    System.out.println(person1.getEyeNum());<span class="comment">//28</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> legNum = person.legNum;</span><br><span class="line">    System.out.println(legNum);<span class="comment">//2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="什么时候使用static变量"><a href="#什么时候使用static变量" class="headerlink" title="什么时候使用static变量"></a>什么时候使用static变量</h6><p>作为共享变量去使用，通过常和final关键字使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String GENERAL_MAN = <span class="string">&quot;man&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>减少对象的创建，比如在类开头的部分，定义Logger方法，用于异常日志采集：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Logger LOGGER = LogFactory.getLoggger(MyClass.class);</span><br></pre></td></tr></table></figure>

<h5 id="static方法："><a href="#static方法：" class="headerlink" title="static方法："></a>static方法：</h5><ul>
<li><p>静态方法只能访问静态成员或静态方法</p>
</li>
<li><p>非静态方法既可以访问静态方法也可以访问非静态方</p>
</li>
</ul>
<h6 id="什么时候使用static方法："><a href="#什么时候使用static方法：" class="headerlink" title="什么时候使用static方法："></a>什么时候使用static方法：</h6><p>static方法一般用于与当前对象无法的工厂方法、工具方法。如Math.sqrt()，Arrays.sort()，StringUtils.isEmpty()等。</p>
<h5 id="static-代码块："><a href="#static-代码块：" class="headerlink" title="static 代码块："></a>static 代码块：</h5><p>static代码块在加载一个类的时候最先执行，且只执行一次。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Map&lt;String, String&gt; timeTypes;</span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">	timeTypes = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    timeTypes.put(<span class="string">&quot;year&quot;</span>, <span class="string">&quot;年&quot;</span>);</span><br><span class="line">    timeTypes.put(<span class="string">&quot;quarter&quot;</span>, <span class="string">&quot;季&quot;</span>);</span><br><span class="line">    timeTypes.put(<span class="string">&quot;month&quot;</span>, <span class="string">&quot;月&quot;</span>);</span><br><span class="line">    timeTypes.put(<span class="string">&quot;day&quot;</span>, <span class="string">&quot;日&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;初始化1&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	System.out.println(<span class="string">&quot;初始化2&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="JAVA集合："><a href="#JAVA集合：" class="headerlink" title="JAVA集合："></a>JAVA集合：</h2><p>​            <img src="https://gitee.com/jwz--jwz/cloud-img/raw/master/image/202201222321307.png" alt="image-20210817083225749"></p>
<p><img src="https://gitee.com/jwz--jwz/cloud-img/raw/master/image/202201222321124.png" alt="image-20210817083243280"></p>
<p><img src="https://gitee.com/jwz--jwz/cloud-img/raw/master/image/202201222321831.png" alt="image-20210818210531421"></p>
<h2 id="1-2-Collection-子接口"><a href="#1-2-Collection-子接口" class="headerlink" title="1.2. Collection 子接口"></a>1.2. Collection 子接口</h2><p>Collection: 是单列集合</p>
<h3 id="list"><a href="#list" class="headerlink" title="list:"></a>list:</h3><h4 id="1-2-1-什么是List"><a href="#1-2-1-什么是List" class="headerlink" title="1.2.1: 什么是List:"></a>1.2.1: 什么是List:</h4><p>   List: 元素是有序的(元素存取是有序)、可重复. 有序的 collection，可以对列表中每个元素的插入位置进行精确地控制。可以根据元素的整数索引（在列表中的位置）访问元素，并搜索列表中的元素。可存放重复元素，元素存取是有序的。</p>
<h4 id="1-2-2-List接口中常用类："><a href="#1-2-2-List接口中常用类：" class="headerlink" title="1.2.2:  List接口中常用类："></a>1.2.2:  List接口中常用类：</h4><h4 id="1-2-3-arraylist扩容"><a href="#1-2-3-arraylist扩容" class="headerlink" title="1.2.3:arraylist扩容"></a>1.2.3:arraylist扩容</h4><p><img src="https://gitee.com/jwz--jwz/cloud-img/raw/master/image/202201222321510.png" alt="image-20210818082036011"></p>
<p>小结： jdk7中的arrayList的对象创建的类似于单例的饿汉模式， 而jdk8中的ArrayList的对象中的类似于单例模式的懒汉式，延迟了数组的创建</p>
<h5 id="源码分析："><a href="#源码分析：" class="headerlink" title="源码分析："></a>源码分析：</h5><h6 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h6><p>​        jdk 1.8扩容的机制为，arrayList在初始化时没有进行初始化默认赋值，而是赋予空的数组，无参构造时使用的空数组，有参创建一个该范围的数组，在添加函数中，如果开始时，小于10.初始化为10，但最小的minCapacity 大于了 数组长度，就需要进行扩容，扩容机制为原来的1.5 倍，如果扩容之后还是比原来的数据小，那就是原来的数据 ，超过则指定为Integer的最大值，否则指定为限制容量大小，之后复制元素</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Default initial capacity.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="comment">//在添加过程个中，如果是空参构造默认赋值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>；</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Shared empty array instance used for empty instances.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="comment">//空实例时的共享数据默认初始</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Shared empty array instance used for default sized empty instances. We</span></span><br><span class="line"><span class="comment">     * distinguish this from EMPTY_ELEMENTDATA to know how much to inflate when</span></span><br><span class="line"><span class="comment">     * first element is added.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">     <span class="comment">//用于区分实例化时默认指定值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The array buffer into which the elements of the ArrayList are stored.</span></span><br><span class="line"><span class="comment">     * The capacity of the ArrayList is the length of this array buffer. Any</span></span><br><span class="line"><span class="comment">     * empty ArrayList with elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA</span></span><br><span class="line"><span class="comment">     * will be expanded to DEFAULT_CAPACITY when the first element is added.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//存储数据的列表</span></span><br><span class="line">    <span class="keyword">transient</span> Object[] elementData; <span class="comment">// non-private to simplify nested class access</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The size of the ArrayList (the number of elements it contains).</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@serial</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">    </span><br><span class="line"><span class="comment">//将元素添加至数组末尾</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    <span class="comment">//   给数组赋值</span></span><br><span class="line">        elementData[size++] = e;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>得到最小的扩容量</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">          <span class="comment">// 获取默认的容量和传入参数的较大值，初始化值为10</span></span><br><span class="line">        minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ensureExplicitCapacity(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>判断是否需要进行扩容（如果初始值为10，那么直到添加到11 个元素才需要进行扩容）:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//判断是否需要扩容</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">       modCount++;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//如果添加元素之后，比较元素大小，判断是否需要进行扩容</span></span><br><span class="line">       <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">           <span class="comment">//调用grow方法进行扩容，调用此方法代表已经开始扩容了</span></span><br><span class="line">           grow(minCapacity);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>扩容函数grow()：</p>
<p>​        </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="comment">// oldCapacity为旧容量，newCapacity为新容量</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="comment">//位运算的速度远远快于整除运算，整句运算式的结果就是将新容量更新为旧容量的1.5倍，右移一位相当于除以2</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">     <span class="comment">//然后检查新容量是否大于最小需要容量，若还是小于最小需要容量，那么就把最小需要容量当作数组的新容量</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    </span><br><span class="line">   <span class="comment">// 如果新容量大于 MAX_ARRAY_SIZE,进入(执行) `hugeCapacity()` 方法来比较 minCapacity 和 MAX_ARRAY_SIZE，</span></span><br><span class="line">   <span class="comment">//如果minCapacity大于最大容量，则新容量则为`Integer.MAX_VALUE`，否则，新容量大小则为 MAX_ARRAY_SIZE 即为 `Integer.MAX_VALUE - 8`</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="LinkedList-双向链表-："><a href="#LinkedList-双向链表-：" class="headerlink" title="LinkedList(双向链表)："></a>LinkedList(双向链表)：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    E item;</span><br><span class="line">    Node&lt;E&gt; next;</span><br><span class="line">    Node&lt;E&gt; prev;</span><br><span class="line">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.item = element;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">        <span class="keyword">this</span>.prev = prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><img src="https://gitee.com/jwz--jwz/cloud-img/raw/master/image/202201222322888.png"></p>
<h4 id="vector"><a href="#vector" class="headerlink" title="vector():"></a>vector():</h4><p>  扩容是原来的两倍</p>
<h3 id="Set接口："><a href="#Set接口：" class="headerlink" title="Set接口："></a>Set接口：</h3><h4 id="什么是set"><a href="#什么是set" class="headerlink" title="什么是set"></a>什么是set</h4><p> 存储无序的、不可重复的对象：</p>
<ul>
<li>HashSet 是set接口的典型的实例，大多数使用Set集合都是</li>
<li>按hash算法来存储集合中的元素，具有很好的存储、删除、查找、删除的性能</li>
</ul>
<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul>
<li>不能够保证元素的排列的顺序</li>
<li>HashSet不是线程安全的</li>
<li>集合的元素可以为空值</li>
</ul>
<p>判断两个元素相等的标准，通过hashcode()方法比较，并且两个对象的quals()方法也相同</p>
<p>相等的对象一定具有相等的散列码</p>
<p>​    hashset :</p>
<p>​               LinkedHashSet:作为HashSet的子类，遍历内部的数据是，可以按照添加的顺序遍历</p>
<p>​     TreeSet:可以按照添加的指定属性，进行排序</p>
<h3 id="hashset："><a href="#hashset：" class="headerlink" title="hashset："></a>hashset：</h3><p>线程不安全，内部是基于<strong>散列函数</strong>实现,存取速度快。它是如何保证元素唯一性的呢？依赖的是元素的hashCode方法和euqals方法。</p>
<p>底层是hashMap</p>
<p><img src="https://gitee.com/jwz--jwz/cloud-img/raw/master/image/202201222322519.png" alt="image-20210818215627841"></p>
<p>先进行hash值比较，在进行equals比较</p>
<p><img src="https://gitee.com/jwz--jwz/cloud-img/raw/master/image/202201222322632.png" alt="image-20210818215733459"></p>
<p>hashcode:</p>
<p><img src="https://gitee.com/jwz--jwz/cloud-img/raw/master/image/202201222322579.png" alt="image-20210818221115967"></p>
<p><img src="https://gitee.com/jwz--jwz/cloud-img/raw/master/image/202201222322662.png" alt="image-20210818221238854"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">(Object a[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Object element : a)</span><br><span class="line">        result = <span class="number">31</span> * result + (element == <span class="keyword">null</span> ? <span class="number">0</span> : element.hashCode());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="treeSet"><a href="#treeSet" class="headerlink" title="treeSet:"></a>treeSet:</h3><p>​             按照对象的不同属性进行排序</p>
<p>​             两种排序：自然排序，定制排序</p>
<p>​            重写排序之后，如果你直接添加元素，会进行自动排序，下面是二级排序，如果有一个属性相同，就不会插入，因为是一个树形结构</p>
<p><img src="https://gitee.com/jwz--jwz/cloud-img/raw/master/image/202201222322996.png" alt="image-20210818221954348"></p>
<p><img src="https://gitee.com/jwz--jwz/cloud-img/raw/master/image/202201222322407.png" alt="image-20210818222237587"></p>
<h3 id="Map接口："><a href="#Map接口：" class="headerlink" title="Map接口："></a>Map接口：</h3><h4 id="hashMap"><a href="#hashMap" class="headerlink" title="hashMap:"></a>hashMap:</h4><p>工作原理</p>
<p>  jdk7  调用hashcode()计算key1的hash 值，此哈希值相同经过算法计算以后，</p>
<p>HashMap 在map。entry静态内部类实现中存储key-value,时，HashMap使用哈希算法，当我们使用key时候，通过调用hashcode()和hash算法，先找出索引，如果不一样，添加成功，否者</p>
<p>，找到同一个桶之后，使用quals检验值是否存在，如果存在，会覆盖value,如果不存在，会创建一个新的entry(包括属性有;key ,value,next) 属性。默认扩容为原来的两倍</p>
<p><img src="https://gitee.com/jwz--jwz/cloud-img/raw/master/image/202201222322911.png"></p>
<p>jdk 相较于jdk7在底层实现的方面的不同：</p>
<p>1、new HashMap()：底层没有创建一个长度为16 的数组</p>
<p>2、jdk 8 底层是 Node[] 不是entry</p>
<p>3、首次调用put 方法时，底层创建长度为16的数组</p>
<p>4、jdk7底层结构数组链表，jdk8 中的底层：数组+链表+红黑树</p>
<p>为了避免链表过长，查询速度变为了线性，      当数组上的某一索引元素以链表的形式存在的数据个数大于&gt;8 ,且当前的长度&gt;64 此时索引的位置上的说有数据改为红黑树</p>
<p><img src="https://gitee.com/jwz--jwz/cloud-img/raw/master/image/202201222322480.png" alt="image-20210819090458603"></p>
<h4 id="对HashMap中put-get方法的认识？"><a href="#对HashMap中put-get方法的认识？" class="headerlink" title="对HashMap中put/get方法的认识？"></a>对HashMap中put/get方法的认识？</h4><h4 id="HashMa"><a href="#HashMa" class="headerlink" title="HashMa"></a>HashMa</h4><p><img src="https://gitee.com/jwz--jwz/cloud-img/raw/master/image/202201222322221.png" alt="image-20210820200517223"></p>
<h3 id="jdk8"><a href="#jdk8" class="headerlink" title="jdk8:"></a>jdk8:</h3><p> 底层存储数据使用的是node:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//    </span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">        <span class="keyword">final</span> K key;</span><br><span class="line">        V value;</span><br><span class="line">        Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">        Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">            <span class="keyword">this</span>.hash = hash;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="put方法："><a href="#put方法：" class="headerlink" title="put方法："></a>put方法：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        <span class="comment">//首次初始化数组</span></span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">         <span class="comment">//找到当前数组的元素值</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="resize"><a href="#resize" class="headerlink" title="resize:"></a>resize:</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="LinkedHashMap的底层原理（待完成）："><a href="#LinkedHashMap的底层原理（待完成）：" class="headerlink" title="LinkedHashMap的底层原理（待完成）："></a>LinkedHashMap的底层原理（待完成）：</h4><h3 id="map常用方法："><a href="#map常用方法：" class="headerlink" title="map常用方法："></a>map常用方法：</h3><p><img src="https://gitee.com/jwz--jwz/cloud-img/raw/master/image/202201222322198.png" alt="image-20210820203510349"></p>
<h3 id="1-1-3-集合框架底层数据结构总结"><a href="#1-1-3-集合框架底层数据结构总结" class="headerlink" title="1.1.3. 集合框架底层数据结构总结"></a>1.1.3. 集合框架底层数据结构总结</h3><h4 id="1-1-3-1-List"><a href="#1-1-3-1-List" class="headerlink" title="1.1.3.1. List"></a>1.1.3.1. List</h4><ul>
<li><code>Arraylist</code>： <code>Object[]</code> 数组         线程不安全，查询速度快。底层数据结构是数组结构 底层使用<code>Object[ ]</code> 存储 </li>
<li><code>Vector</code>：<code>Object[]</code> 数组  线程安全，但速度慢，已被ArrayList替代</li>
<li><code>LinkedList</code>： 双向链表(JDK1.6 之前为循环链表，JDK1.7 取消了循环,线程不安全。增删速度快。底层数据结构是<strong>链表结构</strong></li>
</ul>
<h4 id="1-1-3-2-Set"><a href="#1-1-3-2-Set" class="headerlink" title="1.1.3.2. Set"></a>1.1.3.2. Set</h4><ul>
<li><code>HashSet</code>(无序，唯一): 基于 <code>HashMap</code> 实现的，底层采用 <code>HashMap</code> 来保存元素</li>
<li><code>LinkedHashSet</code>: <code>LinkedHashSet</code> 是 <code>HashSet</code> 的子类，并且其内部是通过 <code>LinkedHashMap</code> 来实现的。有点类似于我们之前说的 <code>LinkedHashMap</code> 其内部是基于 <code>HashMap</code> 实现一样，不过还是有一点点区别的</li>
<li><code>TreeSet</code>(有序，唯一): 红黑树(自平衡的排序二叉树)</li>
</ul>
<h4 id="1-1-3-3-Queue"><a href="#1-1-3-3-Queue" class="headerlink" title="1.1.3.3 Queue"></a>1.1.3.3 Queue</h4><ul>
<li><code>PriorityQueue</code>: <code>Object[]</code> 数组来实现二叉堆</li>
<li><code>ArrayQueue</code>: <code>Object[]</code> 数组 + 双指针</li>
</ul>
<p>再来看看 <code>Map</code> 接口下面的集合。</p>
<h4 id="1-1-3-4-Map"><a href="#1-1-3-4-Map" class="headerlink" title="1.1.3.4. Map"></a>1.1.3.4. Map</h4><ul>
<li><code>HashMap</code>： JDK1.8 之前 <code>HashMap</code> 由数组+链表组成的，数组是 <code>HashMap</code> 的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）。JDK1.8 以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间</li>
<li><code>LinkedHashMap</code>： <code>LinkedHashMap</code> 继承自 <code>HashMap</code>，所以它的底层仍然是基于拉链式散列结构即由数组和链表或红黑树组成。另外，<code>LinkedHashMap</code> 在上面结构的基础上，增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。详细可以查看：<a target="_blank" rel="noopener" href="https://www.imooc.com/article/22931">《LinkedHashMap 源码详细分析（JDK1.8）》</a></li>
<li><code>Hashtable</code>： 数组+链表组成的，数组是 <code>Hashtable</code> 的主体，链表则是主要为了解决哈希冲突而存在的</li>
<li><code>TreeMap</code>： 红黑树（自平衡的排序二叉树）</li>
</ul>
<h3 id="1-1-2-说说-List-Set-Queue-Map-四者的区别？"><a href="#1-1-2-说说-List-Set-Queue-Map-四者的区别？" class="headerlink" title="1.1.2. 说说 List, Set, Queue, Map 四者的区别？"></a>1.1.2. 说说 List, Set, Queue, Map 四者的区别？</h3><ul>
<li><code>List</code>(对付顺序的好帮手): 存储的元素是有序的、可重复的。</li>
<li><code>Set</code>(注重独一无二的性质): 存储的元素是无序的、不可重复的。</li>
<li><code>Queue</code>(实现排队功能的叫号机): 按特定的排队规则来确定先后顺序，存储的元素是有序的、可重复的。</li>
<li><code>Map</code>(用 key 来搜索的专家): 使用键值对（key-value）存储，类似于数学上的函数 y=f(x)，”x” 代表 key，”y” 代表 value，key 是无序的、不可重复的，value 是无序的、可重复的，每个键最多映射到一个值。</li>
</ul>
<h3 id="1-2-1-Arraylist-和-Vector-的区别"><a href="#1-2-1-Arraylist-和-Vector-的区别" class="headerlink" title="1.2.1. Arraylist 和 Vector 的区别?"></a>1.2.1. Arraylist 和 Vector 的区别?</h3><ul>
<li><code>ArrayList</code> 是 <code>List</code> 的主要实现类，底层使用 <code>Object[ ]</code>存储，适用于频繁的查找工作，效率高   线程不安全 ,；</li>
<li><code>Vector</code> 是 <code>List</code> 的古老实现类，底层使用<code>Object[ ]</code> 存储，使用synchronized效率低线程安全的。</li>
</ul>
<h3 id="1-2-2-Arraylist-与-LinkedList-区别"><a href="#1-2-2-Arraylist-与-LinkedList-区别" class="headerlink" title="1.2.2. Arraylist 与 LinkedList 区别?"></a>1.2.2. Arraylist 与 LinkedList 区别?</h3><ol>
<li><strong>是否保证线程安全：</strong> <code>ArrayList</code> 和 <code>LinkedList</code> 都是不同步的，也就是不保证线程安全；</li>
<li><strong>底层数据结构：</strong> <code>Arraylist</code> 底层使用的是 <strong><code>Object</code> 数组</strong>；<code>LinkedList</code> 底层使用的是 <strong>双向链表</strong> 数据结构（JDK1.6 之前为循环链表，JDK1.7 取消了循环。注意双向链表和双向循环链表的区别，下面有介绍到！）</li>
<li>插入和删除是否受元素位置的影响：<ul>
<li><code>ArrayList</code> 采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响。 比如：执行<code>add(E e)</code>方法的时候， <code>ArrayList</code> 会默认在将指定的元素追加到此列表的末尾，这种情况时间复杂度就是 O(1)。但是如果要在指定位置 i 插入和删除元素的话（<code>add(int index, E element)</code>）时间复杂度就为 O(n-i)。因为在进行上述操作的时候集合中第 i 和第 i 个元素之后的(n-i)个元素都要执行向后位/向前移一位的操作。</li>
<li><code>LinkedList</code> 采用链表存储，所以，如果是在头尾插入或者删除元素不受元素位置的影响（<code>add(E e)</code>、<code>addFirst(E e)</code>、<code>addLast(E e)</code>、<code>removeFirst()</code> 、 <code>removeLast()</code>），近似 O(1)，如果是要在指定位置 <code>i</code> 插入和删除元素的话（<code>add(int index, E element)</code>，<code>remove(Object o)</code>） 时间复杂度近似为 O(n) ，因为需要先移动到指定位置再插入。</li>
</ul>
</li>
<li><strong>是否支持快速随机访问：</strong> <code>LinkedList</code> 不支持高效的随机元素访问，而 <code>ArrayList</code> 支持。快速随机访问就是通过元素的序号快速获取元素对象(对应于<code>get(int index)</code>方法)。</li>
<li><strong>内存空间占用：</strong> ArrayList 的空 间浪费主要体现在在 list 列表的结尾会预留一定的容量空间，而 LinkedList 的空间花费则体现在它的每一个元素都需要消耗比 ArrayList 更多的空间（因为要存放直接后继和直接前驱以及数据）。</li>
</ol>
<h3 id="1-2-2-负载因子值的大小，对HashMap有什么影响？"><a href="#1-2-2-负载因子值的大小，对HashMap有什么影响？" class="headerlink" title="1.2.2. 负载因子值的大小，对HashMap有什么影响？"></a>1.2.2. 负载因子值的大小，对HashMap有什么影响？</h3><p>​       负载因子的大小决定了HashMap的数据密度</p>
<p>​       负载因子越大密度越大，发生碰撞的几率越高，数组中的链表越容易长，造成查询或插入时的比较次数也越小，性能会更高，但是会浪费一定的内容空间。而且经常扩容会影响性能建议初始化预设大一点的空间</p>
<p>​        按照其他语言的参考及研究，会考虑将负载因子设置为0.7~0.75，此时平均检索长度接近于常数</p>
<p>​        </p>
<h2 id="Collections常用方法："><a href="#Collections常用方法：" class="headerlink" title="Collections常用方法："></a>Collections常用方法：</h2><h3 id="Collections-工具类常用方法"><a href="#Collections-工具类常用方法" class="headerlink" title="Collections 工具类常用方法:"></a>Collections 工具类常用方法:</h3><ol>
<li>排序</li>
<li>查找,替换操作</li>
<li>同步控制(不推荐，需要线程安全的集合类型时请考虑使用 JUC 包下的并发集合)</li>
</ol>
<h4 id="查找-替换操作"><a href="#查找-替换操作" class="headerlink" title="查找,替换操作"></a>查找,替换操作</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverse</span><span class="params">(List)</span>:反转List中元素的顺序</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">shuffle</span><span class="params">(List)</span>:对List集合元素进行随机排序</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(List)</span>:根据元素的自然顺序对指定List集合元素按升序排序</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(List，Comparator)</span>:根据指定的Comparator产生的顺序对List集合元素进行排序</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(List，<span class="keyword">int</span>，<span class="keyword">int</span>)</span>:将指定list集合中的i处元素和j处元素进行交换</span></span><br></pre></td></tr></table></figure>

<h4 id="查找替换操作："><a href="#查找替换操作：" class="headerlink" title="查找替换操作："></a>查找替换操作：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(List list, Object key)</span><span class="comment">//对List进行二分查找，返回索引，注意List必须是有序的</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(Collection coll)</span><span class="comment">//根据元素的自然顺序，返回最大的元素。 类比int min(Collection coll)</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(Collection coll, Comparator c)</span><span class="comment">//根据定制排序，返回最大元素，排序规则由Comparatator类控制。类比int min(Collection coll, Comparator c)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fill</span><span class="params">(List list, Object obj)</span><span class="comment">//用指定的元素代替指定list中的所有元素</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">frequency</span><span class="params">(Collection c, Object o)</span><span class="comment">//统计元素出现次数</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">indexOfSubList</span><span class="params">(List list, List target)</span><span class="comment">//统计target在list中第一次出现的索引，找不到则返回-1，类比int lastIndexOfSubList(List source, list target)</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">replaceAll</span><span class="params">(List list, Object oldVal, Object newVal)</span><span class="comment">//用新元素替换旧元素</span></span></span><br><span class="line"><span class="function">   <span class="keyword">void</span> <span class="title">copy</span><span class="params">(List dest,Lsit src)</span>:将src的内容复制到dest中</span></span><br></pre></td></tr></table></figure>

<h3 id="同步控制"><a href="#同步控制" class="headerlink" title="同步控制:"></a>同步控制:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Collections 提供了多个synchronizedXxx()方法·，该方法可以将指定集合包装成线程同步的集合，从而解决多线程并发访问集合时的线程安全问题。</span><br><span class="line"></span><br><span class="line">我们知道 HashSet，TreeSet，ArrayList,LinkedList,HashMap,TreeMap 都是线程不安全的。Collections 提供了多个静态方法可以把他们包装成线程同步的集合。</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">synchronizedCollection(Collection&lt;T&gt;  c) <span class="comment">//返回指定 collection 支持的同步（线程安全的）collection。</span></span><br><span class="line">synchronizedList(List&lt;T&gt; list)<span class="comment">//返回指定列表支持的同步（线程安全的）List。</span></span><br><span class="line">synchronizedMap(Map&lt;K,V&gt; m) <span class="comment">//返回由指定映射支持的同步（线程安全的）Map。</span></span><br><span class="line">synchronizedSet(Set&lt;T&gt; s) <span class="comment">//返回指定 set 支持的同步（线程安全的）set。</span></span><br></pre></td></tr></table></figure>



<h2 id="枚举类和注解："><a href="#枚举类和注解：" class="headerlink" title="枚举类和注解："></a>枚举类和注解：</h2><h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>类的对象只有有限个，确定的</p>
<p>当需要进行定义一组常量时，强烈建议使用枚举类：</p>
<p>如何自定义枚举：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//类的对象只有有限个,确定的</span><br><span class="line">//当需要进行定义一组常量时，强烈建议使用枚举类</span><br><span class="line">//如果枚举类中只有一个对象，可以作为单例模式的实现方式</span><br></pre></td></tr></table></figure>

<h4 id="如何使用关键字enum定义枚举类"><a href="#如何使用关键字enum定义枚举类" class="headerlink" title="如何使用关键字enum定义枚举类;"></a>如何使用关键字enum定义枚举类;</h4><h5 id="使用关键字："><a href="#使用关键字：" class="headerlink" title="使用关键字："></a>使用关键字：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类的对象只有有限个,确定的</span></span><br><span class="line"><span class="comment">//当需要进行定义一组常量时，强烈建议使用枚举类</span></span><br><span class="line"><span class="comment">//如果枚举类中只有一个对象，可以作为单例模式的实现方式</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">TestByEnum</span> </span>&#123;</span><br><span class="line">    SYS_CONFIG(<span class="string">&quot;系统配置&quot;</span>,<span class="string">&quot;sys_config&quot;</span>),</span><br><span class="line">    ADMIN_LOGIN(<span class="string">&quot;后台登录&quot;</span>,<span class="string">&quot;admin_login&quot;</span>),</span><br><span class="line">    ADMIN_UI(<span class="string">&quot;后台样式&quot;</span>,<span class="string">&quot;admin_ui&quot;</span>),</span><br><span class="line">    WECHAT_DEV(<span class="string">&quot;微信开发&quot;</span>,<span class="string">&quot;wechat_dev&quot;</span>);</span><br><span class="line">    <span class="keyword">private</span> String text;</span><br><span class="line">    <span class="keyword">private</span> String value;</span><br><span class="line"><span class="comment">//    定义你的常量的类型</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">TestByEnum</span><span class="params">(String text,String value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.text=text;</span><br><span class="line">        <span class="keyword">this</span>.value=value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getText</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> text;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setText</span><span class="params">(String text)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.text = text;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(String value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;TestByEnum&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;text=&#x27;&quot;</span> + text + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, value=&#x27;&quot;</span> + value + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h6 id="test"><a href="#test" class="headerlink" title="test:"></a>test:</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title">TestEnum</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(Enum.Spring.toString());</span><br><span class="line">        TestByEnum[] values = TestByEnum.values();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; values.length; i++) &#123;</span><br><span class="line">            System.out.println(values[i].getValue());</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    使用关键字来进行定义</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="使用自定义："><a href="#使用自定义：" class="headerlink" title="使用自定义："></a>使用自定义：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> wz.TestEnum;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Enum</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    方式一： jdk5.0 自定义枚举类</span></span><br><span class="line"><span class="comment">//    方式二，可以使用enum关键字定义枚举类</span></span><br><span class="line"><span class="comment">//    自定义枚举类</span></span><br><span class="line"></span><br><span class="line">     <span class="keyword">private</span>  <span class="keyword">final</span>  String seasonName;</span><br><span class="line">     <span class="keyword">private</span>  <span class="keyword">final</span>  String seasonDesc;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Enum</span><span class="params">(String seasonName,String seasonDesc)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.seasonName = seasonName;</span><br><span class="line">        <span class="keyword">this</span>.seasonDesc = seasonDesc;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//   提供当前枚举类的多个对象</span></span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">final</span> Enum Spring = <span class="keyword">new</span> Enum(<span class="string">&quot;春天&quot;</span>,<span class="string">&quot;sss&quot;</span>);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getSeasonName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> seasonName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getSeasonDesc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> seasonDesc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Enum&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;seasonName=&#x27;&quot;</span> + seasonName + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, seasonDesc=&#x27;&quot;</span> + seasonDesc + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="注解："><a href="#注解：" class="headerlink" title="注解："></a>注解：</h3><p>●注解(Annotation)概述·</p>
<p>​    jdk5.0 开始</p>
<blockquote>
<p>Annotation其实就是代码里的特殊标记,这些标记可以在编译,类加载,运行时被读取,并执行相应的处理。通过使用Annotation,程序员可以在不改变原有逻辑的情况下,在源文件中嵌入一些补充信息。代码分析工具、开发工具和部署工具可以通过这些补充信息进行验证或者进行部署。</p>
<p>Annotation可以像修饰符一样被使用,可用于修饰包,类,构造器,方法,成员变量,参数,局部变量的声明,这些信息被保存在Annotation的“name=value”对中。</p>
</blockquote>
<p>框架 =注解+ 反射+设计模式</p>
<p>●自定义AnnotationJDK中的元注解</p>
<p>自定义注解通常都会指明两个元注解：retention、target</p>
<ul>
<li>利用反射获取注解信息（在反射部分涉及)</li>
</ul>
<p>●JDK 8中注解的新特性</p>
<h3 id="元数据"><a href="#元数据" class="headerlink" title="元数据"></a>元数据</h3><h5 id="retention"><a href="#retention" class="headerlink" title="@retention:"></a>@retention:</h5><h4 id="指定所修饰的annotation的生命周期：source-class-只有声明为runtime-生命周期的注解，才能通过反射"><a href="#指定所修饰的annotation的生命周期：source-class-只有声明为runtime-生命周期的注解，才能通过反射" class="headerlink" title="指定所修饰的annotation的生命周期：source\class,只有声明为runtime 生命周期的注解，才能通过反射"></a>指定所修饰的annotation的生命周期：source\class,只有声明为runtime 生命周期的注解，才能通过反射</h4><h5 id="target"><a href="#target" class="headerlink" title="@target:"></a>@target:</h5><p>   用于指定被修饰的Annotation能用于修饰哪些程序元素</p>
<p><img src="https://gitee.com/jwz--jwz/cloud-img/raw/master/image/202201222322463.png" alt="image-20210821200035996"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">ElementType</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** Class, interface (including annotation type), or enum declaration */</span></span><br><span class="line">    TYPE,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Field declaration (includes enum constants) */</span></span><br><span class="line">   <span class="comment">//属性</span></span><br><span class="line">    FIELD,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Method declaration */</span></span><br><span class="line">   <span class="comment">//方法</span></span><br><span class="line">    METHOD,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Formal parameter declaration */</span></span><br><span class="line">    <span class="comment">//私有的</span></span><br><span class="line">    PARAMETER,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Constructor declaration */</span></span><br><span class="line">    <span class="comment">//构造函数</span></span><br><span class="line">    CONSTRUCTOR,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Local variable declaration */</span></span><br><span class="line">    <span class="comment">//本地变量</span></span><br><span class="line">    LOCAL_VARIABLE,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Annotation type declaration */</span></span><br><span class="line">    <span class="comment">//注释类型</span></span><br><span class="line">    ANNOTATION_TYPE,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Package declaration */</span></span><br><span class="line">    <span class="comment">//包注解</span></span><br><span class="line">    PACKAGE,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Type parameter declaration</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 1.8</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//类型注解，表示该注解能够写在类型变量的声明语句中（如：泛型的声明</span></span><br><span class="line">    TYPE_PARAMETER,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Use of a type</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 1.8</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//该注解能够写在使用类型的任何语句之中</span></span><br><span class="line">    TYPE_USE</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><img src="https://gitee.com/jwz--jwz/cloud-img/raw/master/image/202201222322713.png" alt="image-20210822094532788"></p>
<h5 id="Documented"><a href="#Documented" class="headerlink" title="@Documented:"></a>@Documented:</h5><p>用于指定被该元Annotation修饰的Annotation类将被javadoc工具提取成文档。默认情况下，javadoc是不包括注解的。&gt;定义为Documented的注解必须设置Retention值为RUNTIME。</p>
<h5 id="inherited"><a href="#inherited" class="headerlink" title="@inherited"></a>@inherited</h5><p> 修饰的Annotation将具有继承性，如果某个类使用了被该注解修饰的Annotion，那么其子类将自动具有该注解</p>
<blockquote>
<p>比如:如果把标有@Inherited注解的自定义的注解标注在类级别上，子类则可以继承父类类级别的注解</p>
</blockquote>
<h3 id="利用反射获取信息："><a href="#利用反射获取信息：" class="headerlink" title="利用反射获取信息："></a>利用反射获取信息：</h3><p>当一个Annotation类型被定义为运行时annotation后，该注解才是运行时可见，当class文件被载入时保存在class 文件中Annotation 才会被虚拟机读取</p>
<p>程序可以调用annotateElement对象来访问Annotation的信息</p>
<h3 id="jdk8中的新注解："><a href="#jdk8中的新注解：" class="headerlink" title="jdk8中的新注解："></a>jdk8中的新注解：</h3><h4 id="可重复注解："><a href="#可重复注解：" class="headerlink" title="可重复注解："></a>可重复注解：</h4><p>  1、在MyAnnotation上面声明@Repeatable,与成员值进行绑定 MyAnnotation.class</p>
<p><img src="C:\Users\jinweizhuo\AppData\Roaming\Typora\typora-user-images\image-20210822092853742.png" alt="image-20210822092853742"><img src="C:\Users\jinweizhuo\AppData\Roaming\Typora\typora-user-images\image-20210822093742882.png" alt="image-20210822093742882"></p>
<h4 id="类型注解："><a href="#类型注解：" class="headerlink" title="类型注解："></a>类型注解：</h4><p>​             <img src="https://gitee.com/jwz--jwz/cloud-img/raw/master/image/202201222323239.png" alt="image-20210822093246408"></p>
<p>注解样例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.jfinal.plugin.ehcache;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Documented;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.ElementType;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Inherited;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.RetentionPolicy;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * CacheName can configure CacheInterceptor&#x27;s cache name or EvictInterceptor&#x27;s evict cache name.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * The order of CacheInterceptor searching for CacheName annotation:&lt;br&gt;</span></span><br><span class="line"><span class="comment"> * 1: Action method of current invocation&lt;br&gt;</span></span><br><span class="line"><span class="comment"> * 2: Controller of the current invocation&lt;br&gt;</span></span><br><span class="line"><span class="comment"> * CacheInterceptor will use the actionKey as the cache name If the CacheName annotation not found. </span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> * CacheName可以配置CacheInterceptor的缓存名或victinterceptor的evict缓存名。</span></span><br><span class="line"><span class="comment">* &lt; p &gt;</span></span><br><span class="line"><span class="comment">* CacheInterceptor搜索CacheName注释的顺序:&lt;br&gt;</span></span><br><span class="line"><span class="comment">* 1:当前调用的动作方法&lt;br&gt;</span></span><br><span class="line"><span class="comment">2:当前调用的控制器&lt;br&gt;</span></span><br><span class="line"><span class="comment">*如果没有找到CacheName注释，CacheInterceptor会使用actionKey作为缓存名。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Inherited</span>  <span class="comment">//被修饰的注解将具备继承性</span></span><br><span class="line"><span class="meta">@Documented</span>  <span class="comment">//表示修饰的注解将被Javadoc解析时保留下来</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span><span class="comment">//指定修饰的生命周期</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)</span><span class="comment">//指定修饰的类型，适合哪个</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> CacheName &#123;</span><br><span class="line">	<span class="function">String <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h2 id="泛型："><a href="#泛型：" class="headerlink" title="泛型："></a>泛型：</h2><h3 id="1-1为什么要有泛型（Generic）："><a href="#1-1为什么要有泛型（Generic）：" class="headerlink" title="1.1为什么要有泛型（Generic）："></a>1.1为什么要有泛型（Generic）：</h3><p>​         在jdk1.5之前只能把元素类型设计为Object,把元素的类型设计成一个参数，从而达到能够对不同的对象进行重用</p>
<p>  所谓泛型：就是允许在定义类中、接口时通过一个标识符表示某个属性的类型或者某个方法的返回值以及参数类型 。这个类型将在使用时确定（例如： 继承或者实习这个接口用这个声明变量、创建对象）确定（传入实际的参数，也称为类型的参数）</p>
<p><img src="https://gitee.com/jwz--jwz/cloud-img/raw/master/image/202201222323721.png" alt="image-20210822113013534"></p>
<p><img src="https://gitee.com/jwz--jwz/cloud-img/raw/master/image/202201222323345.png" alt="image-20210822113221451"></p>
<p>如果没有使用泛型在取出时就会有问题</p>
<p><img src="https://gitee.com/jwz--jwz/cloud-img/raw/master/image/202201222323948.png" alt="image-20210822113354241"></p>
<p><img src="https://gitee.com/jwz--jwz/cloud-img/raw/master/image/202201222323470.png" alt="image-20210822113645205"></p>
<p>使用的时候只需要指定你要的什么类型，然后在进行使用</p>
<p><strong><img src="https://gitee.com/jwz--jwz/cloud-img/raw/master/image/202201222323769.png" alt="image-20210822171725315"></strong></p>
<h3 id="泛型嵌套："><a href="#泛型嵌套：" class="headerlink" title="泛型嵌套："></a>泛型嵌套：</h3><p><img src="https://gitee.com/jwz--jwz/cloud-img/raw/master/image/202201222323303.png" alt="image-20210823090328643"></p>
<h3 id="通配符的使用："><a href="#通配符的使用：" class="headerlink" title="通配符的使用："></a>通配符的使用：</h3><p>1、使用类型通配符：类型变量的限定 ,能够对指定的进行限制</p>
<p>   List&lt;? extends Object&gt;  其父类必须是Object  </p>
<p>对于List&lt;?&gt;不能够向其内部添加数据</p>
<p>//获取（读取）：允许读取数据，读取的数据为Object 类型</p>
<hr>
<p><img src="https://gitee.com/jwz--jwz/cloud-img/raw/master/image/202201222323199.png" alt="image-20210823081616708"></p>
<h4 id="通配符指定上限："><a href="#通配符指定上限：" class="headerlink" title="通配符指定上限："></a>通配符指定上限：</h4><h6 id="上限extends"><a href="#上限extends" class="headerlink" title="上限extends:"></a>上限extends:</h6><p>使用时指定的类型必须继承某个类，或者实现某个接口</p>
<h4 id="通配符指定下限："><a href="#通配符指定下限：" class="headerlink" title="通配符指定下限："></a>通配符指定下限：</h4><h6 id="下限super-s"><a href="#下限super-s" class="headerlink" title="下限super:s"></a>下限super:s</h6><p>使用时指定的类型不能小于操作的类</p>
 <? extends Number>(无穷小，Number)

​       只允许泛型为Number及Number子类的引用

<? super Number>

​       只允许泛型为Number及Number父类的引用

<? extends Comparable>

​      只允许泛型为实现Comparaable接口的实现类的引用

​       便于提取出 泛型的数据:

​     首先人的信息进行封装 ，能够给指定的人显示所需要显示的信息

![image-20210823090544107](https://gitee.com/jwz--jwz/cloud-img/raw/master/image/202201222323881.png)

![image-20210823090552698](https://gitee.com/jwz--jwz/cloud-img/raw/master/image/202201222323338.png)



![1573457377345671.png](https://gitee.com/jwz--jwz/cloud-img/raw/master/image/202201222323921.png)





<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这个只能传递T类型的数据</span></span><br><span class="line"><span class="comment">     * 返回值 就是Demo&lt;T&gt; 实例化传递的对象类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> T <span class="title">getListFisrt</span><span class="params">(List&lt;T&gt; data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (data == <span class="keyword">null</span> || data.size() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> data.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这个&lt;T&gt; T 可以传入任何类型的List</span></span><br><span class="line"><span class="comment">     * 参数T</span></span><br><span class="line"><span class="comment">     *     第一个 表示是泛型</span></span><br><span class="line"><span class="comment">     *     第二个 表示返回的是T类型的数据</span></span><br><span class="line"><span class="comment">     *     第三个 限制参数类型为T</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> &lt;T&gt; <span class="function">T <span class="title">getListFisrt</span><span class="params">(List&lt;T&gt; data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (data == <span class="keyword">null</span> || data.size() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> data.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

例如:

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//    将对象转换为字符串  Object--&gt;String</span></span><br><span class="line">&lt;T&gt; 声明泛型 返回值为string 传入值为 T型</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span>  &lt;T&gt; <span class="function">String <span class="title">obj2String</span><span class="params">(T src)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (src == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>  <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//            判断src是否为String,如果是,强转为string  如果不是调用jackson方法转换</span></span><br><span class="line">        <span class="keyword">return</span>  src <span class="keyword">instanceof</span> String ? (String) src: objectMapper.writeValueAsString(src);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">           <span class="keyword">return</span>  <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//      String --&gt; Object</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">string2Obj</span><span class="params">(String  src , TypeReference&lt;T&gt; typeReference)</span></span>&#123;</span><br><span class="line"><span class="comment">//        将string转换为为我们所需要的对象</span></span><br><span class="line">        <span class="keyword">if</span> (src == <span class="keyword">null</span>|| typeReference == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>  <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span>  (T)(typeReference.getType().equals(String.class)? src:objectMapper.readValue(src,typeReference));</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception exception)&#123;</span><br><span class="line">            exception.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>





## 设计模式：



创建型模式：工厂方法模式、抽象工厂模式、单例模式、建造者模式

结构型模式： 适配器模式、装饰器模式、代理模式、外观模式、组合模式、享乐

行为模式：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式状态模式、访问者模式、中介者模式、解释器模式

####  单例模式：

所谓类的单例设计模式，就是采取一定的方法保证在整个的软件系统中，对某个类只能存在一个对象实例，并且该类只提供一个取得其对象实例的方法。如果我们要让类在一个虚拟机中只能产生一个对象，我们首先必须将类的构造器的访问权限设置为private，这样，就不能用new操作符在类的外部产生类的对象了，但在类内部仍可以产生该类的对象。因为在类的外部开始还无法得到类的对象，只能调用该类的某个静态方法以返回类内部创建的对象，静态方法只能访问类中的静态成员变量，所以，指向类内部产生的该类对象的变量也必须定义成静态的。
让天不漫奇心学的技太

#####  懒汉式和饿汉式

懒汉式：

- 延迟去创建对象
- 线程不安全

饿汉式： 

- 坏处：对象的加载时间过长，一开始就加载

-  好处：线程是安全的

应用：

- 网站的计数器;
- 应用程序的日志文件

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Slf4jLogFilter slf4jLogFilter = <span class="keyword">new</span> Slf4jLogFilter();</span><br><span class="line">slf4jLogFilter.setConnectionLogEnabled(<span class="keyword">false</span>);</span><br><span class="line">slf4jLogFilter.setResultSetLogEnabled(<span class="keyword">false</span>);</span><br><span class="line">slf4jLogFilter.setStatementParameterSetLogEnabled(<span class="keyword">false</span>);</span><br><span class="line">slf4jLogFilter.setConnectionLogEnabled(<span class="keyword">false</span>);</span><br><span class="line">slf4jLogFilter.setResultSetCloseAfterLogEnabled(<span class="keyword">false</span>);</span><br><span class="line">slf4jLogFilter.setConnectionCloseAfterLogEnabled(<span class="keyword">false</span>);</span><br><span class="line">slf4jLogFilter.setStatementParameterClearLogEnable(<span class="keyword">false</span>);</span><br><span class="line">slf4jLogFilter.setStatementPrepareAfterLogEnabled(<span class="keyword">false</span>);</span><br><span class="line">slf4jLogFilter.setStatementPrepareCallAfterLogEnabled(<span class="keyword">false</span>);</span><br><span class="line">slf4jLogFilter.setStatementCreateAfterLogEnabled(<span class="keyword">false</span>);</span><br><span class="line">slf4jLogFilter.setStatementCloseAfterLogEnabled(<span class="keyword">false</span>);</span><br><span class="line"><span class="comment">//设置输出执行后的日志 带执行耗时等信息</span></span><br><span class="line">slf4jLogFilter.setStatementExecuteAfterLogEnabled(<span class="keyword">false</span>);</span><br><span class="line"><span class="comment">//设置批量操作执行后的日志 带执行耗时等信息</span></span><br><span class="line">slf4jLogFilter.setStatementExecuteBatchAfterLogEnabled(<span class="keyword">false</span>);</span><br><span class="line"><span class="comment">//设置查询操作执行后的日志 带执行耗时等信息</span></span><br><span class="line">slf4jLogFilter.setStatementExecuteQueryAfterLogEnabled(<span class="keyword">false</span>);</span><br><span class="line"><span class="comment">//设置更新 插入 删除 操作执行后的日志 带执行耗时等信息</span></span><br><span class="line">slf4jLogFilter.setStatementExecuteUpdateAfterLogEnabled(<span class="keyword">false</span>);</span><br><span class="line"><span class="comment">//输出完整的SQL 将值替换掉问号，这个仅在开发模式下有效</span></span><br><span class="line">slf4jLogFilter.setStatementExecutableSqlLogEnable(DEV_MODE);</span><br></pre></td></tr></table></figure>



- 数据库连接池（典型使用）

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> DruidPlugin druidplugin;</span><br><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line">    druidplugin= MainConfig.createSQLserverDruidPlugin();</span><br><span class="line">    druidplugin.start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  Connection <span class="title">getConnection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Connection connection =druidplugin.getDataSource().getConnection();</span><br><span class="line">            <span class="keyword">return</span> connection;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



- 读取配置文件的类
- 等



## 反射机制：

### 反射概念：

reflection (反射)是被视为动态语言的关键，反射机制允许程序在执行期，借助于refelction 取得任何类的内部信息，并能够直接操作任意对象的内部属性及方法

加载完类之后，在堆内存的方法区就产生了一个class类型的对象（一个类中只有一个class的对象），这个对象就包含了完整的类的结构。

![image-20210823100910743](https://gitee.com/jwz--jwz/cloud-img/raw/master/image/202201222323327.png)



### Java反射机制提供的功能

在运行时判断任意一个对象所属的类

在运行时构造任意一个类的对象

在运行时判断任意一个类所具有的成员变量和方法

在运行时获取泛型信息

在运行时判断任意一个对象所具有的成员变量和方法

在运行是处理注解

生成动态代理



### 反射主要的API：

java.lang.Class:代表一个类

java.lang.reflect.Method:代表类的方法

java.lang.reflect.Field:代表类的成员变量

java.lang.reflect.Constructor:代表类的构造器

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Class cla = User.class;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//              通过反射获取对象的构造方法</span></span><br><span class="line">            Constructor constructor = cla.getConstructor(String.class);</span><br><span class="line">            User user = (User) constructor.newInstance(<span class="string">&quot;jjjjj&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;user = &quot;</span> + user);</span><br><span class="line"><span class="comment">//           2、通过反射，调用对象指定的属性</span></span><br><span class="line">            Field userName = cla.getDeclaredField(<span class="string">&quot;userName&quot;</span>);</span><br><span class="line">            userName.set(user, <span class="string">&quot;22222&quot;</span>);</span><br><span class="line">            System.out.println(user.toString());</span><br><span class="line"><span class="comment">//            调用指定的方法</span></span><br><span class="line">            Method show = cla.getDeclaredMethod(<span class="string">&quot;show&quot;</span>);</span><br><span class="line">            show.invoke(user);</span><br><span class="line"><span class="comment">//          通过反射，可以调用Person类的私有的结构，比如私有的构造器、方法、属性</span></span><br><span class="line">            Constructor declaredConstructor = cla.getDeclaredConstructor(String.class,String.class);</span><br><span class="line">            declaredConstructor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            User user1 = (User) declaredConstructor.newInstance(<span class="string">&quot;jjj&quot;</span>,<span class="string">&quot;uuuuu&quot;</span>);</span><br><span class="line">            System.out.println(user1);</span><br><span class="line"><span class="comment">//          通过反射，直接获取私有的属性</span></span><br><span class="line">            Field name = cla.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">            name.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            name.set(user,<span class="string">&quot;66666&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;user = &quot;</span> + user);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



###   哪些类型可以有class对象?

- 外部类，成员(成员内部类，静态内部类)，

-  局部内部类，匿名内部类

-  interface:接口

-  []:数组

-   enum:枚举

-  annotation:注解@interface(6) 

- primitive type:基本数据类型( 7) void

![image-20210824202449619](C:\Users\jinweizhuo\AppData\Roaming\Typora\typora-user-images\image-20210824202449619.png

![image-20210824202620811](https://gitee.com/jwz--jwz/cloud-img/raw/master/image/202201222323271.png)

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 关于class.lang.class类的理解</span><br><span class="line"> * 1、类的加载文件</span><br><span class="line"> * 程序在经过javac.exe命令以后，会生成一个或者多个字节码文件（。class）文件，</span><br><span class="line"> * 接着使用java.exe命令对某个字节码文件进行解释运行。相当于将某个字节码文件加载到内存种</span><br><span class="line"> * 这个就是类的加载，加载到内存中的类，我们就称为  运行时类 ，这时候运行时类，就是一个class的实例（相当于类本身也是个对象）</span><br><span class="line"> *</span><br><span class="line"> * 2、class的实例就是一个运行时的对应的运行时类</span><br><span class="line"> * 3、加载到了内存中的运行时类，会缓存一定的的时间，在此时间类,我们可以通过不同的方式来获取运行时类</span><br><span class="line"> */</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//    获取class的实例的方式</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//          方式一：调用运行时类的属性：.class</span></span><br><span class="line">            Class class1= User.class;</span><br><span class="line">            System.out.println(<span class="string">&quot;class1 = &quot;</span> + class1);</span><br><span class="line"><span class="comment">//           方式二： 通过运行时类的对象，调用getclass()</span></span><br><span class="line">            User p1 = <span class="keyword">new</span> User();</span><br><span class="line">            Class class2= p1.getClass();</span><br><span class="line">            System.out.println(class2);</span><br><span class="line"><span class="comment">//            方式三：通过调用class的静态方法</span></span><br><span class="line">            Class class3 =Class.forName(<span class="string">&quot;wz.Reflection.User&quot;</span>);</span><br><span class="line">            System.out.println(class3);</span><br><span class="line"><span class="comment">//            加载到内存中的运行时类，会缓存一段时间，我们可以通过不同的的方式来获取运行时类</span></span><br><span class="line">            System.out.println(class1 == class2);</span><br><span class="line">            System.out.println(class1 == class3);</span><br><span class="line"><span class="comment">//             使用类加载机制： classLoader</span></span><br><span class="line"><span class="comment">//             先加载类，然后在使用类</span></span><br><span class="line">            ClassLoader classLoader = ReflectionTest.class.getClassLoader();</span><br><span class="line">            Class class4  = classLoader.loadClass(<span class="string">&quot;wz.Reflection.User&quot;</span>);</span><br><span class="line"><span class="comment">//            使用类加载器：ClassLoader获取对象</span></span><br><span class="line">            System.out.println(<span class="string">&quot;class4 = &quot;</span> + class4);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

### 类的加载与ClassLoader的理解：

####       类的加载过程

当程序主动使用某个类时，如果该类还没有被加载到内存中，则系统会通过一下三个步骤对该类进行初始化

![image-20210824203438316](C:\Users\jinweizhuo\AppData\Roaming\Typora\typora-user-images\image-20210824203438316.png)

![image-20210824203819378](https://gitee.com/jwz--jwz/cloud-img/raw/master/image/202201222323077.png)

####  类加载器的作用：

   ![image-20210824204248064](https://gitee.com/jwz--jwz/cloud-img/raw/master/image/202201222323771.png)

##### 类加载器的作用：

   将class文件字节码内容加载到内存中，并将这些静态数据转换成方法区的运行时数据结构，然后在堆中生成一个代表这个类的Java.lang。class对象，作为方法区中类数据的访问入口



###### 类缓存:

##### 标准的JavaSE类加载器可以按要求查找类，但一旦某个类被加载到类加载器中，它将维持加载（缓存）一段时间。不过JⅣM垃圾回收机制可以回收这些Class对象。

#####    ![image-20210824204910174](https://gitee.com/jwz--jwz/cloud-img/raw/master/image/202201222323423.png)



### 创建运行时类的对象:

通过newInstance()创建运行时类的对象

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;User&gt; personClass = User.class;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * newInstance() 调用此方法,创建对应的运行时对象,内部调用了运行时类的空参构造</span></span><br><span class="line"><span class="comment">    *要想此方法正常的创建运行时类的对象</span></span><br><span class="line"><span class="comment">    * 1 运行时类必须要提供空参的构造器</span></span><br><span class="line"><span class="comment">    * 空参的构造器的访问权限,通常设置为public</span></span><br><span class="line"><span class="comment">    * 在Javabean 中要求提供一个public的空参构造器,原因</span></span><br><span class="line"><span class="comment">    * 1 便于通过反射,创建运行时类的对象</span></span><br><span class="line"><span class="comment">    * 便于子类继承此运行时类时,默认调用super()时,保证父类有此构造器</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   User obj =personClass.newInstance();</span><br><span class="line">   System.out.println(<span class="string">&quot;obj = &quot;</span> + obj);</span><br></pre></td></tr></table></figure>



### java反射机制概述:

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> wz.Reflection.TestField;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> wz.Reflection.Person;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Annotation;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.*;</span><br><span class="line"><span class="keyword">import</span> java.time.Period;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestField</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Class cl = Person.class;</span><br><span class="line"><span class="comment">//      获取属性结构</span></span><br><span class="line">        <span class="comment">//拿取public 修饰的属性值</span></span><br><span class="line"><span class="comment">//     getFields(): 获取当前运行时类及其父类中的属性,该属性必须为public 修饰权限的属性值</span></span><br><span class="line">        Field[] fields = cl.getFields();</span><br><span class="line">        <span class="keyword">for</span> (Field f : fields</span><br><span class="line">        ) &#123;</span><br><span class="line">            System.out.println(f);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;------------&quot;</span>);</span><br><span class="line"><span class="comment">//        getDeclaredFields():获取当前运行时类中声明的所有属性,(不能包含父类中的属,当前类中使用public 修饰的值)</span></span><br><span class="line">        Field[] declareFields = cl.getDeclaredFields();</span><br><span class="line">        <span class="keyword">for</span> (Field f : declareFields</span><br><span class="line">        ) &#123;</span><br><span class="line">            System.out.println(f);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//    权限修饰符 数据类型 变量名</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Class clazz = Person.class;</span><br><span class="line">        Field[] declareFields = clazz.getDeclaredFields();</span><br><span class="line">        <span class="keyword">for</span> (Field f : declareFields</span><br><span class="line">        ) &#123;</span><br><span class="line"><span class="comment">//            1.权限修饰符,获取权限修饰符</span></span><br><span class="line">            <span class="keyword">int</span> modifiers = f.getModifiers();</span><br><span class="line"></span><br><span class="line">            System.out.print(Modifier.toString(modifiers) + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line"><span class="comment">//            2.获取数据类型值</span></span><br><span class="line">            Class type = f.getType();</span><br><span class="line">            System.out.print(type + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line"><span class="comment">//            3.获取数据变量名</span></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * private	class java.lang.String	name</span></span><br><span class="line"><span class="comment">             * public	int	age</span></span><br><span class="line"><span class="comment">             * public	int	id</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            String name = f.getName();</span><br><span class="line">            System.out.print(name);</span><br><span class="line">            System.out.println();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取运行时类的构造器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Class clazz = Person.class;</span><br><span class="line"><span class="comment">//       getConstructors()获取当前运行时类中声明为public 的构造器</span></span><br><span class="line">        Constructor[] constructors = clazz.getConstructors();</span><br><span class="line">        <span class="keyword">for</span> (Constructor c :</span><br><span class="line">                constructors) &#123;</span><br><span class="line">            System.out.println(c);</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * public wz.Reflection.Person()</span></span><br><span class="line"><span class="comment">             * public wz.Reflection.Person(java.lang.String)</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//  获取当前运行是类的所有构造器</span></span><br><span class="line">        Constructor[] constructor = clazz.getDeclaredConstructors();</span><br><span class="line">        <span class="keyword">for</span> (Constructor c :</span><br><span class="line">                constructor) &#123;</span><br><span class="line">            System.out.println(c);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取运行时类的父类及父类的泛型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestT</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//        supec = class java.lang.Class</span></span><br><span class="line">        Class c = Person.class;</span><br><span class="line">        Class supec = c.getClass();</span><br><span class="line">        System.out.println(<span class="string">&quot;supec = &quot;</span> + supec);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取运行时类带泛型的父类的泛型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSuperClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//        genericSuperclass = wz.Reflection.Creature&lt;java.lang.String&gt;</span></span><br><span class="line">        Class&lt;Person&gt; personClass = Person.class;</span><br><span class="line">        Type genericSuperclass = personClass.getGenericSuperclass();</span><br><span class="line">        System.out.println(<span class="string">&quot;genericSuperclass = &quot;</span> + genericSuperclass);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获运行时类的带泛型的父类的泛型</span></span><br><span class="line"><span class="comment">     * actualTypeArgument[0] = class java.lang.String</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestSuperClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Class clazz = Person.class;</span><br><span class="line">        Type genericSupperClass = clazz.getGenericSuperclass();</span><br><span class="line">        ParameterizedType parameterizedType = (ParameterizedType) genericSupperClass;</span><br><span class="line"><span class="comment">//        获取泛型的数据</span></span><br><span class="line">        Type[] actualTypeArgument = parameterizedType.getActualTypeArguments();</span><br><span class="line">        System.out.println(<span class="string">&quot;actualTypeArgument[0] = &quot;</span> + (Class) actualTypeArgument[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取运行时类的接口</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestInterface</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        interface java.lang.Comparable</span></span><br><span class="line"><span class="comment">        interface wz.Reflection.MyInterface</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Class clazz = Person.class;</span><br><span class="line">        Class[] interfaces = clazz.getInterfaces();</span><br><span class="line">        <span class="keyword">for</span> (Class c :</span><br><span class="line">                interfaces) &#123;</span><br><span class="line">            System.out.println(c);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取运行时类的父类的接口，先得到反射的类的对象。在使用对象进行进行后一步的操作</span></span><br><span class="line">        Class[] interfaces1 = clazz.getSuperclass().getInterfaces();</span><br><span class="line">        <span class="keyword">for</span> (Class c :</span><br><span class="line">                interfaces) &#123;</span><br><span class="line">            System.out.println(c);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取运行时类所在的包</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Testpackage</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//        pack = package wz.Reflection</span></span><br><span class="line">        Class cla = Person.class;</span><br><span class="line">        Package pack = cla.getPackage();</span><br><span class="line">        System.out.println(<span class="string">&quot;pack = &quot;</span> + pack);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取运行时类的声明的注解</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestAnnotation</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        Class clazz = Person.class;</span><br><span class="line">        Annotation[] annotations = clazz.getAnnotations();</span><br><span class="line">        <span class="keyword">for</span> (Annotation a:</span><br><span class="line">             annotations) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;a = &quot;</span> + a);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

##### 反射获取对象实例：

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> wz.Reflection.TestField;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> wz.Reflection.Person;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 调用运行时类的中的指定的接口，属性、方法、 构造器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestReflection</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestField</span><span class="params">()</span> <span class="keyword">throws</span> NoSuchFieldException, InstantiationException, IllegalAccessException </span>&#123;</span><br><span class="line">        Class clazz = Person.class;</span><br><span class="line"><span class="comment">//        创建运行时类的对象</span></span><br><span class="line">          Person p = (Person) clazz.newInstance();</span><br><span class="line"></span><br><span class="line"><span class="comment">//        获取指定的反射类型 ,指定泛型的属性，这里就是指获取反射对象的属性值</span></span><br><span class="line">        Field id = clazz.getField(<span class="string">&quot;id&quot;</span>);</span><br><span class="line"><span class="comment">//       属性--》动态获取的参数，指明哪个对象的属性值 + 参数2：参数值设置为多少</span></span><br><span class="line">        id.set(p,<span class="number">100</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;id = &quot;</span> + id);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 获取当前属性的值</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">int</span> pid =(<span class="keyword">int</span>) id.get(p);</span><br><span class="line">        System.out.println(<span class="string">&quot;pid = &quot;</span> + pid);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> InstantiationException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalAccessException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NoSuchFieldException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">testField</span><span class="params">()</span> <span class="keyword">throws</span> InstantiationException, IllegalAccessException, NoSuchFieldException </span>&#123;</span><br><span class="line">        Class clazz = Person.class;</span><br><span class="line"><span class="comment">//        创建运行时类的对象</span></span><br><span class="line">        Person p = (Person) clazz.newInstance();</span><br><span class="line"></span><br><span class="line"><span class="comment">//      获取运行时类的对象</span></span><br><span class="line">        Field name = clazz.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line"><span class="comment">//        保证当前属性值是可以访问的</span></span><br><span class="line">        name.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"><span class="comment">//        获取设置指定对象的此属性值</span></span><br><span class="line">        name.set(p,<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;name = &quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">testMethod</span><span class="params">()</span> <span class="keyword">throws</span> InstantiationException, IllegalAccessException, NoSuchMethodException, InvocationTargetException </span>&#123;</span><br><span class="line">        Class clazz = Person.class;</span><br><span class="line"><span class="comment">//     1   创建运行时类的对象</span></span><br><span class="line">       Person p =(Person) clazz.newInstance();</span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 获取指定的某个方法</span></span><br><span class="line"><span class="comment">        * 2获取某个指定的某个方法 ,指明获取的名称 参数2： 指明获取的方法的形参列表</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       Method show = clazz.getDeclaredMethod(<span class="string">&quot;show&quot;</span>, String.class);</span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        *3 invoke(): 参数1 方法的调用者 参数2 给方法赋值的形参</span></span><br><span class="line"><span class="comment">        * invoke() 的返回值即为对应类中调用的方法的返回值</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       Object chn = show.invoke(p, <span class="string">&quot;chn&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 调用指定的构造器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">TestConstructor</span><span class="params">()</span> <span class="keyword">throws</span> NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException </span>&#123;</span><br><span class="line">       Class cla  = Person.class;</span><br><span class="line">       Constructor declaredConstructor = cla.getDeclaredConstructor(String.class);</span><br><span class="line"><span class="comment">//        2、b保证构造器是可以进行访问的</span></span><br><span class="line"><span class="comment">//       3、调用此构造器创建运行时类的对象</span></span><br><span class="line">       declaredConstructor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"><span class="comment">//       3、调用此构造器创建运行时类的对象</span></span><br><span class="line">       Person tom = (Person)declaredConstructor.newInstance(<span class="string">&quot;tom&quot;</span>);</span><br><span class="line"><span class="comment">//       输出的是地址值</span></span><br><span class="line">       System.out.println(<span class="string">&quot;tom = &quot;</span> + tom);</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>







### 1.写出获取Class实例的三种常见方式

  Class clazz =String.Class

Class clazz =person.getClass();//sout(person)

Class.forname(String classPath)//体现反射的动态性





### 2.谈谈你对Class类的理解

Class 实例对应着加载到内存中的一个运行时类



## 反射的应用：动态代理

### 代理设计模式的原理：

   使用代理将对象包装起来然后用该对象取代原始的对象。任何对原始的对象都要通过代理。代理对象决定是否以何时将方法调用转到原始对象上

在编译期间就将代理类和目标确定下来了，不利于程序的扩展。同时，每个代理只能为一个接口服务。这样就会导致开发过程中产生很多的代理。最好可以通过一个代理类完成全部的代理的功能

 **主要区别就是在编译期间确定对象 还是在运行期间进行动态的创建**

动态代理是指客户通过代理类来调用其他对象的方法，并且在运行时根据需要创建目标类的代理对象

使用场合：

​              调试

​                远程方法的调用

#### 动态代理相比于静态代理的优点:

  抽象角色（接口中）声明的对象的方法都被转移到调用处理器一个集中的方法中去处理

这样可以更加灵活的处理更多的方法



#### 动态代理样例：

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> wz.Reflection.Proxy;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">getBelief</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">(String food)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//被代理</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SuperMan</span> <span class="keyword">implements</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getBelief</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;I believe I can fly !&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">(String food)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;小&quot;</span> + food);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 要想实现动态代理，需要解决的问题？</span></span><br><span class="line"><span class="comment"> * 问题一： 如何解决根据加载到内存中的被代理类，动态的创建一个代理类及其对象</span></span><br><span class="line"><span class="comment"> * 问题二： 通过代理类的对象调用方法时，如何动态的去调用被代理类中的同名方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyFactory</span> </span>&#123;</span><br><span class="line">    <span class="comment">//调用此方法 返回一个代理类的对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getProxyInstance</span><span class="params">(Object obj)</span> </span>&#123;<span class="comment">//obj:被代理类的对象</span></span><br><span class="line">        MyInvocationHandler handler = <span class="keyword">new</span> MyInvocationHandler();</span><br><span class="line"><span class="comment">//        先进行对象的实例化</span></span><br><span class="line">        handler.bind(obj);</span><br><span class="line"><span class="comment">// 获取类加载器，创建代理类的对象，需要同代理类使用同样的接口，</span></span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(obj.getClass().getClassLoader(), obj.getClass().getInterfaces(), handler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyInvocationHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="comment">//    当我们通过代理类的对象，调用方法 a 时，就是自动的调用如下的方法：invoke()</span></span><br><span class="line">    <span class="comment">//    将被代理类要执行的方法a的功能就声明在invoke()中</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object object;<span class="comment">//赋值时,也需要使用被代理类的对象进赋值</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bind</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.object = o;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//    proxy调用者的对象，调用的方法，</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    method  代理类对象的调用的方法，此方法也就作为被代理类对象的方法</span></span><br><span class="line"><span class="comment">//    obj : 被代理类的对象</span></span><br><span class="line">        Object invoke = method.invoke(object, args);</span><br><span class="line"><span class="comment">//        上述方法的返回值就作为当前类中的invoke()返回值</span></span><br><span class="line">        <span class="keyword">return</span> invoke;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span>  <span class="class"><span class="keyword">class</span>  <span class="title">ProxyTest</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">            SuperMan superMan = <span class="keyword">new</span> SuperMan();</span><br><span class="line"><span class="comment">//            proxyInstance； 代理类的对象</span></span><br><span class="line">            Human proxyInstance = (Human) ProxyFactory.getProxyInstance(superMan);</span><br><span class="line">            proxyInstance.getBelief();</span><br><span class="line">            proxyInstance.eat(<span class="string">&quot;麻辣烫&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

#### 动态代理与AOP：、

![image-20210901105249112](https://gitee.com/jwz--jwz/cloud-img/raw/master/image/202201222324606.png)

​        ![image-20210901105209703](https://gitee.com/jwz--jwz/cloud-img/raw/master/image/202201222324838.png)

以硬编码的方式就是在程序中将代码在编译期间就已经写死了,

![image-20210901105603807](https://gitee.com/jwz--jwz/cloud-img/raw/master/image/202201222324621.png)



## 常用类： 

### 时间日期APL:

jdk-8之前的日期APL:

![image-20210901120406801](https://gitee.com/jwz--jwz/cloud-img/raw/master/image/202201222324841.png)

#### java.lang.System

​       ![image-20210901120353495](https://gitee.com/jwz--jwz/cloud-img/raw/master/image/202201222324592.png)



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestCurrent</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//        代表1970年1月1日到当前时间的时间差，常用于时间戳，精确到了毫秒</span></span><br><span class="line">        <span class="keyword">long</span> time = System.currentTimeMillis();</span><br><span class="line"><span class="comment">//        时间戳</span></span><br><span class="line">        System.out.println(time);</span><br><span class="line"><span class="comment">//        1630469278535</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

####    2、java.util.Date

![image-20210901123245640](https://gitee.com/jwz--jwz/cloud-img/raw/master/image/202201222324208.png)

#### 3、java.text.SimpleDateformat

![image-20210903182720331](https://gitee.com/jwz--jwz/cloud-img/raw/master/image/202201222324773.png)





# java 多线程：

## 线程池的使用：

> 当执行大量的异步操作的时候，线程池能够提供较好的性能。在不使用线程池的情况之下，线程的创建是需要进行销毁的，需要很大的开销。线程池里面的线程是可以进行复用的，不需要每次异步任务去重新的创建

线程池提供一种可以管理的手段，比如限制线程的个数、动态新增线程等

### 线程的分类有：

- newCachedThreadPool创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。
- newFixedThreadPool 创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。
- newScheduledThreadPool 创建一个定长线程池，支持定时及周期性任务执行。
  newSingleThreadExecutor 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。



1在我们每次使用new Thread去创建线程的时候

()</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">JIn</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2022/01/20/JAVA%E5%AD%A6%E4%B9%A0%EF%BC%9A/">http://example.com/2022/01/20/JAVA%E5%AD%A6%E4%B9%A0%EF%BC%9A/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">little_kim</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a></div><div class="post_share"><div class="social-share" data-image="https://gitee.com/jwz--jwz/cloud-img/raw/master/piggo/202201041355284.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/03/10/packageError/"><img class="prev-cover" src="https://gitee.com/jwz--jwz/cloud-img/raw/master/piggo/202201041355284.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">maven打包错误</div></div></a></div><div class="next-post pull-right"><a href="/2022/01/16/java8/"><img class="next-cover" src="https://gitee.com/jwz--jwz/cloud-img/raw/master/image/202201042027693.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">java8</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2022/01/16/java8/" title="java8"><img class="cover" src="https://gitee.com/jwz--jwz/cloud-img/raw/master/image/202201042027693.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-01-16</div><div class="title">java8</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="lv-container" data-id="city" data-uid="MTAyMC81NTEyNi8zMTU5NA=="></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/./img/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">JIn</div><div class="author-info__description">欢迎访问</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">12</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">12</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/JInsir200" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:xxxxxx@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">小金的博客上线啦</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#JAVA%E5%AD%A6%E4%B9%A0"><span class="toc-number">1.</span> <span class="toc-text">JAVA学习</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Java%E5%B0%8F%E7%9F%A5%E8%AF%86%E4%B9%8B%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96%EF%BC%9A"><span class="toc-number">1.1.</span> <span class="toc-text">Java小知识之代码优化：</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E3%80%81%E5%B0%BD%E9%87%8F%E9%87%8D%E7%94%A8%E5%AF%B9%E8%B1%A1%EF%BC%9A"><span class="toc-number">1.1.0.1.</span> <span class="toc-text">1、尽量重用对象：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%E3%80%81%E5%BE%AA%E7%8E%AF%E5%86%85%E4%B8%8D%E8%A6%81%E4%B8%8D%E6%96%AD%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E5%BC%95%E7%94%A8"><span class="toc-number">1.1.0.2.</span> <span class="toc-text">2、循环内不要不断创建对象引用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java%E5%88%A4%E6%96%AD%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%98%AF%E5%90%A6%E4%B8%BA%E7%A9%BA"><span class="toc-number">1.2.</span> <span class="toc-text">Java判断字符串是否为空</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80-%E7%A9%BA%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%8Enull%E5%8C%BA%E5%88%AB"><span class="toc-number">1.2.1.</span> <span class="toc-text">一.空字符串与null区别</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E3%80%81%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">1、类型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%E3%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D"><span class="toc-number">1.2.1.2.</span> <span class="toc-text">2、内存分配</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3%E3%80%81%E7%A4%BA%E4%BE%8B%E7%A8%8B%E5%BA%8F%EF%BC%9A"><span class="toc-number">1.2.1.3.</span> <span class="toc-text">3、示例程序：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-Java%E5%88%A4%E6%96%AD%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E6%96%B9%E6%B3%95"><span class="toc-number">1.2.1.4.</span> <span class="toc-text">4.Java判断字符串常方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%94%E3%80%81StringUtils%E7%9A%84isBlank%E4%B8%8EisEmply"><span class="toc-number">1.2.1.5.</span> <span class="toc-text">五、StringUtils的isBlank与isEmply</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#1-public-static-boolean-isEmpty-String-str"><span class="toc-number">1.2.1.5.1.</span> <span class="toc-text">1.public static boolean isEmpty(String str)</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2-public-static-boolean-isNotEmpty-String-str"><span class="toc-number">1.2.1.5.2.</span> <span class="toc-text">2.public static boolean isNotEmpty(String str)</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#3-pblic-static-boolean-isBlank-String-str"><span class="toc-number">1.2.1.5.3.</span> <span class="toc-text">3.pblic static boolean isBlank(String str)</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#4-public-static-boolean-isNotBlank-String-str"><span class="toc-number">1.2.1.5.4.</span> <span class="toc-text">4.public static boolean isNotBlank(String str)</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#java-list%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E5%88%A4%E6%96%AD%E7%A9%BA"><span class="toc-number">1.3.</span> <span class="toc-text">java list如何进行判断空</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E5%B8%B8%E7%94%A8%E8%A1%A8%E8%BE%BE%E6%96%B9%E5%BC%8F"><span class="toc-number">1.3.1.</span> <span class="toc-text">1、常用表达方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81%E9%81%87%E5%88%B0%E9%97%AE%E9%A2%98"><span class="toc-number">1.3.2.</span> <span class="toc-text">2、遇到问题</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E3%80%81-list-isEmpty-%E5%92%8C-list-size-0"><span class="toc-number">1.3.2.1.</span> <span class="toc-text">1、 list.isEmpty() 和 list.size()&#x3D;&#x3D;0</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%E3%80%81-list%EF%BC%81-null-%E8%B7%9F-%EF%BC%81-list-isEmpty"><span class="toc-number">1.3.2.2.</span> <span class="toc-text">2、 list！&#x3D;null 跟 ！ list.isEmpty()</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E3%80%81%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E3%80%81%E7%B1%BB%E5%8F%98%E9%87%8F"><span class="toc-number">1.4.</span> <span class="toc-text">Java局部变量、成员变量、类变量</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F"><span class="toc-number">1.4.1.</span> <span class="toc-text">1、实例变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E5%8F%98%E9%87%8F%EF%BC%9A"><span class="toc-number">1.4.2.</span> <span class="toc-text">类变量：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%EF%BC%9A"><span class="toc-number">1.4.3.</span> <span class="toc-text">局部变量：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E4%BB%96%E4%BB%AC%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.4.4.</span> <span class="toc-text">四、他们的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%92%8C%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.4.4.1.</span> <span class="toc-text">成员变量和局部变量的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%EF%BC%9A"><span class="toc-number">1.4.4.1.1.</span> <span class="toc-text">成员变量：</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%EF%BC%9A-1"><span class="toc-number">1.4.4.1.2.</span> <span class="toc-text">局部变量：</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#b-%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%92%8C%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.4.4.2.</span> <span class="toc-text">b 成员变量和静态变量的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#1%E3%80%81%E4%B8%A4%E4%B8%AA%E5%8F%98%E9%87%8F%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E4%B8%8D%E5%90%8C"><span class="toc-number">1.4.4.2.1.</span> <span class="toc-text">1、两个变量的生命周期不同</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2%E3%80%81%E8%B0%83%E7%94%A8%E6%96%B9%E5%BC%8F%E4%B8%8D%E5%90%8C"><span class="toc-number">1.4.4.2.2.</span> <span class="toc-text">2、调用方式不同</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#3%E3%80%81%E5%88%AB%E5%90%8D%E4%B8%8D%E5%90%8C"><span class="toc-number">1.4.4.2.3.</span> <span class="toc-text">3、别名不同</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#4%E3%80%81%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E4%BD%8D%E7%BD%AE%E4%B8%8D%E5%90%8C"><span class="toc-number">1.4.4.2.4.</span> <span class="toc-text">4、数据存储位置不同</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#java%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-number">2.</span> <span class="toc-text">java序列化:</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E5%BA%8F%E5%88%97%E5%8C%96%E7%9A%84%E5%90%AB%E4%B9%89%E3%80%81%E6%84%8F%E4%B9%89%E5%8F%8A%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9A"><span class="toc-number">2.1.</span> <span class="toc-text">一、序列化的含义、意义及使用场景：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#javaString%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.</span> <span class="toc-text">javaString类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E4%BA%8EString-%E4%B8%8D%E5%8F%AF%E4%BB%A5%E5%8F%98%EF%BC%9A"><span class="toc-number">3.0.1.</span> <span class="toc-text">关于String 不可以变：</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%8D%E5%8F%AF%E5%8F%98%EF%BC%9F"><span class="toc-number">3.0.1.0.1.</span> <span class="toc-text">什么是不可变？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E4%BA%8Ehashcode"><span class="toc-number">3.0.2.</span> <span class="toc-text">关于hashcode ():</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFhash"><span class="toc-number">3.0.2.1.</span> <span class="toc-text">什么是hash :</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#HashCode%EF%BC%9A"><span class="toc-number">3.0.2.2.</span> <span class="toc-text">HashCode：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#HashCode%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8"><span class="toc-number">3.0.2.3.</span> <span class="toc-text">HashCode有什么用</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%B8%BE%E4%B8%AA%E5%AE%9E%E9%99%85%E7%9A%84%E4%BE%8B%E5%AD%90Set%EF%BC%9A"><span class="toc-number">3.0.2.3.1.</span> <span class="toc-text">举个实际的例子Set：</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E9%87%8D%E5%86%99hashcode"><span class="toc-number">3.0.2.4.</span> <span class="toc-text">为什么要重写hashcode</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#java%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">4.</span> <span class="toc-text">java关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81instanceof"><span class="toc-number">4.1.</span> <span class="toc-text">1、instanceof</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81instanceof%E7%94%A8%E6%B3%95%E8%AF%A6%E8%A7%A3%EF%BC%9A"><span class="toc-number">4.1.1.</span> <span class="toc-text">1、instanceof用法详解：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81instanceof%E7%94%A8%E6%B3%95%EF%BC%9A"><span class="toc-number">4.1.2.</span> <span class="toc-text">2、instanceof用法：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#obj-%E4%B8%BA-class-%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%B1%BB"><span class="toc-number">4.2.</span> <span class="toc-text">obj 为 class 接口的实现类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#obj-%E4%B8%BA-class-%E7%B1%BB%E7%9A%84%E7%9B%B4%E6%8E%A5%E6%88%96%E9%97%B4%E6%8E%A5%E5%AD%90%E7%B1%BB"><span class="toc-number">4.3.</span> <span class="toc-text">obj 为 class 类的直接或间接子类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81%E5%8E%9F%E7%90%86%E4%BD%BF%E7%94%A8%E4%BC%AA%E4%BB%A3%E7%A0%81%E8%A1%A8%E7%A4%BA%E4%B8%BA%EF%BC%9A"><span class="toc-number">4.3.1.</span> <span class="toc-text">3、原理使用伪代码表示为：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E3%80%81%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9A"><span class="toc-number">4.3.2.</span> <span class="toc-text">4、应用场景：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#final%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%9A"><span class="toc-number">4.4.</span> <span class="toc-text">final关键字：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#static-%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%9A"><span class="toc-number">4.5.</span> <span class="toc-text">static 关键字：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%AE%E7%9A%84%EF%BC%9A"><span class="toc-number">4.5.1.</span> <span class="toc-text">目的：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E7%82%B9%EF%BC%9A"><span class="toc-number">4.5.2.</span> <span class="toc-text">特点：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">4.5.3.</span> <span class="toc-text">使用场景:</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#static%E5%8F%98%E9%87%8F%EF%BC%9A"><span class="toc-number">4.5.3.1.</span> <span class="toc-text">static变量：</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BD%BF%E7%94%A8static%E5%8F%98%E9%87%8F"><span class="toc-number">4.5.3.1.1.</span> <span class="toc-text">什么时候使用static变量</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#static%E6%96%B9%E6%B3%95%EF%BC%9A"><span class="toc-number">4.5.3.2.</span> <span class="toc-text">static方法：</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BD%BF%E7%94%A8static%E6%96%B9%E6%B3%95%EF%BC%9A"><span class="toc-number">4.5.3.2.1.</span> <span class="toc-text">什么时候使用static方法：</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#static-%E4%BB%A3%E7%A0%81%E5%9D%97%EF%BC%9A"><span class="toc-number">4.5.3.3.</span> <span class="toc-text">static 代码块：</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JAVA%E9%9B%86%E5%90%88%EF%BC%9A"><span class="toc-number">5.</span> <span class="toc-text">JAVA集合：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-Collection-%E5%AD%90%E6%8E%A5%E5%8F%A3"><span class="toc-number">6.</span> <span class="toc-text">1.2. Collection 子接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#list"><span class="toc-number">6.1.</span> <span class="toc-text">list:</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-1-%E4%BB%80%E4%B9%88%E6%98%AFList"><span class="toc-number">6.1.1.</span> <span class="toc-text">1.2.1: 什么是List:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-2-List%E6%8E%A5%E5%8F%A3%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%B1%BB%EF%BC%9A"><span class="toc-number">6.1.2.</span> <span class="toc-text">1.2.2:  List接口中常用类：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-3-arraylist%E6%89%A9%E5%AE%B9"><span class="toc-number">6.1.3.</span> <span class="toc-text">1.2.3:arraylist扩容</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%9A"><span class="toc-number">6.1.3.1.</span> <span class="toc-text">源码分析：</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF%EF%BC%9A"><span class="toc-number">6.1.3.1.1.</span> <span class="toc-text">思路：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LinkedList-%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8-%EF%BC%9A"><span class="toc-number">6.1.4.</span> <span class="toc-text">LinkedList(双向链表)：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#vector"><span class="toc-number">6.1.5.</span> <span class="toc-text">vector():</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Set%E6%8E%A5%E5%8F%A3%EF%BC%9A"><span class="toc-number">6.2.</span> <span class="toc-text">Set接口：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFset"><span class="toc-number">6.2.1.</span> <span class="toc-text">什么是set</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E7%82%B9"><span class="toc-number">6.2.2.</span> <span class="toc-text">特点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#hashset%EF%BC%9A"><span class="toc-number">6.3.</span> <span class="toc-text">hashset：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#treeSet"><span class="toc-number">6.4.</span> <span class="toc-text">treeSet:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Map%E6%8E%A5%E5%8F%A3%EF%BC%9A"><span class="toc-number">6.5.</span> <span class="toc-text">Map接口：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#hashMap"><span class="toc-number">6.5.1.</span> <span class="toc-text">hashMap:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9HashMap%E4%B8%ADput-get%E6%96%B9%E6%B3%95%E7%9A%84%E8%AE%A4%E8%AF%86%EF%BC%9F"><span class="toc-number">6.5.2.</span> <span class="toc-text">对HashMap中put&#x2F;get方法的认识？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HashMa"><span class="toc-number">6.5.3.</span> <span class="toc-text">HashMa</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#jdk8"><span class="toc-number">6.6.</span> <span class="toc-text">jdk8:</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#put%E6%96%B9%E6%B3%95%EF%BC%9A"><span class="toc-number">6.6.1.</span> <span class="toc-text">put方法：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#resize"><span class="toc-number">6.6.2.</span> <span class="toc-text">resize:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LinkedHashMap%E7%9A%84%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%EF%BC%88%E5%BE%85%E5%AE%8C%E6%88%90%EF%BC%89%EF%BC%9A"><span class="toc-number">6.6.3.</span> <span class="toc-text">LinkedHashMap的底层原理（待完成）：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#map%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%EF%BC%9A"><span class="toc-number">6.7.</span> <span class="toc-text">map常用方法：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-3-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93"><span class="toc-number">6.8.</span> <span class="toc-text">1.1.3. 集合框架底层数据结构总结</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-3-1-List"><span class="toc-number">6.8.1.</span> <span class="toc-text">1.1.3.1. List</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-3-2-Set"><span class="toc-number">6.8.2.</span> <span class="toc-text">1.1.3.2. Set</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-3-3-Queue"><span class="toc-number">6.8.3.</span> <span class="toc-text">1.1.3.3 Queue</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-3-4-Map"><span class="toc-number">6.8.4.</span> <span class="toc-text">1.1.3.4. Map</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-2-%E8%AF%B4%E8%AF%B4-List-Set-Queue-Map-%E5%9B%9B%E8%80%85%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">6.9.</span> <span class="toc-text">1.1.2. 说说 List, Set, Queue, Map 四者的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-1-Arraylist-%E5%92%8C-Vector-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">6.10.</span> <span class="toc-text">1.2.1. Arraylist 和 Vector 的区别?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-2-Arraylist-%E4%B8%8E-LinkedList-%E5%8C%BA%E5%88%AB"><span class="toc-number">6.11.</span> <span class="toc-text">1.2.2. Arraylist 与 LinkedList 区别?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-2-%E8%B4%9F%E8%BD%BD%E5%9B%A0%E5%AD%90%E5%80%BC%E7%9A%84%E5%A4%A7%E5%B0%8F%EF%BC%8C%E5%AF%B9HashMap%E6%9C%89%E4%BB%80%E4%B9%88%E5%BD%B1%E5%93%8D%EF%BC%9F"><span class="toc-number">6.12.</span> <span class="toc-text">1.2.2. 负载因子值的大小，对HashMap有什么影响？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Collections%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%EF%BC%9A"><span class="toc-number">7.</span> <span class="toc-text">Collections常用方法：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Collections-%E5%B7%A5%E5%85%B7%E7%B1%BB%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">7.1.</span> <span class="toc-text">Collections 工具类常用方法:</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9F%A5%E6%89%BE-%E6%9B%BF%E6%8D%A2%E6%93%8D%E4%BD%9C"><span class="toc-number">7.1.1.</span> <span class="toc-text">查找,替换操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9F%A5%E6%89%BE%E6%9B%BF%E6%8D%A2%E6%93%8D%E4%BD%9C%EF%BC%9A"><span class="toc-number">7.1.2.</span> <span class="toc-text">查找替换操作：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E6%8E%A7%E5%88%B6"><span class="toc-number">7.2.</span> <span class="toc-text">同步控制:</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%92%8C%E6%B3%A8%E8%A7%A3%EF%BC%9A"><span class="toc-number">8.</span> <span class="toc-text">枚举类和注解：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE"><span class="toc-number">8.1.</span> <span class="toc-text">枚举</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E5%85%B3%E9%94%AE%E5%AD%97enum%E5%AE%9A%E4%B9%89%E6%9E%9A%E4%B8%BE%E7%B1%BB"><span class="toc-number">8.1.1.</span> <span class="toc-text">如何使用关键字enum定义枚举类;</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%9A"><span class="toc-number">8.1.1.1.</span> <span class="toc-text">使用关键字：</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#test"><span class="toc-number">8.1.1.1.1.</span> <span class="toc-text">test:</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E8%87%AA%E5%AE%9A%E4%B9%89%EF%BC%9A"><span class="toc-number">8.1.1.2.</span> <span class="toc-text">使用自定义：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E8%A7%A3%EF%BC%9A"><span class="toc-number">8.2.</span> <span class="toc-text">注解：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%83%E6%95%B0%E6%8D%AE"><span class="toc-number">8.3.</span> <span class="toc-text">元数据</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#retention"><span class="toc-number">8.3.0.1.</span> <span class="toc-text">@retention:</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%87%E5%AE%9A%E6%89%80%E4%BF%AE%E9%A5%B0%E7%9A%84annotation%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%EF%BC%9Asource-class-%E5%8F%AA%E6%9C%89%E5%A3%B0%E6%98%8E%E4%B8%BAruntime-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%9A%84%E6%B3%A8%E8%A7%A3%EF%BC%8C%E6%89%8D%E8%83%BD%E9%80%9A%E8%BF%87%E5%8F%8D%E5%B0%84"><span class="toc-number">8.3.1.</span> <span class="toc-text">指定所修饰的annotation的生命周期：source\class,只有声明为runtime 生命周期的注解，才能通过反射</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#target"><span class="toc-number">8.3.1.1.</span> <span class="toc-text">@target:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Documented"><span class="toc-number">8.3.1.2.</span> <span class="toc-text">@Documented:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#inherited"><span class="toc-number">8.3.1.3.</span> <span class="toc-text">@inherited</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E5%8F%8D%E5%B0%84%E8%8E%B7%E5%8F%96%E4%BF%A1%E6%81%AF%EF%BC%9A"><span class="toc-number">8.4.</span> <span class="toc-text">利用反射获取信息：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#jdk8%E4%B8%AD%E7%9A%84%E6%96%B0%E6%B3%A8%E8%A7%A3%EF%BC%9A"><span class="toc-number">8.5.</span> <span class="toc-text">jdk8中的新注解：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E9%87%8D%E5%A4%8D%E6%B3%A8%E8%A7%A3%EF%BC%9A"><span class="toc-number">8.5.1.</span> <span class="toc-text">可重复注解：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E6%B3%A8%E8%A7%A3%EF%BC%9A"><span class="toc-number">8.5.2.</span> <span class="toc-text">类型注解：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%EF%BC%9A"><span class="toc-number">9.</span> <span class="toc-text">泛型：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9C%89%E6%B3%9B%E5%9E%8B%EF%BC%88Generic%EF%BC%89%EF%BC%9A"><span class="toc-number">9.1.</span> <span class="toc-text">1.1为什么要有泛型（Generic）：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E5%B5%8C%E5%A5%97%EF%BC%9A"><span class="toc-number">9.2.</span> <span class="toc-text">泛型嵌套：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E9%85%8D%E7%AC%A6%E7%9A%84%E4%BD%BF%E7%94%A8%EF%BC%9A"><span class="toc-number">9.3.</span> <span class="toc-text">通配符的使用：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%9A%E9%85%8D%E7%AC%A6%E6%8C%87%E5%AE%9A%E4%B8%8A%E9%99%90%EF%BC%9A"><span class="toc-number">9.3.1.</span> <span class="toc-text">通配符指定上限：</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%B8%8A%E9%99%90extends"><span class="toc-number">9.3.1.0.1.</span> <span class="toc-text">上限extends:</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%9A%E9%85%8D%E7%AC%A6%E6%8C%87%E5%AE%9A%E4%B8%8B%E9%99%90%EF%BC%9A"><span class="toc-number">9.3.2.</span> <span class="toc-text">通配符指定下限：</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%B8%8B%E9%99%90super-s"><span class="toc-number">9.3.2.0.1.</span> <span class="toc-text">下限super:s</span></a></li></ol></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/03/10/EhCache%E7%8E%AF%E5%A2%83%E7%9B%AE%E5%BD%95%20/" title="【转】使用 EhCache 关于临时目录的一个注意事项"><img src="https://gitee.com/jwz--jwz/cloud-img/raw/master/piggo/202201041440795.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【转】使用 EhCache 关于临时目录的一个注意事项"/></a><div class="content"><a class="title" href="/2022/03/10/EhCache%E7%8E%AF%E5%A2%83%E7%9B%AE%E5%BD%95%20/" title="【转】使用 EhCache 关于临时目录的一个注意事项">【转】使用 EhCache 关于临时目录的一个注意事项</a><time datetime="2022-03-09T16:40:07.882Z" title="发表于 2022-03-10 00:40:07">2022-03-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/03/10/tomcat%20%20%E9%85%8D%E7%BD%AE/" title="tomcat配置"><img src="https://gitee.com/jwz--jwz/cloud-img/raw/master/image/202203080018136.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="tomcat配置"/></a><div class="content"><a class="title" href="/2022/03/10/tomcat%20%20%E9%85%8D%E7%BD%AE/" title="tomcat配置">tomcat配置</a><time datetime="2022-03-09T16:32:23.275Z" title="发表于 2022-03-10 00:32:23">2022-03-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/03/10/IOC/" title="什么是IOC"><img src="https://gitee.com/jwz--jwz/cloud-img/raw/master/image/202203080018136.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="什么是IOC"/></a><div class="content"><a class="title" href="/2022/03/10/IOC/" title="什么是IOC">什么是IOC</a><time datetime="2022-03-09T16:32:23.272Z" title="发表于 2022-03-10 00:32:23">2022-03-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/03/10/IDEA%E4%BD%BF%E7%94%A8maven%E5%91%BD%E4%BB%A4%E6%89%93%E5%8C%85/" title="IDEA使用maven命令打包"><img src="https://gitee.com/jwz--jwz/cloud-img/raw/master/piggo/202201041439346.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="IDEA使用maven命令打包"/></a><div class="content"><a class="title" href="/2022/03/10/IDEA%E4%BD%BF%E7%94%A8maven%E5%91%BD%E4%BB%A4%E6%89%93%E5%8C%85/" title="IDEA使用maven命令打包">IDEA使用maven命令打包</a><time datetime="2022-03-09T16:28:33.399Z" title="发表于 2022-03-10 00:28:33">2022-03-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/03/10/packageError/" title="maven打包错误"><img src="https://gitee.com/jwz--jwz/cloud-img/raw/master/piggo/202201041355284.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="maven打包错误"/></a><div class="content"><a class="title" href="/2022/03/10/packageError/" title="maven打包错误">maven打包错误</a><time datetime="2022-03-09T16:23:11.449Z" title="发表于 2022-03-10 00:23:11">2022-03-10</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By JIn</div><div class="footer_custom_text">你将不再是道具，而是人如其名</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><script>function loadLivere () {
  if (typeof LivereTower === 'object') {
    window.LivereTower.init()
  }
  else {
    (function(d, s) {
        var j, e = d.getElementsByTagName(s)[0];
        if (typeof LivereTower === 'function') { return; }
        j = d.createElement(s);
        j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
        j.async = true;
        e.parentNode.insertBefore(j, e);
    })(document, 'script');
  }
}

if ('Livere' === 'Livere' || !false) {
  if (false) btf.loadComment(document.getElementById('lv-container'), loadLivere)
  else loadLivere()
}
else {
  function loadOtherComment () {
    loadLivere()
  }
}</script></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="false"></script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-heart.min.js" async="async" mobile="true"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = [
  'title',
  '#config-diff',
  '#body-wrap',
  '#rightside-config-hide',
  '#rightside-config-show',
  '.js-pjax'
]

if (true) {
  pjaxSelectors.unshift('meta[property="og:image"]', 'meta[property="og:title"]', 'meta[property="og:url"]')
}

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.removeEventListener('scroll', window.tocScrollFn)
  window.removeEventListener('scroll', scrollCollect)

  typeof preloader === 'object' && preloader.initLoading()
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // Analytics
  if (false) {
    MtaH5.pgv()
  }

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()

  typeof preloader === 'object' && preloader.endLoading()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="/live2d_models/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2d_models/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"display":{"position":"right"},"mobile":{"show":false},"model":{"scale":1.2,"jsonPath":"/live2d_models/assets/violet.model.json"},"log":false});</script></body></html>