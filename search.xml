<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title></title>
      <link href="/2022/03/10/Java%E7%BB%9F%E8%AE%A1%E4%BB%A3%E7%A0%81%E7%9A%84%E6%89%A7%E8%A1%8C%E6%97%B6%E9%97%B4%E7%9A%846%E7%A7%8D%E6%96%B9%E6%B3%95/"/>
      <url>/2022/03/10/Java%E7%BB%9F%E8%AE%A1%E4%BB%A3%E7%A0%81%E7%9A%84%E6%89%A7%E8%A1%8C%E6%97%B6%E9%97%B4%E7%9A%846%E7%A7%8D%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>-–</p><p>title:  【转】Java统计代码的执行时间的6种方法</p><p>categories:</p><p>- java小知识</p><p>tags:</p><p>- Java</p><p>- 小知识</p><p>-–</p><h1 id="转载-Java统计代码的执行时间的6种方法"><a href="#转载-Java统计代码的执行时间的6种方法" class="headerlink" title="(转载)Java统计代码的执行时间的6种方法"></a>(转载)Java统计代码的执行时间的6种方法</h1><p><a href="https://blog.csdn.net/m0_37787662/article/details/108746373">(37条消息) Java统计代码的执行时间的6种方法_年少青山的博客-CSDN博客_java记录程序执行时间</a></p><p><img src="https://gitee.com/jwz--jwz/cloud-img/raw/master/image/20200923093826814.png" alt="img"></p><h2 id="方法一：System-currentTimeMillis"><a href="#方法一：System-currentTimeMillis" class="headerlink" title="方法一：System.currentTimeMillis"></a>方法一：System.currentTimeMillis</h2><p>此方法为 Java 内置的方法，使用 <code>System#currentTimeMillis</code> 来统计执行的时间（统计单位：毫秒），示例代码如下：</p><p><img src="https://gitee.com/jwz--jwz/cloud-img/raw/master/image/image-20220310005835924.png" alt="image-20220310005835924"></p><p><img src="https://gitee.com/jwz--jwz/cloud-img/raw/master/image/image-20220310005845181.png" alt="image-20220310005845181"></p><h2 id="方法二：System-nanoTime"><a href="#方法二：System-nanoTime" class="headerlink" title="方法二：System.nanoTime"></a>方法二：System.nanoTime</h2><p>此方法为 Java 内置的方法，使用 <code>System#nanoTime</code> 来统计执行时间（统计单位：纳秒），它的执行方法和 <code>System#currentTimeMillis</code> 类似，示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimeIntervalTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 开始时间</span></span><br><span class="line">        <span class="keyword">long</span> stime = System.nanoTime();</span><br><span class="line">        <span class="comment">// 执行时间（1s）</span></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        <span class="comment">// 结束时间</span></span><br><span class="line">        <span class="keyword">long</span> etime = System.nanoTime();</span><br><span class="line">        <span class="comment">// 计算执行时间</span></span><br><span class="line">        System.out.printf(<span class="string">&quot;执行时长：%d 纳秒.&quot;</span>, (etime - stime));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>执行时长：1000769200 纳秒.</p><p>小贴士：1 毫秒 = 100 万纳秒。</p></blockquote><h2 id="方法三：new-Date"><a href="#方法三：new-Date" class="headerlink" title="方法三：new Date"></a>方法三：new Date</h2><p>此方法也是 Java 的内置方法，在开始执行前 <code>new Date()</code> 创建一个当前时间对象，在执行结束之后 <code>new Date()</code> 一个当前执行时间，然后再统计两个 <code>Date</code> 的时间间隔，示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimeIntervalTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 开始时间</span></span><br><span class="line">        Date sdate = <span class="keyword">new</span> Date();</span><br><span class="line">        <span class="comment">// 执行时间（1s）</span></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        <span class="comment">// 结束时间</span></span><br><span class="line">        Date edate = <span class="keyword">new</span> Date();</span><br><span class="line">        <span class="comment">//  统计执行时间（毫秒）</span></span><br><span class="line">        System.out.printf(<span class="string">&quot;执行时长：%d 毫秒.&quot;</span> , (edate.getTime() - sdate.getTime())); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>执行时长：1000 毫秒</p></blockquote><h2 id="方法四：Spring-StopWatch"><a href="#方法四：Spring-StopWatch" class="headerlink" title="方法四：Spring StopWatch"></a>方法四：Spring StopWatch</h2><p>如果我们使用的是 Spring 或 Spring Boot 项目，可以在项目中直接使用 <code>StopWatch</code> 对象来统计代码执行时间，示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">StopWatch stopWatch = <span class="keyword">new</span> StopWatch();</span><br><span class="line"><span class="comment">// 开始时间</span></span><br><span class="line">stopWatch.start();</span><br><span class="line"><span class="comment">// 执行时间（1s）</span></span><br><span class="line">Thread.sleep(<span class="number">1000</span>);</span><br><span class="line"><span class="comment">// 结束时间</span></span><br><span class="line">stopWatch.stop();</span><br><span class="line"><span class="comment">// 统计执行时间（秒）</span></span><br><span class="line">System.out.printf(<span class="string">&quot;执行时长：%d 秒.%n&quot;</span>, stopWatch.getTotalTimeSeconds()); <span class="comment">// %n 为换行</span></span><br><span class="line"><span class="comment">// 统计执行时间（毫秒）</span></span><br><span class="line">System.out.printf(<span class="string">&quot;执行时长：%d 毫秒.%n&quot;</span>, stopWatch.getTotalTimeMillis()); </span><br><span class="line"><span class="comment">// 统计执行时间（纳秒）</span></span><br><span class="line">System.out.printf(<span class="string">&quot;执行时长：%d 纳秒.%n&quot;</span>, stopWatch.getTotalTimeNanos());</span><br></pre></td></tr></table></figure><blockquote><p>执行时长：0.9996313 秒. 执行时长：999 毫秒. 执行时长：999631300 纳秒.</p><p>小贴士：Thread#sleep 方法的执行时间稍有偏差，在 1s 左右都是正常的。</p></blockquote><h2 id="方法五：commons-lang3-StopWatch"><a href="#方法五：commons-lang3-StopWatch" class="headerlink" title="方法五：commons-lang3 StopWatch"></a>方法五：commons-lang3 StopWatch</h2><p>如果我们使用的是普通项目，那我们可以用 Apache commons-lang3 中的 <code>StopWatch</code> 对象来实现时间统计，首先先添加 commons-lang3 的依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.apache.commons/commons-lang3 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-lang3<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.commons.lang3.time.StopWatch;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimeIntervalTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        StopWatch stopWatch = <span class="keyword">new</span> StopWatch();</span><br><span class="line">        <span class="comment">// 开始时间</span></span><br><span class="line">        stopWatch.start();</span><br><span class="line">        <span class="comment">// 执行时间（1s）</span></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        <span class="comment">// 结束时间</span></span><br><span class="line">        stopWatch.stop();</span><br><span class="line">        <span class="comment">// 统计执行时间（秒）</span></span><br><span class="line">        System.out.println(<span class="string">&quot;执行时长：&quot;</span> + stopWatch.getTime(TimeUnit.SECONDS) + <span class="string">&quot; 秒.&quot;</span>);</span><br><span class="line">        <span class="comment">// 统计执行时间（毫秒）</span></span><br><span class="line">        System.out.println(<span class="string">&quot;执行时长：&quot;</span> + stopWatch.getTime(TimeUnit.MILLISECONDS) + <span class="string">&quot; 毫秒.&quot;</span>);</span><br><span class="line">        <span class="comment">// 统计执行时间（纳秒）</span></span><br><span class="line">        System.out.println(<span class="string">&quot;执行时长：&quot;</span> + stopWatch.getTime(TimeUnit.NANOSECONDS) + <span class="string">&quot; 纳秒.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>执行时长：1 秒. 执行时长：1000 毫秒.</p><p>执行时长：1000555100 纳秒.</p></blockquote><h2 id="方法六：Guava-Stopwatch"><a href="#方法六：Guava-Stopwatch" class="headerlink" title="方法六：Guava Stopwatch"></a>方法六：Guava Stopwatch</h2><p>除了 Apache 的 commons-lang3 外，还有一个常用的 Java 工具包，那就是 Google 的 Guava，Guava 中也包含了  <code>Stopwatch</code> 统计类。首先先添加 Guava 的依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/com.google.guava/guava --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.google.guava<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>guava<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>29.0-jre<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.google.common.base.Stopwatch;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimeIntervalTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 创建并启动计时器</span></span><br><span class="line">        Stopwatch stopwatch = Stopwatch.createStarted();</span><br><span class="line">        <span class="comment">// 执行时间（1s）</span></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        <span class="comment">// 停止计时器</span></span><br><span class="line">        stopwatch.stop();</span><br><span class="line">        <span class="comment">// 执行时间（单位：秒）</span></span><br><span class="line">        System.out.printf(<span class="string">&quot;执行时长：%d 秒. %n&quot;</span>, stopwatch.elapsed().getSeconds()); <span class="comment">// %n 为换行</span></span><br><span class="line">        <span class="comment">// 执行时间（单位：毫秒）</span></span><br><span class="line">        System.out.printf(<span class="string">&quot;执行时长：%d 豪秒.&quot;</span>, stopwatch.elapsed(TimeUnit.MILLISECONDS));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>执行时长：1 秒.</p><p>执行时长：1000 豪秒.</p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文介绍了 6 种实现代码统计的方法，其中 3 种是 Java 内置的方法：</p><p>System.currentTimeMillis()</p><p>System.nanoTime()</p><p>new Date()</p><p>还介绍了 3 种常用框架 spring、commons-langs3、guava 的时间统计器 StopWatch。</p><p>在没有用到 spring、commons-langs3、guava 任意一种框架的情况下，推荐使用 System.currentTimeMillis() 或 System.nanoTime() 来实现代码统计，否则建议直接使用 StopWatch 对象来统计执行时间。</p><h2 id="知识扩展—Stopwatch-让统计更方便"><a href="#知识扩展—Stopwatch-让统计更方便" class="headerlink" title="知识扩展—Stopwatch 让统计更方便"></a>知识扩展—Stopwatch 让统计更方便</h2><p><code>StopWatch</code> 存在的意义是让代码统计更简单，比如 Guava 中 <code>StopWatch</code> 使用示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.google.common.base.Stopwatch;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimeIntervalTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 创建并启动计时器</span></span><br><span class="line">        Stopwatch stopwatch = Stopwatch.createStarted();</span><br><span class="line">        <span class="comment">// 执行时间（1s）</span></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        <span class="comment">// 停止计时器</span></span><br><span class="line">        stopwatch.stop();</span><br><span class="line">        <span class="comment">// 执行统计</span></span><br><span class="line">        System.out.printf(<span class="string">&quot;执行时长：%d 毫秒. %n&quot;</span>,</span><br><span class="line">                stopwatch.elapsed(TimeUnit.MILLISECONDS));</span><br><span class="line">        <span class="comment">// 清空计时器</span></span><br><span class="line">        stopwatch.reset();</span><br><span class="line">        <span class="comment">// 再次启动统计</span></span><br><span class="line">        stopwatch.start();</span><br><span class="line">        <span class="comment">// 执行时间（2s）</span></span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        <span class="comment">// 停止计时器</span></span><br><span class="line">        stopwatch.stop();</span><br><span class="line">        <span class="comment">// 执行统计</span></span><br><span class="line">        System.out.printf(<span class="string">&quot;执行时长：%d 秒. %n&quot;</span>,</span><br><span class="line">                stopwatch.elapsed(TimeUnit.MILLISECONDS));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【转】使用 EhCache 关于临时目录的一个注意事项</title>
      <link href="/2022/03/10/EhCache%E7%8E%AF%E5%A2%83%E7%9B%AE%E5%BD%95%20/"/>
      <url>/2022/03/10/EhCache%E7%8E%AF%E5%A2%83%E7%9B%AE%E5%BD%95%20/</url>
      
        <content type="html"><![CDATA[<h1 id="【转】使用-EhCache-关于临时目录的一个注意事项"><a href="#【转】使用-EhCache-关于临时目录的一个注意事项" class="headerlink" title="【转】使用 EhCache 关于临时目录的一个注意事项"></a>【转】使用 EhCache 关于临时目录的一个注意事项</h1><p>一般 <a href="https://so.csdn.net/so/search?q=ehcache&spm=1001.2101.3001.7020">ehcache</a> 的配置中默认的 diskStore 的路径设置的是 java.io.tmpdir ，等于是当前系统的临时目录。</p><p>但是在 <a href="https://so.csdn.net/so/search?q=Tomcat&spm=1001.2101.3001.7020">Tomcat</a> 和 Resin 这两个应用服务器上，临时目录是有区别的，在 Tomcat 上运行的应用通过 java.io.tmpdir 系统变量获取到的路径是<a href="http://m.oschina.net/p/tomcat">Tomcat</a> 目录下的 temp 子目录，而 <a href="http://m.oschina.net/p/resin">Resin</a> 返回的是系统的临时目录，linux下可能就是 /tmp，在 Linux 下如果我们使用的是 root 账号来启动 Tomcat 和 Resin 的话，那这个问题就不存在。但是我们非常不建议用 root 来启动 Tomcat 和 Resin，这时候我们会单独的创建一个非特权账号，假设该账号名为 www 来运行应用服务器。</p><p>我们需要将 Tomcat 和 Resin 所在的目录授权给 www 账号，这样应用服务器的日志文件才能正常的写入，但是由于 Resin 的临时目录是对应系统的 /tmp 目录，因此如果应用中使用了 ehcache 并设置了存储路径为 java.io.tmpdir ，你就会发现启动的时候报错，提示没有在 /tmp 目录下创建文件的权限，这是因为 www 账号没有写 tmp 目录的权限。</p><h2 id="解决办法："><a href="#解决办法：" class="headerlink" title="解决办法："></a>解决办法：</h2><p>修改 ehcache 的 diskStore 配置的值为 user.home ，将存储文件路径指定到用户的主目录下即可</p><h2 id="windows路径"><a href="#windows路径" class="headerlink" title="windows路径"></a>windows路径</h2><p><img src="https://gitee.com/jwz--jwz/cloud-img/raw/master/image/image-20220310003739608.png" alt="image-20220310003739608"></p><h2 id="Liunx路径："><a href="#Liunx路径：" class="headerlink" title="Liunx路径："></a>Liunx路径：</h2><p><img src="https://gitee.com/jwz--jwz/cloud-img/raw/master/image/image-20220310003922706.png" alt="image-20220310003922706"></p>]]></content>
      
      
      <categories>
          
          <category> EhCache </category>
          
      </categories>
      
      
        <tags>
            
            <tag> EhCache </tag>
            
            <tag> 配置问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>tomcat配置</title>
      <link href="/2022/03/10/tomcat%20%20%E9%85%8D%E7%BD%AE/"/>
      <url>/2022/03/10/tomcat%20%20%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="tomcat-配置："><a href="#tomcat-配置：" class="headerlink" title="tomcat  配置："></a>tomcat  配置：</h1><p><a href="https://blog.csdn.net/weixin_38958597/article/details/114241682">(36条消息) windows下Tomcat详细安装配置教程_From zero-CSDN博客_tomcat安装配置详解</a></p><h1 id="一、版本选择："><a href="#一、版本选择：" class="headerlink" title="一、版本选择："></a>一、版本选择：</h1><p><img src="https://gitee.com/jwz--jwz/cloud-img/raw/master/image/202202272235886.png" alt="image-20220227223535810">选择</p><h2 id="二、下载"><a href="#二、下载" class="headerlink" title="二、下载"></a>二、下载</h2><p>Tomcat是免费开源的<a href="https://so.csdn.net/so/search?q=web%E6%9C%8D%E5%8A%A1&spm=1001.2101.3001.7020">web服务</a>器软件，所以我们可以直接在官网下载：<a href="https://tomcat.apache.org/index.html">https://tomcat.apache.org/index.html</a></p><p>下载路径：</p><p><a href="https://downloads.apache.org/tomcat/tomcat-9/v9.0.44/bin/apache-tomcat-9.0.44-windows-x64.zi">https://downloads.apache.org/tomcat/tomcat-9/v9.0.44/bin/apache-tomcat-9.0.44-windows-x64.zi</a></p><p><img src="https://gitee.com/jwz--jwz/cloud-img/raw/master/image/202202272229527.png" alt="image-20220227222953440"></p><p><img src="https://gitee.com/jwz--jwz/cloud-img/raw/master/image/202202272230629.png" alt="image-20220227223010551"></p><p><img src="https://gitee.com/jwz--jwz/cloud-img/raw/master/image/202202272230826.png" alt="image-20220227223036779"></p><h3 id="修改jdk的路径"><a href="#修改jdk的路径" class="headerlink" title="修改jdk的路径"></a>修改jdk的路径</h3><p><img src="https://gitee.com/jwz--jwz/cloud-img/raw/master/image/202202272322106.png" alt="image-20220227232246996"></p><p><img src="https://gitee.com/jwz--jwz/cloud-img/raw/master/image/202202272323916.png" alt="image-20220227232341821"></p><p><img src="https://gitee.com/jwz--jwz/cloud-img/raw/master/image/202202272324320.png" alt="image-20220227232423241"></p><h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><p><img src="https://gitee.com/jwz--jwz/cloud-img/raw/master/image/202202272326966.png" alt="image-20220227232652923"></p><p><img src="https://gitee.com/jwz--jwz/cloud-img/raw/master/image/202202272326992.png" alt="image-20220227232609866"></p><h2 id="本地配置："><a href="#本地配置：" class="headerlink" title="本地配置："></a>本地配置：</h2><p>环境变量在哪配我想应该不用多说了，如果没配JDK的环境变量，是启动不了tomcat的。</p><p>直接在<strong>系统变量</strong>下新建一个环境变量：</p><p><strong>变量名</strong>：CATALINA_HOME</p><p><strong>变量值</strong>：tomcat安装目录</p><p>然后就解决了上面所说的第二种启动方式。</p><p><img src="https://gitee.com/jwz--jwz/cloud-img/raw/master/image/202202272329518.png" alt="image-20220227232942460"></p><p><img src="https://gitee.com/jwz--jwz/cloud-img/raw/master/image/202202272329033.png" alt="image-20220227232921977"></p><p>这里我偷懒直接用了CATALINA_HOME的环境变量，你也可以新建一个TOMCAT_HOME，然后值和CATALINA_HOME的变量一样，再加入进去，都可以。</p><p><strong>测试</strong>：</p><p>可以看到，在任意地方直接输入startup.bat，都可以正常启动了。</p><p><img src="https://gitee.com/jwz--jwz/cloud-img/raw/master/image/202202272331285.png" alt="image-20220227233106216"></p><p><img src="https://gitee.com/jwz--jwz/cloud-img/raw/master/image/202202272333683.png" alt="image-20220227233344615"></p><p><img src="https://gitee.com/jwz--jwz/cloud-img/raw/master/image/202202272333289.png" alt="image-20220227233336211"></p><p><img src="https://gitee.com/jwz--jwz/cloud-img/raw/master/image/202202272336476.png" alt="image-20220227233654413"></p><p><img src="https://gitee.com/jwz--jwz/cloud-img/raw/master/image/202202272336304.png" alt="image-20220227233637224"></p><h1 id="maven配置"><a href="#maven配置" class="headerlink" title="maven配置"></a>maven配置</h1><p><a href="https://blog.csdn.net/weixin_43811057/article/details/108235117?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~BlogCommendFromBaidu~Rate-1.pc_relevant_default&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~BlogCommendFromBaidu~Rate-1.pc_relevant_default&utm_relevant_index=1">(36条消息) maven安装及配置（详细版）_伏加特遇上西柚的博客-CSDN博客_maven 安装</a></p><p><a href="https://blog.csdn.net/wyf2017/article/details/105713362">(36条消息) IDEA中配置Maven_あなたを待って-CSDN博客</a></p>]]></content>
      
      
      <categories>
          
          <category> tomcat </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tomcat </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>什么是IOC</title>
      <link href="/2022/03/10/IOC/"/>
      <url>/2022/03/10/IOC/</url>
      
        <content type="html"><![CDATA[<h1 id="IOC是什么"><a href="#IOC是什么" class="headerlink" title="IOC是什么:"></a>IOC是什么:</h1><h1 id="IOC的理论背景"><a href="#IOC的理论背景" class="headerlink" title="IOC的理论背景:"></a>IOC的理论背景:</h1><p>在面向设计的软件系统中，他的底层都是由N个对象构成的，各个对象之间相互合作，最终实现业务逻辑</p><p><img src="https://gitee.com/jwz--jwz/cloud-img/raw/master/image/202201162356392.png" alt="img"></p><p>​                                            软件系统中的耦合对象</p><p>　　齿轮组中齿轮之间的啮合关系,与软件系统中对象之间的耦合关系非常相似。对象之间的耦合关系是无法避免的，也是必要的，这是协同工作的基础。现在，伴随着工业级应用的规模越来越庞大，对象之间的依赖关系也越来越复杂，经常会出现对象之间的多重依赖性关系，因此，架构师和设计师对于系统的分析和设计，将面临更大的挑战。对象之间耦合度过高的系统，必然会出现牵一发而动全身的情形。</p><p><img src="https://gitee.com/jwz--jwz/cloud-img/raw/master/image/202201162356403.png" alt="img"></p><p>　　图2 对象之间的依赖关系</p><p>　　耦合关系不仅会出现在对象与对象之间，也会出现在软件系统的各模块之间，以及软件系统和硬件系统之间。如何降低系统之间、模块之间和对象之间的耦合度，是软件工程永远追求的目标之一。为了解决对象之间的耦合度过高的问题，软件专家Michael Mattson 1996年提出了IOC理论，用来实现对象之间的“解耦”，目前这个理论已经被成功地应用到实践当中。</p><h1 id="什么是IOC"><a href="#什么是IOC" class="headerlink" title="什么是IOC"></a>什么是IOC</h1><blockquote><p>IOC是Inversion of Control的缩写，多数书籍翻译成“控制反转”。</p><p>IOC理论提出的观点大体是这样的：借助于“第三方”实现具有依赖关系的对象之间的解耦。IoC 不是一种技术，只是一种思想，一个重要的面向对象编程的法则，它能指导我们如何设计出松耦合、更优良的程序</p></blockquote><p><img src="https://gitee.com/jwz--jwz/cloud-img/raw/master/image/202201162357730.png" alt="img"></p><p>大家看到了吧，由于引进了中间位置的“第三方”，也就是IOC容器，使得A、B、C、D这4个对象没有了耦合关系，齿轮之间的传动全部依靠“第三方”了，全部对象的控制权全部上缴给“第三方”IOC容器，所以，IOC容器成了整个系统的关键核心，它起到了一种类似“粘合剂”的作用，把系统中的所有对象粘合在一起发挥作用，如果没有这个“粘合剂”，对象与对象之间会彼此失去联系，这就是有人把IOC容器比喻成“粘合剂”的由来。</p><p>　　我们再来做个试验：把上图中间的IOC容器拿掉，然后再来看看这套系统：</p><p><img src="https://gitee.com/jwz--jwz/cloud-img/raw/master/image/202201162359293.png" alt="img"></p><p>​                                                         图4 拿掉IOC容器后的系统</p><p>从上图我们可以看出 A、B、C、D 这四个对象之间已经没有了耦合关系。当去实现A时，不用再去考虑B、C、D.</p><p>控制反转(IOC)到底为什么要起这么个名字?</p><blockquote><p>  软件系统在没有引入IOC容器之前，如图1所示，对象A依赖于对象B，那么对象A在初始化或者运行到某一点的时候，<strong>自己必须主动去创建对象B或者使用已经创建的对象B</strong>。无论是创建还是使用对象B，控制权都在自己手上。</p></blockquote><blockquote><p>软件系统在引入IOC容器之后，这种情形就完全改变了，如图3所示，由于IOC容器的加入，对象A与对象B之间失去了直接联系，所以，当对象A运行到需要对象B的时候，IOC容器会主动创建一个对象B注入到对象A需要的地方。</p></blockquote><blockquote><p><strong>对象A获得依赖对象B的过程,由主动行为变为了被动行为，控制权颠倒过来了，这就是“控制反转”这个名称的由来。</strong></p></blockquote><h1 id="IOC也叫依赖注入（DI-）"><a href="#IOC也叫依赖注入（DI-）" class="headerlink" title="IOC也叫依赖注入（DI ）"></a>IOC也叫依赖注入（DI ）</h1><p>2004年，Martin Fowler探讨了同一个问题，既然IOC是控制反转，那么到底是“<strong>哪些方面的控制被反转了呢</strong>？”经过详细地分析和论证后，他得出了答案：“<strong>获得依赖对象的过程被反转了</strong>“</p><p>控制反转之后，获取对象的过程变成了有IOC容器主动进行注入。于是将控制反转起了一个更为合适的名字”依赖注入（Dependency Injection）“。</p><blockquote><p><strong>所谓依赖注入，就是由IOC容器在运行期间，动态地将某种依赖关系注入到对象之中。</strong></p><p>　　所以，依赖注入(DI)和控制反转(IOC)是从不同的角度的描述的同一件事情，就是指通过引入IOC容器，利用依赖关系注入的方式，实现对象之间的解耦。</p></blockquote><p>即由容器动态的将某个依赖关系注入到组件之中。依赖注入的目的并非为软件系统带来更多功能，而是为了提升组件重用的频率，并为系统搭建一个灵活、可扩展的平台。通过依赖注入机制，我们只需要通过简单的配置，而无需任何代码就可指定目标需要的资源，完成自身的业务逻辑，而不需要关心具体的资源来自何处，由谁实现。</p><p>　　理解DI的关键是：“谁依赖谁，为什么需要依赖，谁注入谁，注入了什么”，那我们来深入分析一下：</p><p>　　●谁依赖于谁：当然是应用程序依赖于IoC容器；</p><p>　　●为什么需要依赖：应用程序需要IoC容器来提供对象需要的外部资源；</p><p>　　●谁注入谁：很明显是IoC容器注入应用程序某个对象，应用程序依赖的对象；</p><p>　　●注入了什么：就是注入某个对象所需要的外部资源（包括对象、资源、<a href="https://www.zhihu.com/search?q=%E5%B8%B8%E9%87%8F%E6%95%B0%E6%8D%AE&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:753288166%7D">常量数据</a>）。</p><p><a href="https://blog.csdn.net/ivan820819/article/details/79744797">https://blog.csdn.net/ivan820819/article/details/79744797</a>)</p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IDEA使用maven命令打包</title>
      <link href="/2022/03/10/IDEA%E4%BD%BF%E7%94%A8maven%E5%91%BD%E4%BB%A4%E6%89%93%E5%8C%85/"/>
      <url>/2022/03/10/IDEA%E4%BD%BF%E7%94%A8maven%E5%91%BD%E4%BB%A4%E6%89%93%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<h1 id="IDEA使用maven命令打包"><a href="#IDEA使用maven命令打包" class="headerlink" title="IDEA使用maven命令打包"></a>IDEA使用maven命令打包</h1><p>现在IDEA是最火的java集成开发环境，经常会用到一些<a href="https://so.csdn.net/so/search?q=maven&spm=1001.2101.3001.7020">maven</a>命令进行必要的操作（例如打jar包），所以在这里做一些简单的总结</p><h2 id="1-常用打包命令："><a href="#1-常用打包命令：" class="headerlink" title="1.常用打包命令："></a>1.常用打包命令：</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mvn clean package -Dmaven.test.skip=true跳过单测打包</span><br><span class="line">mvn clean install -Dmaven.test.skip=true跳过单测打包，并把打好的包上传到本地仓库</span><br><span class="line">mvn clean deploy -Dmaven.test.skip=true跳过单测打包，并把打好的包上传到远程仓库</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="2-常用命令列表："><a href="#2-常用命令列表：" class="headerlink" title="2.常用命令列表："></a>2.常用命令列表：</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">mvn -v //查看版本 </span><br><span class="line">mvn archetype:create //创建 Maven 项目 </span><br><span class="line">mvn compile //编译源代码 </span><br><span class="line">mvn test-compile //编译测试代码 </span><br><span class="line">mvn test //运行应用程序中的单元测试 </span><br><span class="line">mvn site //生成项目相关信息的网站 </span><br><span class="line">mvn package //依据项目生成 jar 文件 </span><br><span class="line">mvn install //在本地 Repository 中安装 jar </span><br><span class="line">mvn -Dmaven.test.skip=true //忽略测试文档编译 </span><br><span class="line">mvn clean //清除目标目录中的生成结果 </span><br><span class="line">mvn clean compile //将.java类编译为.class文件 </span><br><span class="line">mvn clean package //进行打包 </span><br><span class="line">mvn clean test //执行单元测试 </span><br><span class="line">mvn clean deploy //部署到版本仓库 </span><br><span class="line">mvn clean install //使其他项目使用这个jar,会安装到maven本地仓库中 </span><br><span class="line">mvn archetype:generate //创建项目架构 </span><br><span class="line">mvn dependency:list //查看已解析依赖 </span><br><span class="line">mvn dependency:tree //看到依赖树 </span><br><span class="line">mvn dependency:analyze //查看依赖的工具 </span><br><span class="line">mvn help:system //从中央仓库下载文件至本地仓库 </span><br><span class="line">mvn help:active-profiles //查看当前激活的profiles </span><br><span class="line">mvn help:all-profiles //查看所有profiles </span><br><span class="line">mvn help:effective -pom //查看完整的pom信息</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>maven 命令要在IDEA的Terminal窗口执行<br>    执行maven命令需要当前目录有pom依赖，可以用cd命令切换目录</p><p><img src="https://gitee.com/jwz--jwz/cloud-img/raw/master/image/image-20220310002658226.png" alt="image-20220310002658226"></p><p>也可以使用idea,前提是maven项目</p><p><img src="https://gitee.com/jwz--jwz/cloud-img/raw/master/image/image-20220310002744603.png" alt="image-20220310002744603"></p>]]></content>
      
      
      <categories>
          
          <category> maven </category>
          
      </categories>
      
      
        <tags>
            
            <tag> maven指令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>maven打包错误</title>
      <link href="/2022/03/10/packageError/"/>
      <url>/2022/03/10/packageError/</url>
      
        <content type="html"><![CDATA[<h1 id="resolution-will-not-be-reattempted-until-the-update-interval-of-XXX-has-elapsed-or-updates-are-force"><a href="#resolution-will-not-be-reattempted-until-the-update-interval-of-XXX-has-elapsed-or-updates-are-force" class="headerlink" title="resolution will not be reattempted until the update interval of XXX has elapsed or updates are force"></a>resolution will not be reattempted until the update interval of XXX has elapsed or updates are force</h1><h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><p>Java：1.8<br>     maven：3.6.3</p><p>主要错误消息，如题：<br>就是<code>resolution will not be reattempted until the update interval of XXX has elapsed or updates are force</code></p><p>意思就是：</p><blockquote><p>在 XXX的更新间隔过去或强制更新之前，不会重新尝试解析。</p></blockquote><p>如果你去本地的maven仓库，你会发现，其只有lastUpdate结尾的文件，没有jar包。</p><p>这个时候，你无论怎么点击IDEA中的Reimports All Maven Projects都是没有用的。原因上面也说了，要么等更新时间过去，要么强制更新。<br>maven的默认更新时间为day，即一天更新一次。</p><p>所以我们一般都是采用强制更新的方式。</p><h2 id="使用命令行"><a href="#使用命令行" class="headerlink" title="使用命令行"></a>使用命令行</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn clean install -U</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> maven </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 错误问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java基础</title>
      <link href="/2022/01/20/JAVA%E5%AD%A6%E4%B9%A0%EF%BC%9A/"/>
      <url>/2022/01/20/JAVA%E5%AD%A6%E4%B9%A0%EF%BC%9A/</url>
      
        <content type="html"><![CDATA[<h2 id="JAVA学习"><a href="#JAVA学习" class="headerlink" title="JAVA学习"></a>JAVA学习</h2><h3 id="Java小知识之代码优化："><a href="#Java小知识之代码优化：" class="headerlink" title="Java小知识之代码优化："></a>Java小知识之代码优化：</h3><p>​                            代码优化的目标是</p><ul><li>减小代码的体积</li><li>提高代码运行的效率</li></ul><p>​                </p><h5 id="1、尽量重用对象："><a href="#1、尽量重用对象：" class="headerlink" title="1、尽量重用对象："></a>1、尽量重用对象：</h5><p>​           1、特别是String对象的使用，出现字符串连接时应该使用StringBuilder/StringBu ffer代替。由于Java虚拟机不仅要花时间生成对象，以后可能还需要花时间对这些对象进行垃圾回收和处理，因此，生成过多的对象将会给程序的性能带来很大的影响。</p><h5 id="2、循环内不要不断创建对象引用"><a href="#2、循环内不要不断创建对象引用" class="headerlink" title="2、循环内不要不断创建对象引用"></a>2、循环内不要不断创建对象引用</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= count; i++) &#123;Object obj = <span class="keyword">new</span> Object(); &#125;</span><br></pre></td></tr></table></figure><p>​       这种做法会导致内存中有count份Object对象引用存在，count很大的话，就耗费内存了，建议为改为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object obj = <span class="keyword">null</span>;<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= count; i++) &#123; obj = <span class="keyword">new</span> Object(); &#125;</span><br></pre></td></tr></table></figure><p>​         内存中只有一份Object对象引用，每次new Object()的时候，Object对象引用指向不同的Object罢了，但是内存中只有一份，这样就大大节省了内存空间了</p><p>​       3、 尽量使用HashMap、ArrayList、StringBuilder，除非线程安全需要，否则不推荐使用Hashtable、Vector、StringBuffer，后三者由于使用 同步机制而导致了性能开销</p><p>​       4、实现RandomAccess接口的集合比如ArrayList，应当使用最普通的for循环而不是foreach循环来遍历</p><p>这是JDK推荐给用户的。JDK API对于RandomAccess接口的解释是：实现RandomAccess接口用来表明其支持快速随机访问，此接口的主要目的是允许一般的算法更改其行为，从而将其应用到随机或连续访问列表时能提供良好的性能。实际经验表明，实现RandomAccess接口的类实例，假如是随机访问的，使用普通for循环效率将高于使用foreach循环；反过来，如果是顺序访问的，则使用Iterator会效率更高。可以使用类似如下的代码作判断：``</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (list <span class="keyword">instanceof</span> RandomAccess)</span><br><span class="line">&#123; <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++)&#123;&#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">Iterator&lt;?&gt; iterator = list.iterable(); <span class="keyword">while</span> (iterator.hasNext())&#123;iterator.next()&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>foreach循环的底层实现原理就是迭代器Iterator，参见Java语法糖1：可变长度参数以及foreach循环原理。所以后半句”反过来，如果是顺序访问的，则使用Iterator会效率更高”的意思就是顺序访问的那些类实例，使用foreach循环去遍历。</p><hr><h3 id="Java判断字符串是否为空"><a href="#Java判断字符串是否为空" class="headerlink" title="Java判断字符串是否为空"></a>Java判断字符串是否为空</h3><h4 id="一-空字符串与null区别"><a href="#一-空字符串与null区别" class="headerlink" title="一.空字符串与null区别"></a>一.空字符串与null区别</h4><h5 id="1、类型"><a href="#1、类型" class="headerlink" title="1、类型"></a>1、类型</h5><p>null表示的是一个对象的值，而并不是一个字符串。例如声明一个对象的引用，String a = null ;<br>“”表示的是一个空字符串，也就是说它的长度为0。例如声明一个字符串String str = “” ;</p><h5 id="2、内存分配"><a href="#2、内存分配" class="headerlink" title="2、内存分配"></a>2、内存分配</h5><p>String str = null ; 表示声明一个字符串对象的引用，但指向为null，也就是说还没有指向任何的内存空间；<br>String str = “”;    表示声明一个字符串类型的引用，其值为””空字符串，这个str引用指向的是空字符串的内存空间；<br>在java中变量和引用变量是存在栈中（stack），而对象（new产生的）都是存放在堆中（heap）：</p><p>就如下：</p><p>String str = new String(“abc”) ;</p><p>ps：=左边的是存放在栈中（stack），=右边是存放在堆中（heap）。</p><h5 id="3、示例程序："><a href="#3、示例程序：" class="headerlink" title="3、示例程序："></a>3、示例程序：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">String_Demo01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;        </span><br><span class="line">        String str1 = <span class="keyword">new</span> String() ;</span><br><span class="line">        String str2 = <span class="keyword">null</span> ;</span><br><span class="line">        String str3 = <span class="string">&quot;&quot;</span> ;</span><br><span class="line">        System.out.println(str1==str2);                <span class="comment">//内存地址的比较，返回false</span></span><br><span class="line">        System.out.println(str1.equals(str2));         <span class="comment">//值的比较，返回false</span></span><br><span class="line">        System.out.println(str2==str3);                <span class="comment">//内存地址的比较，返回false</span></span><br><span class="line">        System.out.println(str3.equals(str2));         <span class="comment">//值的比较，返回false</span></span><br><span class="line">        System.out.println(str1==str3);                <span class="comment">//内存地址的比较，返回false</span></span><br><span class="line">        System.out.println(str1.equals(str3));         <span class="comment">//值的比较，返回true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过如上的程序可以得出如下结论：</p><blockquote><p>字符串对象与null的值不相等，且内存地址也不相等；<br>空字符串对象与null的值不相等，且内存地址也不相等；<br>new String()创建一个字符串对象的默认值为”” （String类型成员变量的初始值为null）</p></blockquote><h5 id="4-Java判断字符串常方法"><a href="#4-Java判断字符串常方法" class="headerlink" title="4.Java判断字符串常方法"></a>4.Java判断字符串常方法</h5><p>方法一: 最多人使用的一个方法, 直观, 方便, 但效率很低:</p><pre><code>                 if(s == null || s.equals(&quot;&quot;));</code></pre><p>方法二: 比较字符串长度, 效率高, 是我知道的最好一个方法:</p><pre><code>                 if(s == null || s.length() == 0);</code></pre><p>方法三: Java SE 6.0 才开始提供的方法, 效率和方法二几乎相等, 但出于兼容性考虑, 推荐使用方法二.</p><pre><code>                 if(s == null || s.isEmpty());</code></pre><p>方法四: 这是一种比较直观,简便的方法,而且效率也非常的高,与方法二、三的效率差不多:</p><pre><code>                 if (s == null || s == &quot;&quot;);</code></pre><p> 注意:s == null 是有必要存在的.</p><p>　　如果 String 类型为null, 而去进行 equals(String) 或 length() 等操作会抛出java.lang.NullPointerException.</p><p>　　并且s==null 的顺序必须出现在前面，不然同样会抛出java.lang.NullPointerException.</p><p>　　如下Java代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="keyword">null</span>;</span><br><span class="line">　　<span class="keyword">if</span>(str.equals(<span class="string">&quot;&quot;</span>) || str == <span class="keyword">null</span>)&#123;<span class="comment">//会抛出异常</span></span><br><span class="line">　　          System.out.println(<span class="string">&quot;success&quot;</span>);</span><br><span class="line">　　&#125;</span><br></pre></td></tr></table></figure><h5 id="五、StringUtils的isBlank与isEmply"><a href="#五、StringUtils的isBlank与isEmply" class="headerlink" title="五、StringUtils的isBlank与isEmply"></a>五、StringUtils的isBlank与isEmply</h5><h6 id="1-public-static-boolean-isEmpty-String-str"><a href="#1-public-static-boolean-isEmpty-String-str" class="headerlink" title="1.public static boolean isEmpty(String str)"></a>1.public static boolean isEmpty(String str)</h6><p>　　判断某字符串是否为空，为空的标准是 str==null 或 str.length()==0</p><p>　　下面是 StringUtils 判断是否为空的示例： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">　　StringUtils.isEmpty(<span class="keyword">null</span>) = <span class="keyword">true</span></span><br><span class="line"></span><br><span class="line">　　StringUtils.isEmpty(<span class="string">&quot;&quot;</span>) = <span class="keyword">true</span></span><br><span class="line"></span><br><span class="line">　　StringUtils.isEmpty(<span class="string">&quot; &quot;</span>) = <span class="keyword">false</span> <span class="comment">//注意在 StringUtils 中空格作非空处理 </span></span><br><span class="line"></span><br><span class="line">　　StringUtils.isEmpty(<span class="string">&quot;   &quot;</span>) = <span class="keyword">false</span></span><br><span class="line"></span><br><span class="line">　　StringUtils.isEmpty(<span class="string">&quot;bob&quot;</span>) = <span class="keyword">false</span></span><br><span class="line"></span><br><span class="line">　　StringUtils.isEmpty(<span class="string">&quot; bob &quot;</span>) = <span class="keyword">false</span></span><br></pre></td></tr></table></figure><h6 id="2-public-static-boolean-isNotEmpty-String-str"><a href="#2-public-static-boolean-isNotEmpty-String-str" class="headerlink" title="2.public static boolean isNotEmpty(String str)"></a>2.public static boolean isNotEmpty(String str)</h6><p>　　判断某字符串是否非空，等于 !isEmpty(String str) </p><p>　　下面是示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">　　StringUtils.isNotEmpty(<span class="keyword">null</span>) = <span class="keyword">false</span></span><br><span class="line"></span><br><span class="line">　　StringUtils.isNotEmpty(<span class="string">&quot;&quot;</span>) = <span class="keyword">false</span></span><br><span class="line"></span><br><span class="line">　　StringUtils.isNotEmpty(<span class="string">&quot; &quot;</span>) = <span class="keyword">true</span></span><br><span class="line"></span><br><span class="line">　　StringUtils.isNotEmpty(<span class="string">&quot;         &quot;</span>) = <span class="keyword">true</span></span><br><span class="line"></span><br><span class="line">　　StringUtils.isNotEmpty(<span class="string">&quot;bob&quot;</span>) = <span class="keyword">true</span></span><br><span class="line"></span><br><span class="line">　　StringUtils.isNotEmpty(<span class="string">&quot; bob &quot;</span>) = <span class="keyword">true</span></span><br></pre></td></tr></table></figure><h6 id="3-pblic-static-boolean-isBlank-String-str"><a href="#3-pblic-static-boolean-isBlank-String-str" class="headerlink" title="3.pblic static boolean isBlank(String str)"></a>3.pblic static boolean isBlank(String str)</h6><p>　　判断某字符串是否为空或长度为0或由空白符(whitespace) 构成 </p><p>　　下面是示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">　　StringUtils.isBlank(<span class="keyword">null</span>) = <span class="keyword">true</span></span><br><span class="line"></span><br><span class="line">　　StringUtils.isBlank(<span class="string">&quot;&quot;</span>) = <span class="keyword">true</span></span><br><span class="line"></span><br><span class="line">　　StringUtils.isBlank(<span class="string">&quot; &quot;</span>) = <span class="keyword">true</span></span><br><span class="line"></span><br><span class="line">　　StringUtils.isBlank(<span class="string">&quot;        &quot;</span>) = <span class="keyword">true</span></span><br><span class="line"></span><br><span class="line">　　StringUtils.isBlank(<span class="string">&quot;\t \n \f \r&quot;</span>) = <span class="keyword">true</span>   <span class="comment">//对于制表符、换行符、换页符和回车符</span></span><br><span class="line"></span><br><span class="line">　　StringUtils.isBlank()  <span class="comment">//均识为空白符</span></span><br><span class="line"></span><br><span class="line">　　StringUtils.isBlank(<span class="string">&quot;\b&quot;</span>) = <span class="keyword">false</span>   <span class="comment">//&quot;\b&quot;为单词边界符</span></span><br><span class="line"></span><br><span class="line">　　StringUtils.isBlank(<span class="string">&quot;bob&quot;</span>) = <span class="keyword">false</span></span><br><span class="line"></span><br><span class="line">　　StringUtils.isBlank(<span class="string">&quot; bob &quot;</span>) = <span class="keyword">false</span></span><br></pre></td></tr></table></figure><h6 id="4-public-static-boolean-isNotBlank-String-str"><a href="#4-public-static-boolean-isNotBlank-String-str" class="headerlink" title="4.public static boolean isNotBlank(String str)"></a>4.public static boolean isNotBlank(String str)</h6><p>　　判断某字符串是否不为空且长度不为0且不由空白符(whitespace) 构成，等于 !isBlank(String str) </p><p>　　下面是示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">　　StringUtils.isNotBlank(<span class="keyword">null</span>) = <span class="keyword">false</span></span><br><span class="line"></span><br><span class="line">　　StringUtils.isNotBlank(<span class="string">&quot;&quot;</span>) = <span class="keyword">false</span></span><br><span class="line"></span><br><span class="line">　　StringUtils.isNotBlank(<span class="string">&quot; &quot;</span>) = <span class="keyword">false</span></span><br><span class="line"></span><br><span class="line">　　StringUtils.isNotBlank(<span class="string">&quot;         &quot;</span>) = <span class="keyword">false</span></span><br><span class="line"></span><br><span class="line">　　StringUtils.isNotBlank(<span class="string">&quot;\t \n \f \r&quot;</span>) = <span class="keyword">false</span></span><br><span class="line"></span><br><span class="line">　　StringUtils.isNotBlank(<span class="string">&quot;\b&quot;</span>) = <span class="keyword">true</span></span><br><span class="line"></span><br><span class="line">　　StringUtils.isNotBlank(<span class="string">&quot;bob&quot;</span>) = <span class="keyword">true</span></span><br><span class="line"></span><br><span class="line">　　StringUtils.isNotBlank(<span class="string">&quot; bob &quot;</span>) = <span class="keyword">true</span></span><br></pre></td></tr></table></figure><h3 id="java-list如何进行判断空"><a href="#java-list如何进行判断空" class="headerlink" title="java list如何进行判断空"></a>java list如何进行判断空</h3><h4 id="1、常用表达方式"><a href="#1、常用表达方式" class="headerlink" title="1、常用表达方式"></a>1、常用表达方式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="keyword">null</span> == list || list.size() ==<span class="number">0</span> )&#123;</span><br><span class="line"></span><br><span class="line">　　<span class="comment">//为空的情况</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"></span><br><span class="line">　　<span class="comment">//不为空的情况</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(list!=<span class="keyword">null</span> &amp;&amp; !list.isEmpty())&#123;</span><br><span class="line">　　　<span class="comment">//不为空的情况</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">　　　<span class="comment">//为空的情况</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2、遇到问题"><a href="#2、遇到问题" class="headerlink" title="2、遇到问题"></a>2、遇到问题</h4><h5 id="1、-list-isEmpty-和-list-size-0"><a href="#1、-list-isEmpty-和-list-size-0" class="headerlink" title="1、 list.isEmpty() 和 list.size()==0"></a>1、 list.isEmpty() 和 list.size()==0</h5><p>　　答案：没有区别 。isEmpty()判断有没有元素，而size()返回有几个元素， 如果判断一个集合有无元素 建议用isEmpty()方法.比较符合逻辑用法。</p><h5 id="2、-list！-null-跟-！-list-isEmpty"><a href="#2、-list！-null-跟-！-list-isEmpty" class="headerlink" title="2、 list！=null 跟 ！ list.isEmpty()"></a>2、 list！=null 跟 ！ list.isEmpty()</h5><p>　　这就相当与，你要要到商店买东西</p><p>　　　　list！=null 首先判断是否有商店</p><p>　　　　！list.isEmpty() 没有判断商店是否存在，而是判断商店是否有东西</p><h3 id="Java局部变量、成员变量、类变量"><a href="#Java局部变量、成员变量、类变量" class="headerlink" title="Java局部变量、成员变量、类变量"></a>Java局部变量、成员变量、类变量</h3><h4 id="1、实例变量"><a href="#1、实例变量" class="headerlink" title="1、实例变量"></a>1、实例变量</h4><p>  也叫对象变量、类成员变量：从属于类,并由类生生成对象是，才分配存储空间， 能通过对象访问实例变量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> String nameString;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> age;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">int</span> priority;</span><br><span class="line"><span class="comment">//实例方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getNameString</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.nameString;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="类变量："><a href="#类变量：" class="headerlink" title="类变量："></a>类变量：</h4><p>也叫静态变量，是一种比较特殊的实例变量，用static关键字修饰；一个类的静态变量，所有由这类生成的对象都共用这个类变量，类装载时就分配存储空间。一个对象修改了变量，则所以对象中这个变量的值都会发生改变。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类变量（静态变量）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//实例变量</span></span><br><span class="line">   <span class="keyword">private</span> String nameString;</span><br></pre></td></tr></table></figure><h4 id="局部变量："><a href="#局部变量：" class="headerlink" title="局部变量："></a>局部变量：</h4><p>方法中或者某局部中声明定义的变量方法或方法的参数 ,他们只存在创建他们的block里无法再block外面进行任何操作，在Java的多线程中，每个线程都会复制一份局部的变量，可以防止某些同步问题的发生</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//实例变量</span></span><br><span class="line"><span class="keyword">private</span> String nameString;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//局部变量</span></span><br><span class="line"><span class="keyword">int</span> temp = <span class="number">1</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/jwz--jwz/cloud-img/raw/master/image/202201222320395.png" alt="image-20210723003109260"></p><h4 id="四、他们的区别"><a href="#四、他们的区别" class="headerlink" title="四、他们的区别"></a>四、他们的区别</h4><h5 id="成员变量和局部变量的区别"><a href="#成员变量和局部变量的区别" class="headerlink" title="成员变量和局部变量的区别"></a>成员变量和局部变量的区别</h5><h6 id="成员变量："><a href="#成员变量：" class="headerlink" title="成员变量："></a>成员变量：</h6><p> ①成员变量定义在类中，在整个类中都可以被访问。</p><p>  ②成员变量随着对象的建立而建立，随着对象的消失而消失，存在于对象所在的堆内存中。</p><p>  ③成员变量有默认初始化值。</p><h6 id="局部变量：-1"><a href="#局部变量：-1" class="headerlink" title="局部变量："></a>局部变量：</h6><p>  ①局部变量只定义在局部范围内，如：函数内，语句内等，只在所属的区域有效。</p><p>  ②局部变量存在于栈内存中，作用的范围结束，变量空间会自动释放。</p><p>  ③局部变量没有默认初始化值</p><p> 在使用变量时需要遵循的原则为：就近原则</p><p>  首先在局部范围找，有就使用；接着在成员位置找</p><h5 id="b-成员变量和静态变量的区别"><a href="#b-成员变量和静态变量的区别" class="headerlink" title="b 成员变量和静态变量的区别"></a>b 成员变量和静态变量的区别</h5><h6 id="1、两个变量的生命周期不同"><a href="#1、两个变量的生命周期不同" class="headerlink" title="1、两个变量的生命周期不同"></a>1、两个变量的生命周期不同</h6><p>​    成员变量随着对象的创建而存在，随着对象被回收而释放。</p><p>​    静态变量随着类的加载而存在，随着类的消失而消失。****</p><h6 id="2、调用方式不同"><a href="#2、调用方式不同" class="headerlink" title="2、调用方式不同"></a>2、调用方式不同</h6><p>​    成员变量只能被对象调用。</p><p>​    静态变量可以被对象调用，还可以被类名调用。</p><h6 id="3、别名不同"><a href="#3、别名不同" class="headerlink" title="3、别名不同"></a>3、别名不同</h6><p>​    成员变量也称为实例变量。</p><p>​    静态变量也称为类变量。</p><h6 id="4、数据存储位置不同"><a href="#4、数据存储位置不同" class="headerlink" title="4、数据存储位置不同"></a>4、数据存储位置不同</h6><p>​    成员变量存储在堆内存的对象中，所以也叫对象的特有数据。</p><p>   静态变量数据存储在方法区（共享数据区）的静态区，所以也叫对象的共享数据。</p><p> [java 静态变量生命周期（类生命周期） - HF_Cherish - 博客园 (cnblogs.com)](<a href="https://www.cnblogs.com/hf-cherish/p/4970267.html#:~:text=%E5%9B%A0%E4%B8%BA%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E8%99%BD%E7%84%B6%E9%95%BF%EF%BC%88%E5%B0%B1%E6%98%AF%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%EF%BC%89%EF%BC%8C%E4%BD%86%E6%98%AF%E5%BD%93%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C%E5%AE%8C%EF%BC%8C%E4%B9%9F%E5%B0%B1%E6%98%AF%E8%AF%A5%E7%B1%BB%E7%9A%84%E6%89%80%E6%9C%89%E5%AF%B9%E8%B1%A1%E9%83%BD%E5%B7%B2%E7%BB%8F%E8%A2%AB%E5%9B%9E%E6%94%B6%EF%BC%8C%E6%88%96%E8%80%85%E5%8A%A0%E8%BD%BD%E7%B1%BB%E7%9A%84ClassLoader%E5%B7%B2%E7%BB%8F%E8%A2%AB%E5%9B%9E%E6%94%B6%EF%BC%8C%E9%82%A3%E4%B9%88%E8%AF%A5%E7%B1%BB%E5%B0%B1%E4%BC%9A%E4%BB%8Ejvm%E7%9A%84%E6%96%B9%E6%B3%95%E5%8C%BA%E5%8D%B8%E8%BD%BD%EF%BC%8C%E5%8D%B3%E7%94%9F%E5%91%BD%E6%9C%9F%E7%BB%88%E6%AD%A2%E3%80%82">https://www.cnblogs.com/hf-cherish/p/4970267.html#:~:text=因为静态变量生命周期虽然长（就是类的生命周期），但是当程序执行完，也就是该类的所有对象都已经被回收，或者加载类的ClassLoader已经被回收，那么该类就会从jvm的方法区卸载，即生命期终止。</a> 更进一步来说，static变量终究是存在jvm的内存中的，jvm下次重新运行时，肯定会清空里边上次运行的内容，包括方法区、常量区的内容。,要实现某些变量在程序多次运行时都可以读取，那么必须要将变量存下来，即存到本地文件中。 常用的数据存取格式：XML、JSON、Propertities类（类似map的键值对）等)</p><hr><h2 id="java序列化"><a href="#java序列化" class="headerlink" title="java序列化:"></a>java序列化:</h2><h3 id="一、序列化的含义、意义及使用场景："><a href="#一、序列化的含义、意义及使用场景：" class="headerlink" title="一、序列化的含义、意义及使用场景："></a>一、序列化的含义、意义及使用场景：</h3><ul><li><p>  序列化：<strong>将对象写入到IO流中</strong></p></li><li><p>  反序列化：<strong>从IO流中恢复对象</strong></p></li></ul><p> 序列化目的：</p><blockquote><p> 方便数据的传递以及存储到磁盘上（把一个Java对象写入到硬盘或者传输到网路上面的其它计算机，这时我们就需要将对象转换成字节流才能进行网络传输。对于这种通用的操作，就出现了序列化来统一这些格式）</p><p>​     简单来说序列化就是一种用来处理<strong>对象流</strong>的机制。将<strong>对象</strong>转化成<strong>字节序列</strong>后可以保存在磁盘上，或通过网络传输，以达到以后恢复成原来的对象。<strong>序列化机制使得对象可以脱离程序的运行而独立存在</strong>。</p></blockquote><p>就是说你想要你要传输对象，那么就必须转换字节码传输，传输之后想要还原到原来的样子，就必须是要进行</p><p>使用场景:</p><ul><li>所有可在网络上传输的对象都必须是可序列化的，比如RMI（remote method invoke,即远程方法调用），传入的参数或返回的对象都是可序列化的，否则会出错</li><li> 所有需要保存到磁盘的java对象都必须是可序列化的, Redis 将对象当做字符串存储的时候，如果对象实现了序列化，则只需要将对象直接存储即可（java会自动将对象转换成序列化后的字节流）</li></ul><p><strong>通常建议：程序创建的每个JavaBean类都实现Serializeable接口</strong></p><p>转载：</p><p><a href="https://www.cnblogs.com/9dragon/p/10901448.html">java序列化，看这篇就够了 - 9龙 - 博客园 (cnblogs.com)</a></p><h2 id="javaString类型"><a href="#javaString类型" class="headerlink" title="javaString类型"></a>javaString类型</h2><h4 id="关于String-不可以变："><a href="#关于String-不可以变：" class="headerlink" title="关于String 不可以变："></a>关于String 不可以变：</h4><h6 id="什么是不可变？"><a href="#什么是不可变？" class="headerlink" title="什么是不可变？"></a>什么是不可变？</h6><p>​      说String不可以变，那么到底是什么不可以变呢？ 我们可以这样认为，当创建一个对象，不改变他的状态，就是说不能改变他的成员变量，包括基本类型的值不能变，引用类型的不能指向别的对象，它的状态也不能够被改变</p><p>  例如一下状态：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="string">&quot;ABCabc&quot;</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;s = &quot;</span> + s);<span class="comment">//ABCabc</span></span><br><span class="line">s = <span class="string">&quot;123456&quot;</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;s = &quot;</span> + s);<span class="comment">//123456</span></span><br></pre></td></tr></table></figure><p>不是说不可变了吗，为什么还是变了？</p><p>  这个就要注意一下， s只是String对象的一个引用，并不是指对象本身，。对象在内存中是一个内存区，成员变量越多，内存就越大。<strong>引用只是一个四字节的地址，通过该地址可以访问到对象</strong>。所以说 s只是一个引用，它指向了对象所处的地址。代码中，s是同一引用，但是，值在不同的地址中，开始时，引用s 是“ABC”,调用同一个引用，又将s指向的地址改变成了“123456”的值</p><p><img src="https://gitee.com/jwz--jwz/cloud-img/raw/master/image/202201222320127.png" alt="image-20210819220635970"></p><hr><p>在Java中，Java并不能直接操控对象本身，所有的对象都是一个应用的指向，必须通过引用才能访问对象的本身,包括成员变量等，改变对象的成员变量，调用指针的方法等，引用和指针类似，<strong>都是存放的对象在内存中的地址，只是不能够进行指针运算</strong></p><p><img src="https://gitee.com/jwz--jwz/cloud-img/raw/master/image/202201222320043.png" alt="image-20210819225848264"></p><p><img src="C:\Users\jinweizhuo\AppData\Roaming\Typora\typora-user-images\image-20210819225902697.png" alt="image-20210819225902697"></p><p>所以说，一旦创建就不能够修改，而是重新创建一个地址，然后让该引用指向该地址的值，原来的数据并没有变化。而是重新创建了一个新的地址,改变了引用的指向</p><p><img src="https://gitee.com/jwz--jwz/cloud-img/raw/master/image/202201222321599.png" alt="image-20210820080154918">//true</p><p>上面的结果是true，因为string在创建对象是，在常量池里边，创建一个对象，会自动到常量池里面去找，如果有，改变该引用的指向，否则，重新创建一个对象</p><p>==比较的是值是不是相同，这个值分为地址值和数据的值，但它是基本数据类型时（int等 但是并没有对他进行实例化），因为那么就是比较的值，如果两个引用变量，指向同一个地址，采用== 就是ture,</p><p>equals 没有重写之前，就是和==一样</p><p>打个方，拿string做个比较就是，他重写了equals方法，两个string引用变量去比较，首先比较采用== ，比较地址值，你的地址值指向一样，那值肯定就是相等的</p><p>如果在不同的地址，那么引用地址的引用类型就需要重写了，equals来比较是否连个对象中的值相同</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object anObject)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//两个引用指向同一个地址，那么他们的值一定相等</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == anObject) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果在不同的地址之下，就要比较hash是否相同，如果hash值相同，就是说值相等，</span></span><br><span class="line">    <span class="keyword">if</span> (anObject <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">        String anotherString = (String)anObject;</span><br><span class="line">        <span class="keyword">int</span> n = value.length;</span><br><span class="line">        <span class="keyword">if</span> (n == anotherString.value.length) &#123;</span><br><span class="line">            <span class="keyword">char</span> v1[] = value;</span><br><span class="line">            <span class="keyword">char</span> v2[] = anotherString.value;</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (n-- != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (v1[i] != v2[i])</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">    <span class="meta">@org</span>.junit.<span class="function">Test</span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">IntTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">        String integer =<span class="keyword">new</span> String(<span class="string">&quot;7&quot;</span>) ;</span><br><span class="line">        change(integer);</span><br><span class="line">        User user = <span class="keyword">new</span> User(<span class="string">&quot;jin&quot;</span>);</span><br><span class="line">        user.setUserId(<span class="number">288</span>);</span><br><span class="line">        String kk = user.getUserName();</span><br><span class="line"><span class="comment">//       只要是new的对象就在方法区,就不会去常量池中寻找</span></span><br><span class="line">        String name3 =<span class="keyword">new</span> String(<span class="string">&quot;jin&quot;</span>);</span><br><span class="line">        String name= <span class="string">&quot;jin&quot;</span>;</span><br><span class="line"><span class="comment">//       引用地址值不一样，所指向的值一样，但指向不同的方法区</span></span><br><span class="line">        System.out.println(<span class="string">&quot;name3+name =&quot;</span>+(name3==name));<span class="comment">//false</span></span><br><span class="line"><span class="comment">//       == 进行的是值比较，在同一个常量池中，指向的地址一样</span></span><br><span class="line">        System.out.println(<span class="string">&quot;kk==name =&quot;</span>+(kk==name));<span class="comment">//true</span></span><br><span class="line"><span class="comment">//       同上，set方法中对象在常量池中</span></span><br><span class="line">        System.out.println(<span class="string">&quot;name==user.getUserName()=&quot;</span>+(name==user.getUserName()));<span class="comment">//true</span></span><br><span class="line">        User user1 = <span class="keyword">new</span> User();</span><br><span class="line"><span class="comment">//       user方法中初始话使用了new String</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;user1.getName1()==name=&quot;+(user1.getName1()==name));//false</span></span><br><span class="line"><span class="comment">//        user1.setName1(&quot;jin&quot;);</span></span><br><span class="line"><span class="comment">////        再次用set方法赋值时，进入常量池中</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;user1.getName1()==name=&quot;+(user1.getName1()==name));//ture</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//       基本数据类型会进行值比较</span></span><br><span class="line"><span class="comment">//        基本数据的引用类型 Integer 超过了127,就会自动装箱，创建内存地址，此时就是地址不同了</span></span><br><span class="line">        <span class="comment">//        值比较</span></span><br><span class="line">        <span class="keyword">int</span>   id=user.getUserId();</span><br><span class="line"><span class="comment">//        大于127进入堆中，地址值不一样</span></span><br><span class="line">        Integer integer1 =<span class="number">288</span>;</span><br><span class="line">        Integer integer2 = user.getUserId();</span><br><span class="line">        System.out.println(<span class="string">&quot;integer1==integer2 =&quot;</span>+(integer1==integer2));<span class="comment">//false</span></span><br><span class="line">        System.out.println(integer1 == user.getUserId());</span><br><span class="line"><span class="comment">//        超过范围自动装箱变引用，比较的就是一个地址值</span></span><br><span class="line">        System.out.println(id==user.getUserId());</span><br><span class="line">        System.out.println( user.getUserName() == name);</span><br><span class="line">        <span class="keyword">if</span> (user.getUserName().equals(name))&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;ooooooo&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(integer);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;--------------未有重写---------------------&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;1&quot;</span>+<span class="keyword">new</span> User().hashCode());</span><br><span class="line">        System.out.println(<span class="string">&quot;2&quot;</span>+<span class="keyword">new</span> User().hashCode());</span><br><span class="line">        System.out.println(<span class="string">&quot;3&quot;</span>+<span class="keyword">new</span> User().hashCode());</span><br><span class="line">        System.out.println(<span class="string">&quot;4&quot;</span>+<span class="keyword">new</span> User().hashCode());</span><br></pre></td></tr></table></figure><p><a href="https://www.zhihu.com/question/20618891">如何理解 String 类型值的不可变？ - 知乎 (zhihu.com)</a></p><h4 id="关于hashcode"><a href="#关于hashcode" class="headerlink" title="关于hashcode ():"></a>关于hashcode ():</h4><h5 id="什么是hash"><a href="#什么是hash" class="headerlink" title="什么是hash :"></a>什么是hash :</h5><p>​        <img src="https://gitee.com/jwz--jwz/cloud-img/raw/master/image/202201222321069.png" alt="image-20210820123558804"></p><ul><li><strong>不同关键字经过散列算法变换后可能得到同一个散列地址，这种现象称为碰撞</strong></li><li><strong>如果两个Hash值不同（前提是同一Hash算法），那么这两个Hash值对应的原始输入必定不同</strong></li></ul><h5 id="HashCode："><a href="#HashCode：" class="headerlink" title="HashCode："></a>HashCode：</h5><p>1、HashCode的存在主要是为了查找的快捷性，HashCode是用来在散列存储结构中确定对象的存储地址的</p><p>2、如果两个对象equals相等，那么这两个对象的HashCode一定也相同</p><p>3、如果对象的equals方法被重写，那么对象的HashCode方法也尽量重写</p><p>4、如果两个对象的HashCode相同，不代表两个对象就相同，只能说明这两个对象在散列存储结构中，存放于同一个位置</p><h5 id="HashCode有什么用"><a href="#HashCode有什么用" class="headerlink" title="HashCode有什么用"></a><strong>HashCode有什么用</strong></h5><p>回到最关键的问题，HashCode有什么用？不妨举个例子：</p><p>1、假设内存中有0 1 2 3 4 5 6 7 8这9个位置，如果我有个字段叫做ID，那么我要把这个字段存放在以上9个位置之一，如果不用HashCode而任意存放，那么当查找时就需要到8个位置中去挨个查找</p><p>2、使用HashCode则效率会快很多，把ID的HashCode % 9，然后把ID存放在取得余数的那个位置，然后每次查找该类的时候都可以通过ID的HashCode % 9求余数直接找到存放的位置了</p><p>3、如果ID的HashCode % 9算出来的位置上本身已经有数据了怎么办？这就取决于算法的实现了，比如ThreadLocal中的做法就是从算出来的位置向后查找第一个为空的位置，放置数据；HashMap的做法就是通过链式结构连起来。反正，只要保证放的时候和取的时候的算法一致就行了。</p><p>4、如果ID的HashCode % 9相等怎么办（这种对应的是第三点说的链式结构的场景）？这时候就需要定义equals了。先通过HashCode%8来判断类在哪一个位置，再通过equals来在这个位置上寻找需要的类。对比两个类的时候也差不多，先通过HashCode比较，假如HashCode相等再判断equals。<strong>如果两个类的HashCode都不相同，那么这两个类必定是不同的</strong>。</p><h6 id="举个实际的例子Set："><a href="#举个实际的例子Set：" class="headerlink" title="举个实际的例子Set："></a>举个实际的例子Set：</h6><p>我们知道Set里面的元素是不可以重复的，那么如何做到？Set是根据equals()方法来判断两个元素是否相等的。比方说Set里面已经有1000个元素了，那么第1001个元素进来的时候，最多可能调用1000次equals方法，如果equals方法写得复杂，对比的东西特别多，那么效率会大大降低。使用HashCode就不一样了，比方说HashSet，底层是基于HashMap实现的，先通过HashCode取一个模，这样一下子就固定到某个位置了，如果这个位置上没有元素，那么就可以肯定HashSet中必定没有和新添加的元素equals的元素，就可以直接存放了，都不需要比较；如果这个位置上有元素了，逐一比较，比较的时候先比较HashCode，HashCode都不同接下去都不用比了，肯定不一样，HashCode相等，再equals比较，没有相同的元素就存，有相同的元素就不存。如果原来的Set里面有相同的元素，只要HashCode的生成方式定义得好（不重复），不管Set里面原来有多少元素，只需要执行一次的equals就可以了。这样一来，实际调用equals方法的次数大大降低，提高了效率。</p><h5 id="为什么要重写hashcode"><a href="#为什么要重写hashcode" class="headerlink" title="为什么要重写hashcode"></a>为什么要重写hashcode</h5><p>[讲讲HashCode的作用 - 五月的仓颉 - 博客园 (cnblogs.com)](<a href="https://www.cnblogs.com/xrq730/p/4842028.html#:~:text=HashCode">https://www.cnblogs.com/xrq730/p/4842028.html#:~:text=HashCode</a>. 然后讲下什么是HashCode，总结几个关键点：.,1、HashCode的存在主要是为了查找的快捷性，HashCode是用来在散列存储结构中确定对象的存储地址的. 2、如果两个对象equals相等，那么这两个对象的HashCode一定也相同. 3、如果对象的equals方法被重写，那么对象的HashCode方法也尽量重写.)</p><p><a href="https://blog.csdn.net/weixin_44259720/article/details/88414828">(6条消息) 为什么重写equals()方法时，必须要求重写hashCode()方法？_IT无知君的博客-CSDN博客</a></p><p>保证成员变量都相等的情况下，他们的hashcode都相等的，重写equals方法必须尽量要重写hashCode方法的原因</p><p> <strong>1.equals()相等的两个对象他们的hashCode()肯定相等，也就是用equals()对比是绝对可靠的。</strong></p><p> <strong>2.hashCode()相等的两个对象他们的equals()不一定相等，也就是hashCode()不是绝对可靠的。</strong></p><pre><code>  所有对于需要大量并且快速的对比的话如果都用equals()去做显然效率太低，所以解决方式是，每当需要对比的时候，首先用hashCode()去对比，如果hashCode()不一样，则表示这两个对象肯定不相等（也就是不必再用equals()去再对比了）,如果hashCode()相同，此时再对比他们的equals()，如果equals()也相同，则表示这两个对象是真的相同了，这样既能大大提高了效率也保证了对比的绝对正确性！</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h = hash;<span class="comment">//默认是0</span></span><br><span class="line">    <span class="keyword">if</span> (h == <span class="number">0</span> &amp;&amp; value.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">char</span> val[] = value;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; value.length; i++) &#123;</span><br><span class="line">            h = <span class="number">31</span> * h + val[i];</span><br><span class="line">        &#125;</span><br><span class="line">        hash = h;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="java关键字"><a href="#java关键字" class="headerlink" title="java关键字"></a>java关键字</h2><h3 id="1、instanceof"><a href="#1、instanceof" class="headerlink" title="1、instanceof"></a>1、instanceof</h3><h4 id="1、instanceof用法详解："><a href="#1、instanceof用法详解：" class="headerlink" title="1、instanceof用法详解："></a>1、instanceof用法详解：</h4><p>instanceof严格上来说是一个双目运算符，用来测试一个类是否是一个类的实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> result = obj <span class="keyword">instanceof</span> Class</span><br></pre></td></tr></table></figure><ul><li>类的实例包含本身的实例，以及所有直接或间接子类的实例</li><li>instanceof左边显式声明的类型与右边操作元必须是同种类或存在继承关系，也就是说需要位于同一个继承树，否则会编译错误</li></ul><h4 id="2、instanceof用法："><a href="#2、instanceof用法：" class="headerlink" title="2、instanceof用法："></a>2、instanceof用法：</h4><ul><li>左边的实例对象不能为基本数据类型</li></ul><p><img src="https://gitee.com/jwz--jwz/cloud-img/raw/master/image/202201222321095.png" alt="image-20210811170323344"></p><ul><li>左边的实例与右边的类不在同一个继承树上</li></ul><p><img src="https://gitee.com/jwz--jwz/cloud-img/raw/master/image/202201222321781.png" alt="image-20210811170424784"></p><ul><li>obj 为 null ，跟任何类型比较时都是false</li></ul><p><img src="https://gitee.com/jwz--jwz/cloud-img/raw/master/image/202201222321577.png" alt="image-20210811171114568"></p><p><img src="https://gitee.com/jwz--jwz/cloud-img/raw/master/image/202201222321868.png" alt="image-20210811171124133"></p><ul><li><h3 id="obj-为-class-接口的实现类"><a href="#obj-为-class-接口的实现类" class="headerlink" title="obj 为 class 接口的实现类"></a>obj 为 class 接口的实现类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure><p>instanceof 运算符判断 某个对象是否是 List 接口的实现类，如果是返回 true，否则返回 false</p><p><img src="https://gitee.com/jwz--jwz/cloud-img/raw/master/image/202201222321729.png" alt="image-20210811171507254"></p><h3 id="obj-为-class-类的直接或间接子类"><a href="#obj-为-class-类的直接或间接子类" class="headerlink" title="obj 为 class 类的直接或间接子类"></a>obj 为 class 类的直接或间接子类</h3></li></ul><p><img src="https://gitee.com/jwz--jwz/cloud-img/raw/master/image/202201222321719.png" alt="image-20210811171217018"></p><h4 id="3、原理使用伪代码表示为："><a href="#3、原理使用伪代码表示为：" class="headerlink" title="3、原理使用伪代码表示为："></a>3、原理使用伪代码表示为：</h4><p><img src="https://gitee.com/jwz--jwz/cloud-img/raw/master/image/202201222321514.png" alt="image-20210811172228543"></p><p>表达式必须是null或者是引用类型，否则会返回false</p><p><strong>如果 obj 不为 null 并且 (T) obj 不抛 ClassCastException 异常则该表达式值为 true ，否则值为 false 。</strong></p><h4 id="4、应用场景："><a href="#4、应用场景：" class="headerlink" title="4、应用场景："></a>4、应用场景：</h4><p>​            对象类型强制转换：</p><p><img src="https://gitee.com/jwz--jwz/cloud-img/raw/master/image/202201222321259.png" alt="image-20210811172552838"></p><p><img src="https://gitee.com/jwz--jwz/cloud-img/raw/master/image/202201222321793.png" alt="image-20210811172603353"></p><h3 id="final关键字："><a href="#final关键字：" class="headerlink" title="final关键字："></a>final关键字：</h3><p>[浅析Java中的final关键字 - Matrix海子 - 博客园 (cnblogs.com)](<a href="https://www.cnblogs.com/dolphin0520/p/3736238.html#:~:text=%E4%B8%80.final%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95">https://www.cnblogs.com/dolphin0520/p/3736238.html#:~:text=一.final关键字的基本用法</a>. 在Java中，final关键字可以用来修饰类、方法和变量（包括成员变量和局部变量）。. 下面就从这三个方面来了解一下final关键字的基本用法。. 当用final修饰一个类时，表明这个类不能被继承。.,也就是说，如果一个类你永远不会让他被继承，就可以用final进行修饰。. final类中的成员变量可以根据需要设为final，但是要注意final类中的所有成员方法都会被隐式地指定为final方法。. 在使用final修饰类的时候，要注意谨慎选择，除非这个类真的在以后不会用来继承或者出于安全的考虑，尽量不要将类设计为final类。. 下面这段话摘自《Java编程思想》第四版第143页：.)</p><h3 id="static-关键字："><a href="#static-关键字：" class="headerlink" title="static 关键字："></a>static 关键字：</h3><h4 id="目的："><a href="#目的：" class="headerlink" title="目的："></a>目的：</h4><ul><li><p>​    当只想用一个内存区去保存一个特定的数据（无论创建多少个对象，甚至根本不用去创建对象）</p></li><li><p>​     与该类没有任何的对象的关联，即使没有创建对象，也能够调用方法</p></li></ul><h4 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h4><ul><li><p> static修饰的代码块、变量、方法内部类在类加载的期间就已经完成了初始化，存储在堆中的静态存储区，static优于对象而存在</p></li><li><p>static修饰的（变量和成员方法）被所有的对象所共享，也叫静态变量或静态方法</p></li></ul><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景:"></a>使用场景:</h4><p>static 是一个修饰符，常常用来修饰变量和方法，如在开发过程中常常static 来进行修饰，如 工具类的方法，如DateUtils,StringUtils这类的工具方法会用到static来进行修饰</p><p>static 变量</p><p>static 方法</p><p>static 代码块</p><p>static  内部类</p><p>static  包内导入</p><h5 id="static变量："><a href="#static变量：" class="headerlink" title="static变量："></a>static变量：</h5><p>随着类的加载而存在，随着类的消失而消失，当类被加载的时候，就会在Java heap中分配内存空间，静态变量被所有的 对象 进行共享，一个值改动，就会改变另一个对象的取值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> eyeNum;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> legNum = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getEyeNum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> eyeNum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setEyeNum</span><span class="params">(<span class="keyword">int</span> eyeNum)</span> </span>&#123;</span><br><span class="line">        Person.eyeNum = eyeNum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Person person = <span class="keyword">new</span> Person();</span><br><span class="line">    person.setEyeNum(<span class="number">25</span>);</span><br><span class="line"></span><br><span class="line">    Person person1 = <span class="keyword">new</span> Person();</span><br><span class="line">    person1.setEyeNum(<span class="number">28</span>);</span><br><span class="line">    System.out.println(person.getEyeNum());<span class="comment">//28</span></span><br><span class="line">    System.out.println(person1.getEyeNum());<span class="comment">//28</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> legNum = person.legNum;</span><br><span class="line">    System.out.println(legNum);<span class="comment">//2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="什么时候使用static变量"><a href="#什么时候使用static变量" class="headerlink" title="什么时候使用static变量"></a>什么时候使用static变量</h6><p>作为共享变量去使用，通过常和final关键字使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String GENERAL_MAN = <span class="string">&quot;man&quot;</span>;</span><br></pre></td></tr></table></figure><p>减少对象的创建，比如在类开头的部分，定义Logger方法，用于异常日志采集：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Logger LOGGER = LogFactory.getLoggger(MyClass.class);</span><br></pre></td></tr></table></figure><h5 id="static方法："><a href="#static方法：" class="headerlink" title="static方法："></a>static方法：</h5><ul><li><p>静态方法只能访问静态成员或静态方法</p></li><li><p>非静态方法既可以访问静态方法也可以访问非静态方</p></li></ul><h6 id="什么时候使用static方法："><a href="#什么时候使用static方法：" class="headerlink" title="什么时候使用static方法："></a>什么时候使用static方法：</h6><p>static方法一般用于与当前对象无法的工厂方法、工具方法。如Math.sqrt()，Arrays.sort()，StringUtils.isEmpty()等。</p><h5 id="static-代码块："><a href="#static-代码块：" class="headerlink" title="static 代码块："></a>static 代码块：</h5><p>static代码块在加载一个类的时候最先执行，且只执行一次。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Map&lt;String, String&gt; timeTypes;</span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">timeTypes = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    timeTypes.put(<span class="string">&quot;year&quot;</span>, <span class="string">&quot;年&quot;</span>);</span><br><span class="line">    timeTypes.put(<span class="string">&quot;quarter&quot;</span>, <span class="string">&quot;季&quot;</span>);</span><br><span class="line">    timeTypes.put(<span class="string">&quot;month&quot;</span>, <span class="string">&quot;月&quot;</span>);</span><br><span class="line">    timeTypes.put(<span class="string">&quot;day&quot;</span>, <span class="string">&quot;日&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;初始化1&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;初始化2&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JAVA集合："><a href="#JAVA集合：" class="headerlink" title="JAVA集合："></a>JAVA集合：</h2><p>​            <img src="https://gitee.com/jwz--jwz/cloud-img/raw/master/image/202201222321307.png" alt="image-20210817083225749"></p><p><img src="https://gitee.com/jwz--jwz/cloud-img/raw/master/image/202201222321124.png" alt="image-20210817083243280"></p><p><img src="https://gitee.com/jwz--jwz/cloud-img/raw/master/image/202201222321831.png" alt="image-20210818210531421"></p><h2 id="1-2-Collection-子接口"><a href="#1-2-Collection-子接口" class="headerlink" title="1.2. Collection 子接口"></a>1.2. Collection 子接口</h2><p>Collection: 是单列集合</p><h3 id="list"><a href="#list" class="headerlink" title="list:"></a>list:</h3><h4 id="1-2-1-什么是List"><a href="#1-2-1-什么是List" class="headerlink" title="1.2.1: 什么是List:"></a>1.2.1: 什么是List:</h4><p>   List: 元素是有序的(元素存取是有序)、可重复. 有序的 collection，可以对列表中每个元素的插入位置进行精确地控制。可以根据元素的整数索引（在列表中的位置）访问元素，并搜索列表中的元素。可存放重复元素，元素存取是有序的。</p><h4 id="1-2-2-List接口中常用类："><a href="#1-2-2-List接口中常用类：" class="headerlink" title="1.2.2:  List接口中常用类："></a>1.2.2:  List接口中常用类：</h4><h4 id="1-2-3-arraylist扩容"><a href="#1-2-3-arraylist扩容" class="headerlink" title="1.2.3:arraylist扩容"></a>1.2.3:arraylist扩容</h4><p><img src="https://gitee.com/jwz--jwz/cloud-img/raw/master/image/202201222321510.png" alt="image-20210818082036011"></p><p>小结： jdk7中的arrayList的对象创建的类似于单例的饿汉模式， 而jdk8中的ArrayList的对象中的类似于单例模式的懒汉式，延迟了数组的创建</p><h5 id="源码分析："><a href="#源码分析：" class="headerlink" title="源码分析："></a>源码分析：</h5><h6 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h6><p>​        jdk 1.8扩容的机制为，arrayList在初始化时没有进行初始化默认赋值，而是赋予空的数组，无参构造时使用的空数组，有参创建一个该范围的数组，在添加函数中，如果开始时，小于10.初始化为10，但最小的minCapacity 大于了 数组长度，就需要进行扩容，扩容机制为原来的1.5 倍，如果扩容之后还是比原来的数据小，那就是原来的数据 ，超过则指定为Integer的最大值，否则指定为限制容量大小，之后复制元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Default initial capacity.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="comment">//在添加过程个中，如果是空参构造默认赋值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>；</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Shared empty array instance used for empty instances.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="comment">//空实例时的共享数据默认初始</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Shared empty array instance used for default sized empty instances. We</span></span><br><span class="line"><span class="comment">     * distinguish this from EMPTY_ELEMENTDATA to know how much to inflate when</span></span><br><span class="line"><span class="comment">     * first element is added.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">     <span class="comment">//用于区分实例化时默认指定值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The array buffer into which the elements of the ArrayList are stored.</span></span><br><span class="line"><span class="comment">     * The capacity of the ArrayList is the length of this array buffer. Any</span></span><br><span class="line"><span class="comment">     * empty ArrayList with elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA</span></span><br><span class="line"><span class="comment">     * will be expanded to DEFAULT_CAPACITY when the first element is added.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//存储数据的列表</span></span><br><span class="line">    <span class="keyword">transient</span> Object[] elementData; <span class="comment">// non-private to simplify nested class access</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The size of the ArrayList (the number of elements it contains).</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@serial</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">    </span><br><span class="line"><span class="comment">//将元素添加至数组末尾</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    <span class="comment">//   给数组赋值</span></span><br><span class="line">        elementData[size++] = e;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>得到最小的扩容量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">          <span class="comment">// 获取默认的容量和传入参数的较大值，初始化值为10</span></span><br><span class="line">        minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ensureExplicitCapacity(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>判断是否需要进行扩容（如果初始值为10，那么直到添加到11 个元素才需要进行扩容）:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//判断是否需要扩容</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">       modCount++;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//如果添加元素之后，比较元素大小，判断是否需要进行扩容</span></span><br><span class="line">       <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">           <span class="comment">//调用grow方法进行扩容，调用此方法代表已经开始扩容了</span></span><br><span class="line">           grow(minCapacity);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>扩容函数grow()：</p><p>​        </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="comment">// oldCapacity为旧容量，newCapacity为新容量</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="comment">//位运算的速度远远快于整除运算，整句运算式的结果就是将新容量更新为旧容量的1.5倍，右移一位相当于除以2</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">     <span class="comment">//然后检查新容量是否大于最小需要容量，若还是小于最小需要容量，那么就把最小需要容量当作数组的新容量</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    </span><br><span class="line">   <span class="comment">// 如果新容量大于 MAX_ARRAY_SIZE,进入(执行) `hugeCapacity()` 方法来比较 minCapacity 和 MAX_ARRAY_SIZE，</span></span><br><span class="line">   <span class="comment">//如果minCapacity大于最大容量，则新容量则为`Integer.MAX_VALUE`，否则，新容量大小则为 MAX_ARRAY_SIZE 即为 `Integer.MAX_VALUE - 8`</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="LinkedList-双向链表-："><a href="#LinkedList-双向链表-：" class="headerlink" title="LinkedList(双向链表)："></a>LinkedList(双向链表)：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    E item;</span><br><span class="line">    Node&lt;E&gt; next;</span><br><span class="line">    Node&lt;E&gt; prev;</span><br><span class="line">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.item = element;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">        <span class="keyword">this</span>.prev = prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/jwz--jwz/cloud-img/raw/master/image/202201222322888.png"></p><h4 id="vector"><a href="#vector" class="headerlink" title="vector():"></a>vector():</h4><p>  扩容是原来的两倍</p><h3 id="Set接口："><a href="#Set接口：" class="headerlink" title="Set接口："></a>Set接口：</h3><h4 id="什么是set"><a href="#什么是set" class="headerlink" title="什么是set"></a>什么是set</h4><p> 存储无序的、不可重复的对象：</p><ul><li>HashSet 是set接口的典型的实例，大多数使用Set集合都是</li><li>按hash算法来存储集合中的元素，具有很好的存储、删除、查找、删除的性能</li></ul><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul><li>不能够保证元素的排列的顺序</li><li>HashSet不是线程安全的</li><li>集合的元素可以为空值</li></ul><p>判断两个元素相等的标准，通过hashcode()方法比较，并且两个对象的quals()方法也相同</p><p>相等的对象一定具有相等的散列码</p><p>​    hashset :</p><p>​               LinkedHashSet:作为HashSet的子类，遍历内部的数据是，可以按照添加的顺序遍历</p><p>​     TreeSet:可以按照添加的指定属性，进行排序</p><h3 id="hashset："><a href="#hashset：" class="headerlink" title="hashset："></a>hashset：</h3><p>线程不安全，内部是基于<strong>散列函数</strong>实现,存取速度快。它是如何保证元素唯一性的呢？依赖的是元素的hashCode方法和euqals方法。</p><p>底层是hashMap</p><p><img src="https://gitee.com/jwz--jwz/cloud-img/raw/master/image/202201222322519.png" alt="image-20210818215627841"></p><p>先进行hash值比较，在进行equals比较</p><p><img src="https://gitee.com/jwz--jwz/cloud-img/raw/master/image/202201222322632.png" alt="image-20210818215733459"></p><p>hashcode:</p><p><img src="https://gitee.com/jwz--jwz/cloud-img/raw/master/image/202201222322579.png" alt="image-20210818221115967"></p><p><img src="https://gitee.com/jwz--jwz/cloud-img/raw/master/image/202201222322662.png" alt="image-20210818221238854"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">(Object a[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Object element : a)</span><br><span class="line">        result = <span class="number">31</span> * result + (element == <span class="keyword">null</span> ? <span class="number">0</span> : element.hashCode());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="treeSet"><a href="#treeSet" class="headerlink" title="treeSet:"></a>treeSet:</h3><p>​             按照对象的不同属性进行排序</p><p>​             两种排序：自然排序，定制排序</p><p>​            重写排序之后，如果你直接添加元素，会进行自动排序，下面是二级排序，如果有一个属性相同，就不会插入，因为是一个树形结构</p><p><img src="https://gitee.com/jwz--jwz/cloud-img/raw/master/image/202201222322996.png" alt="image-20210818221954348"></p><p><img src="https://gitee.com/jwz--jwz/cloud-img/raw/master/image/202201222322407.png" alt="image-20210818222237587"></p><h3 id="Map接口："><a href="#Map接口：" class="headerlink" title="Map接口："></a>Map接口：</h3><h4 id="hashMap"><a href="#hashMap" class="headerlink" title="hashMap:"></a>hashMap:</h4><p>工作原理</p><p>  jdk7  调用hashcode()计算key1的hash 值，此哈希值相同经过算法计算以后，</p><p>HashMap 在map。entry静态内部类实现中存储key-value,时，HashMap使用哈希算法，当我们使用key时候，通过调用hashcode()和hash算法，先找出索引，如果不一样，添加成功，否者</p><p>，找到同一个桶之后，使用quals检验值是否存在，如果存在，会覆盖value,如果不存在，会创建一个新的entry(包括属性有;key ,value,next) 属性。默认扩容为原来的两倍</p><p><img src="https://gitee.com/jwz--jwz/cloud-img/raw/master/image/202201222322911.png"></p><p>jdk 相较于jdk7在底层实现的方面的不同：</p><p>1、new HashMap()：底层没有创建一个长度为16 的数组</p><p>2、jdk 8 底层是 Node[] 不是entry</p><p>3、首次调用put 方法时，底层创建长度为16的数组</p><p>4、jdk7底层结构数组链表，jdk8 中的底层：数组+链表+红黑树</p><p>为了避免链表过长，查询速度变为了线性，      当数组上的某一索引元素以链表的形式存在的数据个数大于&gt;8 ,且当前的长度&gt;64 此时索引的位置上的说有数据改为红黑树</p><p><img src="https://gitee.com/jwz--jwz/cloud-img/raw/master/image/202201222322480.png" alt="image-20210819090458603"></p><h4 id="对HashMap中put-get方法的认识？"><a href="#对HashMap中put-get方法的认识？" class="headerlink" title="对HashMap中put/get方法的认识？"></a>对HashMap中put/get方法的认识？</h4><h4 id="HashMa"><a href="#HashMa" class="headerlink" title="HashMa"></a>HashMa</h4><p><img src="https://gitee.com/jwz--jwz/cloud-img/raw/master/image/202201222322221.png" alt="image-20210820200517223"></p><h3 id="jdk8"><a href="#jdk8" class="headerlink" title="jdk8:"></a>jdk8:</h3><p> 底层存储数据使用的是node:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//    </span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">        <span class="keyword">final</span> K key;</span><br><span class="line">        V value;</span><br><span class="line">        Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">        Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">            <span class="keyword">this</span>.hash = hash;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="put方法："><a href="#put方法：" class="headerlink" title="put方法："></a>put方法：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        <span class="comment">//首次初始化数组</span></span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">         <span class="comment">//找到当前数组的元素值</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="resize"><a href="#resize" class="headerlink" title="resize:"></a>resize:</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="LinkedHashMap的底层原理（待完成）："><a href="#LinkedHashMap的底层原理（待完成）：" class="headerlink" title="LinkedHashMap的底层原理（待完成）："></a>LinkedHashMap的底层原理（待完成）：</h4><h3 id="map常用方法："><a href="#map常用方法：" class="headerlink" title="map常用方法："></a>map常用方法：</h3><p><img src="https://gitee.com/jwz--jwz/cloud-img/raw/master/image/202201222322198.png" alt="image-20210820203510349"></p><h3 id="1-1-3-集合框架底层数据结构总结"><a href="#1-1-3-集合框架底层数据结构总结" class="headerlink" title="1.1.3. 集合框架底层数据结构总结"></a>1.1.3. 集合框架底层数据结构总结</h3><h4 id="1-1-3-1-List"><a href="#1-1-3-1-List" class="headerlink" title="1.1.3.1. List"></a>1.1.3.1. List</h4><ul><li><code>Arraylist</code>： <code>Object[]</code> 数组         线程不安全，查询速度快。底层数据结构是数组结构 底层使用<code>Object[ ]</code> 存储 </li><li><code>Vector</code>：<code>Object[]</code> 数组  线程安全，但速度慢，已被ArrayList替代</li><li><code>LinkedList</code>： 双向链表(JDK1.6 之前为循环链表，JDK1.7 取消了循环,线程不安全。增删速度快。底层数据结构是<strong>链表结构</strong></li></ul><h4 id="1-1-3-2-Set"><a href="#1-1-3-2-Set" class="headerlink" title="1.1.3.2. Set"></a>1.1.3.2. Set</h4><ul><li><code>HashSet</code>(无序，唯一): 基于 <code>HashMap</code> 实现的，底层采用 <code>HashMap</code> 来保存元素</li><li><code>LinkedHashSet</code>: <code>LinkedHashSet</code> 是 <code>HashSet</code> 的子类，并且其内部是通过 <code>LinkedHashMap</code> 来实现的。有点类似于我们之前说的 <code>LinkedHashMap</code> 其内部是基于 <code>HashMap</code> 实现一样，不过还是有一点点区别的</li><li><code>TreeSet</code>(有序，唯一): 红黑树(自平衡的排序二叉树)</li></ul><h4 id="1-1-3-3-Queue"><a href="#1-1-3-3-Queue" class="headerlink" title="1.1.3.3 Queue"></a>1.1.3.3 Queue</h4><ul><li><code>PriorityQueue</code>: <code>Object[]</code> 数组来实现二叉堆</li><li><code>ArrayQueue</code>: <code>Object[]</code> 数组 + 双指针</li></ul><p>再来看看 <code>Map</code> 接口下面的集合。</p><h4 id="1-1-3-4-Map"><a href="#1-1-3-4-Map" class="headerlink" title="1.1.3.4. Map"></a>1.1.3.4. Map</h4><ul><li><code>HashMap</code>： JDK1.8 之前 <code>HashMap</code> 由数组+链表组成的，数组是 <code>HashMap</code> 的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）。JDK1.8 以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间</li><li><code>LinkedHashMap</code>： <code>LinkedHashMap</code> 继承自 <code>HashMap</code>，所以它的底层仍然是基于拉链式散列结构即由数组和链表或红黑树组成。另外，<code>LinkedHashMap</code> 在上面结构的基础上，增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。详细可以查看：<a href="https://www.imooc.com/article/22931">《LinkedHashMap 源码详细分析（JDK1.8）》</a></li><li><code>Hashtable</code>： 数组+链表组成的，数组是 <code>Hashtable</code> 的主体，链表则是主要为了解决哈希冲突而存在的</li><li><code>TreeMap</code>： 红黑树（自平衡的排序二叉树）</li></ul><h3 id="1-1-2-说说-List-Set-Queue-Map-四者的区别？"><a href="#1-1-2-说说-List-Set-Queue-Map-四者的区别？" class="headerlink" title="1.1.2. 说说 List, Set, Queue, Map 四者的区别？"></a>1.1.2. 说说 List, Set, Queue, Map 四者的区别？</h3><ul><li><code>List</code>(对付顺序的好帮手): 存储的元素是有序的、可重复的。</li><li><code>Set</code>(注重独一无二的性质): 存储的元素是无序的、不可重复的。</li><li><code>Queue</code>(实现排队功能的叫号机): 按特定的排队规则来确定先后顺序，存储的元素是有序的、可重复的。</li><li><code>Map</code>(用 key 来搜索的专家): 使用键值对（key-value）存储，类似于数学上的函数 y=f(x)，”x” 代表 key，”y” 代表 value，key 是无序的、不可重复的，value 是无序的、可重复的，每个键最多映射到一个值。</li></ul><h3 id="1-2-1-Arraylist-和-Vector-的区别"><a href="#1-2-1-Arraylist-和-Vector-的区别" class="headerlink" title="1.2.1. Arraylist 和 Vector 的区别?"></a>1.2.1. Arraylist 和 Vector 的区别?</h3><ul><li><code>ArrayList</code> 是 <code>List</code> 的主要实现类，底层使用 <code>Object[ ]</code>存储，适用于频繁的查找工作，效率高   线程不安全 ,；</li><li><code>Vector</code> 是 <code>List</code> 的古老实现类，底层使用<code>Object[ ]</code> 存储，使用synchronized效率低线程安全的。</li></ul><h3 id="1-2-2-Arraylist-与-LinkedList-区别"><a href="#1-2-2-Arraylist-与-LinkedList-区别" class="headerlink" title="1.2.2. Arraylist 与 LinkedList 区别?"></a>1.2.2. Arraylist 与 LinkedList 区别?</h3><ol><li><strong>是否保证线程安全：</strong> <code>ArrayList</code> 和 <code>LinkedList</code> 都是不同步的，也就是不保证线程安全；</li><li><strong>底层数据结构：</strong> <code>Arraylist</code> 底层使用的是 <strong><code>Object</code> 数组</strong>；<code>LinkedList</code> 底层使用的是 <strong>双向链表</strong> 数据结构（JDK1.6 之前为循环链表，JDK1.7 取消了循环。注意双向链表和双向循环链表的区别，下面有介绍到！）</li><li>插入和删除是否受元素位置的影响：<ul><li><code>ArrayList</code> 采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响。 比如：执行<code>add(E e)</code>方法的时候， <code>ArrayList</code> 会默认在将指定的元素追加到此列表的末尾，这种情况时间复杂度就是 O(1)。但是如果要在指定位置 i 插入和删除元素的话（<code>add(int index, E element)</code>）时间复杂度就为 O(n-i)。因为在进行上述操作的时候集合中第 i 和第 i 个元素之后的(n-i)个元素都要执行向后位/向前移一位的操作。</li><li><code>LinkedList</code> 采用链表存储，所以，如果是在头尾插入或者删除元素不受元素位置的影响（<code>add(E e)</code>、<code>addFirst(E e)</code>、<code>addLast(E e)</code>、<code>removeFirst()</code> 、 <code>removeLast()</code>），近似 O(1)，如果是要在指定位置 <code>i</code> 插入和删除元素的话（<code>add(int index, E element)</code>，<code>remove(Object o)</code>） 时间复杂度近似为 O(n) ，因为需要先移动到指定位置再插入。</li></ul></li><li><strong>是否支持快速随机访问：</strong> <code>LinkedList</code> 不支持高效的随机元素访问，而 <code>ArrayList</code> 支持。快速随机访问就是通过元素的序号快速获取元素对象(对应于<code>get(int index)</code>方法)。</li><li><strong>内存空间占用：</strong> ArrayList 的空 间浪费主要体现在在 list 列表的结尾会预留一定的容量空间，而 LinkedList 的空间花费则体现在它的每一个元素都需要消耗比 ArrayList 更多的空间（因为要存放直接后继和直接前驱以及数据）。</li></ol><h3 id="1-2-2-负载因子值的大小，对HashMap有什么影响？"><a href="#1-2-2-负载因子值的大小，对HashMap有什么影响？" class="headerlink" title="1.2.2. 负载因子值的大小，对HashMap有什么影响？"></a>1.2.2. 负载因子值的大小，对HashMap有什么影响？</h3><p>​       负载因子的大小决定了HashMap的数据密度</p><p>​       负载因子越大密度越大，发生碰撞的几率越高，数组中的链表越容易长，造成查询或插入时的比较次数也越小，性能会更高，但是会浪费一定的内容空间。而且经常扩容会影响性能建议初始化预设大一点的空间</p><p>​        按照其他语言的参考及研究，会考虑将负载因子设置为0.7~0.75，此时平均检索长度接近于常数</p><p>​        </p><h2 id="Collections常用方法："><a href="#Collections常用方法：" class="headerlink" title="Collections常用方法："></a>Collections常用方法：</h2><h3 id="Collections-工具类常用方法"><a href="#Collections-工具类常用方法" class="headerlink" title="Collections 工具类常用方法:"></a>Collections 工具类常用方法:</h3><ol><li>排序</li><li>查找,替换操作</li><li>同步控制(不推荐，需要线程安全的集合类型时请考虑使用 JUC 包下的并发集合)</li></ol><h4 id="查找-替换操作"><a href="#查找-替换操作" class="headerlink" title="查找,替换操作"></a>查找,替换操作</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverse</span><span class="params">(List)</span>:反转List中元素的顺序</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">shuffle</span><span class="params">(List)</span>:对List集合元素进行随机排序</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(List)</span>:根据元素的自然顺序对指定List集合元素按升序排序</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(List，Comparator)</span>:根据指定的Comparator产生的顺序对List集合元素进行排序</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(List，<span class="keyword">int</span>，<span class="keyword">int</span>)</span>:将指定list集合中的i处元素和j处元素进行交换</span></span><br></pre></td></tr></table></figure><h4 id="查找替换操作："><a href="#查找替换操作：" class="headerlink" title="查找替换操作："></a>查找替换操作：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(List list, Object key)</span><span class="comment">//对List进行二分查找，返回索引，注意List必须是有序的</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(Collection coll)</span><span class="comment">//根据元素的自然顺序，返回最大的元素。 类比int min(Collection coll)</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(Collection coll, Comparator c)</span><span class="comment">//根据定制排序，返回最大元素，排序规则由Comparatator类控制。类比int min(Collection coll, Comparator c)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fill</span><span class="params">(List list, Object obj)</span><span class="comment">//用指定的元素代替指定list中的所有元素</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">frequency</span><span class="params">(Collection c, Object o)</span><span class="comment">//统计元素出现次数</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">indexOfSubList</span><span class="params">(List list, List target)</span><span class="comment">//统计target在list中第一次出现的索引，找不到则返回-1，类比int lastIndexOfSubList(List source, list target)</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">replaceAll</span><span class="params">(List list, Object oldVal, Object newVal)</span><span class="comment">//用新元素替换旧元素</span></span></span><br><span class="line"><span class="function">   <span class="keyword">void</span> <span class="title">copy</span><span class="params">(List dest,Lsit src)</span>:将src的内容复制到dest中</span></span><br></pre></td></tr></table></figure><h3 id="同步控制"><a href="#同步控制" class="headerlink" title="同步控制:"></a>同步控制:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Collections 提供了多个synchronizedXxx()方法·，该方法可以将指定集合包装成线程同步的集合，从而解决多线程并发访问集合时的线程安全问题。</span><br><span class="line"></span><br><span class="line">我们知道 HashSet，TreeSet，ArrayList,LinkedList,HashMap,TreeMap 都是线程不安全的。Collections 提供了多个静态方法可以把他们包装成线程同步的集合。</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">synchronizedCollection(Collection&lt;T&gt;  c) <span class="comment">//返回指定 collection 支持的同步（线程安全的）collection。</span></span><br><span class="line">synchronizedList(List&lt;T&gt; list)<span class="comment">//返回指定列表支持的同步（线程安全的）List。</span></span><br><span class="line">synchronizedMap(Map&lt;K,V&gt; m) <span class="comment">//返回由指定映射支持的同步（线程安全的）Map。</span></span><br><span class="line">synchronizedSet(Set&lt;T&gt; s) <span class="comment">//返回指定 set 支持的同步（线程安全的）set。</span></span><br></pre></td></tr></table></figure><h2 id="枚举类和注解："><a href="#枚举类和注解：" class="headerlink" title="枚举类和注解："></a>枚举类和注解：</h2><h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>类的对象只有有限个，确定的</p><p>当需要进行定义一组常量时，强烈建议使用枚举类：</p><p>如何自定义枚举：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//类的对象只有有限个,确定的</span><br><span class="line">//当需要进行定义一组常量时，强烈建议使用枚举类</span><br><span class="line">//如果枚举类中只有一个对象，可以作为单例模式的实现方式</span><br></pre></td></tr></table></figure><h4 id="如何使用关键字enum定义枚举类"><a href="#如何使用关键字enum定义枚举类" class="headerlink" title="如何使用关键字enum定义枚举类;"></a>如何使用关键字enum定义枚举类;</h4><h5 id="使用关键字："><a href="#使用关键字：" class="headerlink" title="使用关键字："></a>使用关键字：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类的对象只有有限个,确定的</span></span><br><span class="line"><span class="comment">//当需要进行定义一组常量时，强烈建议使用枚举类</span></span><br><span class="line"><span class="comment">//如果枚举类中只有一个对象，可以作为单例模式的实现方式</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">TestByEnum</span> </span>&#123;</span><br><span class="line">    SYS_CONFIG(<span class="string">&quot;系统配置&quot;</span>,<span class="string">&quot;sys_config&quot;</span>),</span><br><span class="line">    ADMIN_LOGIN(<span class="string">&quot;后台登录&quot;</span>,<span class="string">&quot;admin_login&quot;</span>),</span><br><span class="line">    ADMIN_UI(<span class="string">&quot;后台样式&quot;</span>,<span class="string">&quot;admin_ui&quot;</span>),</span><br><span class="line">    WECHAT_DEV(<span class="string">&quot;微信开发&quot;</span>,<span class="string">&quot;wechat_dev&quot;</span>);</span><br><span class="line">    <span class="keyword">private</span> String text;</span><br><span class="line">    <span class="keyword">private</span> String value;</span><br><span class="line"><span class="comment">//    定义你的常量的类型</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">TestByEnum</span><span class="params">(String text,String value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.text=text;</span><br><span class="line">        <span class="keyword">this</span>.value=value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getText</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> text;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setText</span><span class="params">(String text)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.text = text;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(String value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;TestByEnum&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;text=&#x27;&quot;</span> + text + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, value=&#x27;&quot;</span> + value + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h6 id="test"><a href="#test" class="headerlink" title="test:"></a>test:</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title">TestEnum</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(Enum.Spring.toString());</span><br><span class="line">        TestByEnum[] values = TestByEnum.values();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; values.length; i++) &#123;</span><br><span class="line">            System.out.println(values[i].getValue());</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    使用关键字来进行定义</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="使用自定义："><a href="#使用自定义：" class="headerlink" title="使用自定义："></a>使用自定义：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> wz.TestEnum;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Enum</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    方式一： jdk5.0 自定义枚举类</span></span><br><span class="line"><span class="comment">//    方式二，可以使用enum关键字定义枚举类</span></span><br><span class="line"><span class="comment">//    自定义枚举类</span></span><br><span class="line"></span><br><span class="line">     <span class="keyword">private</span>  <span class="keyword">final</span>  String seasonName;</span><br><span class="line">     <span class="keyword">private</span>  <span class="keyword">final</span>  String seasonDesc;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Enum</span><span class="params">(String seasonName,String seasonDesc)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.seasonName = seasonName;</span><br><span class="line">        <span class="keyword">this</span>.seasonDesc = seasonDesc;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//   提供当前枚举类的多个对象</span></span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">final</span> Enum Spring = <span class="keyword">new</span> Enum(<span class="string">&quot;春天&quot;</span>,<span class="string">&quot;sss&quot;</span>);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getSeasonName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> seasonName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getSeasonDesc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> seasonDesc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Enum&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;seasonName=&#x27;&quot;</span> + seasonName + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, seasonDesc=&#x27;&quot;</span> + seasonDesc + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="注解："><a href="#注解：" class="headerlink" title="注解："></a>注解：</h3><p>●注解(Annotation)概述·</p><p>​    jdk5.0 开始</p><blockquote><p>Annotation其实就是代码里的特殊标记,这些标记可以在编译,类加载,运行时被读取,并执行相应的处理。通过使用Annotation,程序员可以在不改变原有逻辑的情况下,在源文件中嵌入一些补充信息。代码分析工具、开发工具和部署工具可以通过这些补充信息进行验证或者进行部署。</p><p>Annotation可以像修饰符一样被使用,可用于修饰包,类,构造器,方法,成员变量,参数,局部变量的声明,这些信息被保存在Annotation的“name=value”对中。</p></blockquote><p>框架 =注解+ 反射+设计模式</p><p>●自定义AnnotationJDK中的元注解</p><p>自定义注解通常都会指明两个元注解：retention、target</p><ul><li>利用反射获取注解信息（在反射部分涉及)</li></ul><p>●JDK 8中注解的新特性</p><h3 id="元数据"><a href="#元数据" class="headerlink" title="元数据"></a>元数据</h3><h5 id="retention"><a href="#retention" class="headerlink" title="@retention:"></a>@retention:</h5><h4 id="指定所修饰的annotation的生命周期：source-class-只有声明为runtime-生命周期的注解，才能通过反射"><a href="#指定所修饰的annotation的生命周期：source-class-只有声明为runtime-生命周期的注解，才能通过反射" class="headerlink" title="指定所修饰的annotation的生命周期：source\class,只有声明为runtime 生命周期的注解，才能通过反射"></a>指定所修饰的annotation的生命周期：source\class,只有声明为runtime 生命周期的注解，才能通过反射</h4><h5 id="target"><a href="#target" class="headerlink" title="@target:"></a>@target:</h5><p>   用于指定被修饰的Annotation能用于修饰哪些程序元素</p><p><img src="https://gitee.com/jwz--jwz/cloud-img/raw/master/image/202201222322463.png" alt="image-20210821200035996"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">ElementType</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** Class, interface (including annotation type), or enum declaration */</span></span><br><span class="line">    TYPE,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Field declaration (includes enum constants) */</span></span><br><span class="line">   <span class="comment">//属性</span></span><br><span class="line">    FIELD,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Method declaration */</span></span><br><span class="line">   <span class="comment">//方法</span></span><br><span class="line">    METHOD,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Formal parameter declaration */</span></span><br><span class="line">    <span class="comment">//私有的</span></span><br><span class="line">    PARAMETER,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Constructor declaration */</span></span><br><span class="line">    <span class="comment">//构造函数</span></span><br><span class="line">    CONSTRUCTOR,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Local variable declaration */</span></span><br><span class="line">    <span class="comment">//本地变量</span></span><br><span class="line">    LOCAL_VARIABLE,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Annotation type declaration */</span></span><br><span class="line">    <span class="comment">//注释类型</span></span><br><span class="line">    ANNOTATION_TYPE,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Package declaration */</span></span><br><span class="line">    <span class="comment">//包注解</span></span><br><span class="line">    PACKAGE,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Type parameter declaration</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 1.8</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//类型注解，表示该注解能够写在类型变量的声明语句中（如：泛型的声明</span></span><br><span class="line">    TYPE_PARAMETER,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Use of a type</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 1.8</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//该注解能够写在使用类型的任何语句之中</span></span><br><span class="line">    TYPE_USE</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/jwz--jwz/cloud-img/raw/master/image/202201222322713.png" alt="image-20210822094532788"></p><h5 id="Documented"><a href="#Documented" class="headerlink" title="@Documented:"></a>@Documented:</h5><p>用于指定被该元Annotation修饰的Annotation类将被javadoc工具提取成文档。默认情况下，javadoc是不包括注解的。&gt;定义为Documented的注解必须设置Retention值为RUNTIME。</p><h5 id="inherited"><a href="#inherited" class="headerlink" title="@inherited"></a>@inherited</h5><p> 修饰的Annotation将具有继承性，如果某个类使用了被该注解修饰的Annotion，那么其子类将自动具有该注解</p><blockquote><p>比如:如果把标有@Inherited注解的自定义的注解标注在类级别上，子类则可以继承父类类级别的注解</p></blockquote><h3 id="利用反射获取信息："><a href="#利用反射获取信息：" class="headerlink" title="利用反射获取信息："></a>利用反射获取信息：</h3><p>当一个Annotation类型被定义为运行时annotation后，该注解才是运行时可见，当class文件被载入时保存在class 文件中Annotation 才会被虚拟机读取</p><p>程序可以调用annotateElement对象来访问Annotation的信息</p><h3 id="jdk8中的新注解："><a href="#jdk8中的新注解：" class="headerlink" title="jdk8中的新注解："></a>jdk8中的新注解：</h3><h4 id="可重复注解："><a href="#可重复注解：" class="headerlink" title="可重复注解："></a>可重复注解：</h4><p>  1、在MyAnnotation上面声明@Repeatable,与成员值进行绑定 MyAnnotation.class</p><p><img src="C:\Users\jinweizhuo\AppData\Roaming\Typora\typora-user-images\image-20210822092853742.png" alt="image-20210822092853742"><img src="C:\Users\jinweizhuo\AppData\Roaming\Typora\typora-user-images\image-20210822093742882.png" alt="image-20210822093742882"></p><h4 id="类型注解："><a href="#类型注解：" class="headerlink" title="类型注解："></a>类型注解：</h4><p>​             <img src="https://gitee.com/jwz--jwz/cloud-img/raw/master/image/202201222323239.png" alt="image-20210822093246408"></p><p>注解样例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.jfinal.plugin.ehcache;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Documented;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.ElementType;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Inherited;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.RetentionPolicy;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * CacheName can configure CacheInterceptor&#x27;s cache name or EvictInterceptor&#x27;s evict cache name.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * The order of CacheInterceptor searching for CacheName annotation:&lt;br&gt;</span></span><br><span class="line"><span class="comment"> * 1: Action method of current invocation&lt;br&gt;</span></span><br><span class="line"><span class="comment"> * 2: Controller of the current invocation&lt;br&gt;</span></span><br><span class="line"><span class="comment"> * CacheInterceptor will use the actionKey as the cache name If the CacheName annotation not found. </span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> * CacheName可以配置CacheInterceptor的缓存名或victinterceptor的evict缓存名。</span></span><br><span class="line"><span class="comment">* &lt; p &gt;</span></span><br><span class="line"><span class="comment">* CacheInterceptor搜索CacheName注释的顺序:&lt;br&gt;</span></span><br><span class="line"><span class="comment">* 1:当前调用的动作方法&lt;br&gt;</span></span><br><span class="line"><span class="comment">2:当前调用的控制器&lt;br&gt;</span></span><br><span class="line"><span class="comment">*如果没有找到CacheName注释，CacheInterceptor会使用actionKey作为缓存名。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Inherited</span>  <span class="comment">//被修饰的注解将具备继承性</span></span><br><span class="line"><span class="meta">@Documented</span>  <span class="comment">//表示修饰的注解将被Javadoc解析时保留下来</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span><span class="comment">//指定修饰的生命周期</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)</span><span class="comment">//指定修饰的类型，适合哪个</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> CacheName &#123;</span><br><span class="line"><span class="function">String <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="泛型："><a href="#泛型：" class="headerlink" title="泛型："></a>泛型：</h2><h3 id="1-1为什么要有泛型（Generic）："><a href="#1-1为什么要有泛型（Generic）：" class="headerlink" title="1.1为什么要有泛型（Generic）："></a>1.1为什么要有泛型（Generic）：</h3><p>​         在jdk1.5之前只能把元素类型设计为Object,把元素的类型设计成一个参数，从而达到能够对不同的对象进行重用</p><p>  所谓泛型：就是允许在定义类中、接口时通过一个标识符表示某个属性的类型或者某个方法的返回值以及参数类型 。这个类型将在使用时确定（例如： 继承或者实习这个接口用这个声明变量、创建对象）确定（传入实际的参数，也称为类型的参数）</p><p><img src="https://gitee.com/jwz--jwz/cloud-img/raw/master/image/202201222323721.png" alt="image-20210822113013534"></p><p><img src="https://gitee.com/jwz--jwz/cloud-img/raw/master/image/202201222323345.png" alt="image-20210822113221451"></p><p>如果没有使用泛型在取出时就会有问题</p><p><img src="https://gitee.com/jwz--jwz/cloud-img/raw/master/image/202201222323948.png" alt="image-20210822113354241"></p><p><img src="https://gitee.com/jwz--jwz/cloud-img/raw/master/image/202201222323470.png" alt="image-20210822113645205"></p><p>使用的时候只需要指定你要的什么类型，然后在进行使用</p><p><strong><img src="https://gitee.com/jwz--jwz/cloud-img/raw/master/image/202201222323769.png" alt="image-20210822171725315"></strong></p><h3 id="泛型嵌套："><a href="#泛型嵌套：" class="headerlink" title="泛型嵌套："></a>泛型嵌套：</h3><p><img src="https://gitee.com/jwz--jwz/cloud-img/raw/master/image/202201222323303.png" alt="image-20210823090328643"></p><h3 id="通配符的使用："><a href="#通配符的使用：" class="headerlink" title="通配符的使用："></a>通配符的使用：</h3><p>1、使用类型通配符：类型变量的限定 ,能够对指定的进行限制</p><p>   List&lt;? extends Object&gt;  其父类必须是Object  </p><p>对于List&lt;?&gt;不能够向其内部添加数据</p><p>//获取（读取）：允许读取数据，读取的数据为Object 类型</p><hr><p><img src="https://gitee.com/jwz--jwz/cloud-img/raw/master/image/202201222323199.png" alt="image-20210823081616708"></p><h4 id="通配符指定上限："><a href="#通配符指定上限：" class="headerlink" title="通配符指定上限："></a>通配符指定上限：</h4><h6 id="上限extends"><a href="#上限extends" class="headerlink" title="上限extends:"></a>上限extends:</h6><p>使用时指定的类型必须继承某个类，或者实现某个接口</p><h4 id="通配符指定下限："><a href="#通配符指定下限：" class="headerlink" title="通配符指定下限："></a>通配符指定下限：</h4><h6 id="下限super-s"><a href="#下限super-s" class="headerlink" title="下限super:s"></a>下限super:s</h6><p>使用时指定的类型不能小于操作的类</p> <? extends Number>(无穷小，Number)​       只允许泛型为Number及Number子类的引用<? super Number>​       只允许泛型为Number及Number父类的引用<? extends Comparable>​      只允许泛型为实现Comparaable接口的实现类的引用​       便于提取出 泛型的数据:​     首先人的信息进行封装 ，能够给指定的人显示所需要显示的信息![image-20210823090544107](https://gitee.com/jwz--jwz/cloud-img/raw/master/image/202201222323881.png)![image-20210823090552698](https://gitee.com/jwz--jwz/cloud-img/raw/master/image/202201222323338.png)![1573457377345671.png](https://gitee.com/jwz--jwz/cloud-img/raw/master/image/202201222323921.png)<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这个只能传递T类型的数据</span></span><br><span class="line"><span class="comment">     * 返回值 就是Demo&lt;T&gt; 实例化传递的对象类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> T <span class="title">getListFisrt</span><span class="params">(List&lt;T&gt; data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (data == <span class="keyword">null</span> || data.size() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> data.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这个&lt;T&gt; T 可以传入任何类型的List</span></span><br><span class="line"><span class="comment">     * 参数T</span></span><br><span class="line"><span class="comment">     *     第一个 表示是泛型</span></span><br><span class="line"><span class="comment">     *     第二个 表示返回的是T类型的数据</span></span><br><span class="line"><span class="comment">     *     第三个 限制参数类型为T</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> &lt;T&gt; <span class="function">T <span class="title">getListFisrt</span><span class="params">(List&lt;T&gt; data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (data == <span class="keyword">null</span> || data.size() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> data.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>例如:<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//    将对象转换为字符串  Object--&gt;String</span></span><br><span class="line">&lt;T&gt; 声明泛型 返回值为string 传入值为 T型</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span>  &lt;T&gt; <span class="function">String <span class="title">obj2String</span><span class="params">(T src)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (src == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>  <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//            判断src是否为String,如果是,强转为string  如果不是调用jackson方法转换</span></span><br><span class="line">        <span class="keyword">return</span>  src <span class="keyword">instanceof</span> String ? (String) src: objectMapper.writeValueAsString(src);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">           <span class="keyword">return</span>  <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//      String --&gt; Object</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">string2Obj</span><span class="params">(String  src , TypeReference&lt;T&gt; typeReference)</span></span>&#123;</span><br><span class="line"><span class="comment">//        将string转换为为我们所需要的对象</span></span><br><span class="line">        <span class="keyword">if</span> (src == <span class="keyword">null</span>|| typeReference == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>  <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span>  (T)(typeReference.getType().equals(String.class)? src:objectMapper.readValue(src,typeReference));</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception exception)&#123;</span><br><span class="line">            exception.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>## 设计模式：创建型模式：工厂方法模式、抽象工厂模式、单例模式、建造者模式结构型模式： 适配器模式、装饰器模式、代理模式、外观模式、组合模式、享乐行为模式：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式状态模式、访问者模式、中介者模式、解释器模式####  单例模式：所谓类的单例设计模式，就是采取一定的方法保证在整个的软件系统中，对某个类只能存在一个对象实例，并且该类只提供一个取得其对象实例的方法。如果我们要让类在一个虚拟机中只能产生一个对象，我们首先必须将类的构造器的访问权限设置为private，这样，就不能用new操作符在类的外部产生类的对象了，但在类内部仍可以产生该类的对象。因为在类的外部开始还无法得到类的对象，只能调用该类的某个静态方法以返回类内部创建的对象，静态方法只能访问类中的静态成员变量，所以，指向类内部产生的该类对象的变量也必须定义成静态的。让天不漫奇心学的技太#####  懒汉式和饿汉式懒汉式：- 延迟去创建对象- 线程不安全饿汉式： - 坏处：对象的加载时间过长，一开始就加载-  好处：线程是安全的应用：- 网站的计数器;- 应用程序的日志文件<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Slf4jLogFilter slf4jLogFilter = <span class="keyword">new</span> Slf4jLogFilter();</span><br><span class="line">slf4jLogFilter.setConnectionLogEnabled(<span class="keyword">false</span>);</span><br><span class="line">slf4jLogFilter.setResultSetLogEnabled(<span class="keyword">false</span>);</span><br><span class="line">slf4jLogFilter.setStatementParameterSetLogEnabled(<span class="keyword">false</span>);</span><br><span class="line">slf4jLogFilter.setConnectionLogEnabled(<span class="keyword">false</span>);</span><br><span class="line">slf4jLogFilter.setResultSetCloseAfterLogEnabled(<span class="keyword">false</span>);</span><br><span class="line">slf4jLogFilter.setConnectionCloseAfterLogEnabled(<span class="keyword">false</span>);</span><br><span class="line">slf4jLogFilter.setStatementParameterClearLogEnable(<span class="keyword">false</span>);</span><br><span class="line">slf4jLogFilter.setStatementPrepareAfterLogEnabled(<span class="keyword">false</span>);</span><br><span class="line">slf4jLogFilter.setStatementPrepareCallAfterLogEnabled(<span class="keyword">false</span>);</span><br><span class="line">slf4jLogFilter.setStatementCreateAfterLogEnabled(<span class="keyword">false</span>);</span><br><span class="line">slf4jLogFilter.setStatementCloseAfterLogEnabled(<span class="keyword">false</span>);</span><br><span class="line"><span class="comment">//设置输出执行后的日志 带执行耗时等信息</span></span><br><span class="line">slf4jLogFilter.setStatementExecuteAfterLogEnabled(<span class="keyword">false</span>);</span><br><span class="line"><span class="comment">//设置批量操作执行后的日志 带执行耗时等信息</span></span><br><span class="line">slf4jLogFilter.setStatementExecuteBatchAfterLogEnabled(<span class="keyword">false</span>);</span><br><span class="line"><span class="comment">//设置查询操作执行后的日志 带执行耗时等信息</span></span><br><span class="line">slf4jLogFilter.setStatementExecuteQueryAfterLogEnabled(<span class="keyword">false</span>);</span><br><span class="line"><span class="comment">//设置更新 插入 删除 操作执行后的日志 带执行耗时等信息</span></span><br><span class="line">slf4jLogFilter.setStatementExecuteUpdateAfterLogEnabled(<span class="keyword">false</span>);</span><br><span class="line"><span class="comment">//输出完整的SQL 将值替换掉问号，这个仅在开发模式下有效</span></span><br><span class="line">slf4jLogFilter.setStatementExecutableSqlLogEnable(DEV_MODE);</span><br></pre></td></tr></table></figure>- 数据库连接池（典型使用）<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> DruidPlugin druidplugin;</span><br><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line">    druidplugin= MainConfig.createSQLserverDruidPlugin();</span><br><span class="line">    druidplugin.start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  Connection <span class="title">getConnection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Connection connection =druidplugin.getDataSource().getConnection();</span><br><span class="line">            <span class="keyword">return</span> connection;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>- 读取配置文件的类- 等## 反射机制：### 反射概念：reflection (反射)是被视为动态语言的关键，反射机制允许程序在执行期，借助于refelction 取得任何类的内部信息，并能够直接操作任意对象的内部属性及方法加载完类之后，在堆内存的方法区就产生了一个class类型的对象（一个类中只有一个class的对象），这个对象就包含了完整的类的结构。![image-20210823100910743](https://gitee.com/jwz--jwz/cloud-img/raw/master/image/202201222323327.png)### Java反射机制提供的功能在运行时判断任意一个对象所属的类在运行时构造任意一个类的对象在运行时判断任意一个类所具有的成员变量和方法在运行时获取泛型信息在运行时判断任意一个对象所具有的成员变量和方法在运行是处理注解生成动态代理### 反射主要的API：java.lang.Class:代表一个类java.lang.reflect.Method:代表类的方法java.lang.reflect.Field:代表类的成员变量java.lang.reflect.Constructor:代表类的构造器<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Class cla = User.class;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//              通过反射获取对象的构造方法</span></span><br><span class="line">            Constructor constructor = cla.getConstructor(String.class);</span><br><span class="line">            User user = (User) constructor.newInstance(<span class="string">&quot;jjjjj&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;user = &quot;</span> + user);</span><br><span class="line"><span class="comment">//           2、通过反射，调用对象指定的属性</span></span><br><span class="line">            Field userName = cla.getDeclaredField(<span class="string">&quot;userName&quot;</span>);</span><br><span class="line">            userName.set(user, <span class="string">&quot;22222&quot;</span>);</span><br><span class="line">            System.out.println(user.toString());</span><br><span class="line"><span class="comment">//            调用指定的方法</span></span><br><span class="line">            Method show = cla.getDeclaredMethod(<span class="string">&quot;show&quot;</span>);</span><br><span class="line">            show.invoke(user);</span><br><span class="line"><span class="comment">//          通过反射，可以调用Person类的私有的结构，比如私有的构造器、方法、属性</span></span><br><span class="line">            Constructor declaredConstructor = cla.getDeclaredConstructor(String.class,String.class);</span><br><span class="line">            declaredConstructor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            User user1 = (User) declaredConstructor.newInstance(<span class="string">&quot;jjj&quot;</span>,<span class="string">&quot;uuuuu&quot;</span>);</span><br><span class="line">            System.out.println(user1);</span><br><span class="line"><span class="comment">//          通过反射，直接获取私有的属性</span></span><br><span class="line">            Field name = cla.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">            name.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            name.set(user,<span class="string">&quot;66666&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;user = &quot;</span> + user);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>###   哪些类型可以有class对象?- 外部类，成员(成员内部类，静态内部类)，-  局部内部类，匿名内部类-  interface:接口-  []:数组-   enum:枚举-  annotation:注解@interface(6) - primitive type:基本数据类型( 7) void![image-20210824202449619](C:\Users\jinweizhuo\AppData\Roaming\Typora\typora-user-images\image-20210824202449619.png![image-20210824202620811](https://gitee.com/jwz--jwz/cloud-img/raw/master/image/202201222323271.png)<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 关于class.lang.class类的理解</span><br><span class="line"> * 1、类的加载文件</span><br><span class="line"> * 程序在经过javac.exe命令以后，会生成一个或者多个字节码文件（。class）文件，</span><br><span class="line"> * 接着使用java.exe命令对某个字节码文件进行解释运行。相当于将某个字节码文件加载到内存种</span><br><span class="line"> * 这个就是类的加载，加载到内存中的类，我们就称为  运行时类 ，这时候运行时类，就是一个class的实例（相当于类本身也是个对象）</span><br><span class="line"> *</span><br><span class="line"> * 2、class的实例就是一个运行时的对应的运行时类</span><br><span class="line"> * 3、加载到了内存中的运行时类，会缓存一定的的时间，在此时间类,我们可以通过不同的方式来获取运行时类</span><br><span class="line"> */</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//    获取class的实例的方式</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//          方式一：调用运行时类的属性：.class</span></span><br><span class="line">            Class class1= User.class;</span><br><span class="line">            System.out.println(<span class="string">&quot;class1 = &quot;</span> + class1);</span><br><span class="line"><span class="comment">//           方式二： 通过运行时类的对象，调用getclass()</span></span><br><span class="line">            User p1 = <span class="keyword">new</span> User();</span><br><span class="line">            Class class2= p1.getClass();</span><br><span class="line">            System.out.println(class2);</span><br><span class="line"><span class="comment">//            方式三：通过调用class的静态方法</span></span><br><span class="line">            Class class3 =Class.forName(<span class="string">&quot;wz.Reflection.User&quot;</span>);</span><br><span class="line">            System.out.println(class3);</span><br><span class="line"><span class="comment">//            加载到内存中的运行时类，会缓存一段时间，我们可以通过不同的的方式来获取运行时类</span></span><br><span class="line">            System.out.println(class1 == class2);</span><br><span class="line">            System.out.println(class1 == class3);</span><br><span class="line"><span class="comment">//             使用类加载机制： classLoader</span></span><br><span class="line"><span class="comment">//             先加载类，然后在使用类</span></span><br><span class="line">            ClassLoader classLoader = ReflectionTest.class.getClassLoader();</span><br><span class="line">            Class class4  = classLoader.loadClass(<span class="string">&quot;wz.Reflection.User&quot;</span>);</span><br><span class="line"><span class="comment">//            使用类加载器：ClassLoader获取对象</span></span><br><span class="line">            System.out.println(<span class="string">&quot;class4 = &quot;</span> + class4);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>### 类的加载与ClassLoader的理解：####       类的加载过程当程序主动使用某个类时，如果该类还没有被加载到内存中，则系统会通过一下三个步骤对该类进行初始化![image-20210824203438316](C:\Users\jinweizhuo\AppData\Roaming\Typora\typora-user-images\image-20210824203438316.png)![image-20210824203819378](https://gitee.com/jwz--jwz/cloud-img/raw/master/image/202201222323077.png)####  类加载器的作用：   ![image-20210824204248064](https://gitee.com/jwz--jwz/cloud-img/raw/master/image/202201222323771.png)##### 类加载器的作用：   将class文件字节码内容加载到内存中，并将这些静态数据转换成方法区的运行时数据结构，然后在堆中生成一个代表这个类的Java.lang。class对象，作为方法区中类数据的访问入口###### 类缓存:##### 标准的JavaSE类加载器可以按要求查找类，但一旦某个类被加载到类加载器中，它将维持加载（缓存）一段时间。不过JⅣM垃圾回收机制可以回收这些Class对象。#####    ![image-20210824204910174](https://gitee.com/jwz--jwz/cloud-img/raw/master/image/202201222323423.png)### 创建运行时类的对象:通过newInstance()创建运行时类的对象<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;User&gt; personClass = User.class;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * newInstance() 调用此方法,创建对应的运行时对象,内部调用了运行时类的空参构造</span></span><br><span class="line"><span class="comment">    *要想此方法正常的创建运行时类的对象</span></span><br><span class="line"><span class="comment">    * 1 运行时类必须要提供空参的构造器</span></span><br><span class="line"><span class="comment">    * 空参的构造器的访问权限,通常设置为public</span></span><br><span class="line"><span class="comment">    * 在Javabean 中要求提供一个public的空参构造器,原因</span></span><br><span class="line"><span class="comment">    * 1 便于通过反射,创建运行时类的对象</span></span><br><span class="line"><span class="comment">    * 便于子类继承此运行时类时,默认调用super()时,保证父类有此构造器</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   User obj =personClass.newInstance();</span><br><span class="line">   System.out.println(<span class="string">&quot;obj = &quot;</span> + obj);</span><br></pre></td></tr></table></figure>### java反射机制概述:<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> wz.Reflection.TestField;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> wz.Reflection.Person;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Annotation;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.*;</span><br><span class="line"><span class="keyword">import</span> java.time.Period;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestField</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Class cl = Person.class;</span><br><span class="line"><span class="comment">//      获取属性结构</span></span><br><span class="line">        <span class="comment">//拿取public 修饰的属性值</span></span><br><span class="line"><span class="comment">//     getFields(): 获取当前运行时类及其父类中的属性,该属性必须为public 修饰权限的属性值</span></span><br><span class="line">        Field[] fields = cl.getFields();</span><br><span class="line">        <span class="keyword">for</span> (Field f : fields</span><br><span class="line">        ) &#123;</span><br><span class="line">            System.out.println(f);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;------------&quot;</span>);</span><br><span class="line"><span class="comment">//        getDeclaredFields():获取当前运行时类中声明的所有属性,(不能包含父类中的属,当前类中使用public 修饰的值)</span></span><br><span class="line">        Field[] declareFields = cl.getDeclaredFields();</span><br><span class="line">        <span class="keyword">for</span> (Field f : declareFields</span><br><span class="line">        ) &#123;</span><br><span class="line">            System.out.println(f);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//    权限修饰符 数据类型 变量名</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Class clazz = Person.class;</span><br><span class="line">        Field[] declareFields = clazz.getDeclaredFields();</span><br><span class="line">        <span class="keyword">for</span> (Field f : declareFields</span><br><span class="line">        ) &#123;</span><br><span class="line"><span class="comment">//            1.权限修饰符,获取权限修饰符</span></span><br><span class="line">            <span class="keyword">int</span> modifiers = f.getModifiers();</span><br><span class="line"></span><br><span class="line">            System.out.print(Modifier.toString(modifiers) + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line"><span class="comment">//            2.获取数据类型值</span></span><br><span class="line">            Class type = f.getType();</span><br><span class="line">            System.out.print(type + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line"><span class="comment">//            3.获取数据变量名</span></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * privateclass java.lang.Stringname</span></span><br><span class="line"><span class="comment">             * publicintage</span></span><br><span class="line"><span class="comment">             * publicintid</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            String name = f.getName();</span><br><span class="line">            System.out.print(name);</span><br><span class="line">            System.out.println();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取运行时类的构造器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Class clazz = Person.class;</span><br><span class="line"><span class="comment">//       getConstructors()获取当前运行时类中声明为public 的构造器</span></span><br><span class="line">        Constructor[] constructors = clazz.getConstructors();</span><br><span class="line">        <span class="keyword">for</span> (Constructor c :</span><br><span class="line">                constructors) &#123;</span><br><span class="line">            System.out.println(c);</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * public wz.Reflection.Person()</span></span><br><span class="line"><span class="comment">             * public wz.Reflection.Person(java.lang.String)</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//  获取当前运行是类的所有构造器</span></span><br><span class="line">        Constructor[] constructor = clazz.getDeclaredConstructors();</span><br><span class="line">        <span class="keyword">for</span> (Constructor c :</span><br><span class="line">                constructor) &#123;</span><br><span class="line">            System.out.println(c);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取运行时类的父类及父类的泛型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestT</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//        supec = class java.lang.Class</span></span><br><span class="line">        Class c = Person.class;</span><br><span class="line">        Class supec = c.getClass();</span><br><span class="line">        System.out.println(<span class="string">&quot;supec = &quot;</span> + supec);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取运行时类带泛型的父类的泛型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSuperClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//        genericSuperclass = wz.Reflection.Creature&lt;java.lang.String&gt;</span></span><br><span class="line">        Class&lt;Person&gt; personClass = Person.class;</span><br><span class="line">        Type genericSuperclass = personClass.getGenericSuperclass();</span><br><span class="line">        System.out.println(<span class="string">&quot;genericSuperclass = &quot;</span> + genericSuperclass);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获运行时类的带泛型的父类的泛型</span></span><br><span class="line"><span class="comment">     * actualTypeArgument[0] = class java.lang.String</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestSuperClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Class clazz = Person.class;</span><br><span class="line">        Type genericSupperClass = clazz.getGenericSuperclass();</span><br><span class="line">        ParameterizedType parameterizedType = (ParameterizedType) genericSupperClass;</span><br><span class="line"><span class="comment">//        获取泛型的数据</span></span><br><span class="line">        Type[] actualTypeArgument = parameterizedType.getActualTypeArguments();</span><br><span class="line">        System.out.println(<span class="string">&quot;actualTypeArgument[0] = &quot;</span> + (Class) actualTypeArgument[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取运行时类的接口</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestInterface</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        interface java.lang.Comparable</span></span><br><span class="line"><span class="comment">        interface wz.Reflection.MyInterface</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Class clazz = Person.class;</span><br><span class="line">        Class[] interfaces = clazz.getInterfaces();</span><br><span class="line">        <span class="keyword">for</span> (Class c :</span><br><span class="line">                interfaces) &#123;</span><br><span class="line">            System.out.println(c);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取运行时类的父类的接口，先得到反射的类的对象。在使用对象进行进行后一步的操作</span></span><br><span class="line">        Class[] interfaces1 = clazz.getSuperclass().getInterfaces();</span><br><span class="line">        <span class="keyword">for</span> (Class c :</span><br><span class="line">                interfaces) &#123;</span><br><span class="line">            System.out.println(c);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取运行时类所在的包</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Testpackage</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//        pack = package wz.Reflection</span></span><br><span class="line">        Class cla = Person.class;</span><br><span class="line">        Package pack = cla.getPackage();</span><br><span class="line">        System.out.println(<span class="string">&quot;pack = &quot;</span> + pack);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取运行时类的声明的注解</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestAnnotation</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        Class clazz = Person.class;</span><br><span class="line">        Annotation[] annotations = clazz.getAnnotations();</span><br><span class="line">        <span class="keyword">for</span> (Annotation a:</span><br><span class="line">             annotations) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;a = &quot;</span> + a);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>##### 反射获取对象实例：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> wz.Reflection.TestField;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> wz.Reflection.Person;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 调用运行时类的中的指定的接口，属性、方法、 构造器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestReflection</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestField</span><span class="params">()</span> <span class="keyword">throws</span> NoSuchFieldException, InstantiationException, IllegalAccessException </span>&#123;</span><br><span class="line">        Class clazz = Person.class;</span><br><span class="line"><span class="comment">//        创建运行时类的对象</span></span><br><span class="line">          Person p = (Person) clazz.newInstance();</span><br><span class="line"></span><br><span class="line"><span class="comment">//        获取指定的反射类型 ,指定泛型的属性，这里就是指获取反射对象的属性值</span></span><br><span class="line">        Field id = clazz.getField(<span class="string">&quot;id&quot;</span>);</span><br><span class="line"><span class="comment">//       属性--》动态获取的参数，指明哪个对象的属性值 + 参数2：参数值设置为多少</span></span><br><span class="line">        id.set(p,<span class="number">100</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;id = &quot;</span> + id);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 获取当前属性的值</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">int</span> pid =(<span class="keyword">int</span>) id.get(p);</span><br><span class="line">        System.out.println(<span class="string">&quot;pid = &quot;</span> + pid);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> InstantiationException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalAccessException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NoSuchFieldException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">testField</span><span class="params">()</span> <span class="keyword">throws</span> InstantiationException, IllegalAccessException, NoSuchFieldException </span>&#123;</span><br><span class="line">        Class clazz = Person.class;</span><br><span class="line"><span class="comment">//        创建运行时类的对象</span></span><br><span class="line">        Person p = (Person) clazz.newInstance();</span><br><span class="line"></span><br><span class="line"><span class="comment">//      获取运行时类的对象</span></span><br><span class="line">        Field name = clazz.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line"><span class="comment">//        保证当前属性值是可以访问的</span></span><br><span class="line">        name.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"><span class="comment">//        获取设置指定对象的此属性值</span></span><br><span class="line">        name.set(p,<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;name = &quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">testMethod</span><span class="params">()</span> <span class="keyword">throws</span> InstantiationException, IllegalAccessException, NoSuchMethodException, InvocationTargetException </span>&#123;</span><br><span class="line">        Class clazz = Person.class;</span><br><span class="line"><span class="comment">//     1   创建运行时类的对象</span></span><br><span class="line">       Person p =(Person) clazz.newInstance();</span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 获取指定的某个方法</span></span><br><span class="line"><span class="comment">        * 2获取某个指定的某个方法 ,指明获取的名称 参数2： 指明获取的方法的形参列表</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       Method show = clazz.getDeclaredMethod(<span class="string">&quot;show&quot;</span>, String.class);</span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        *3 invoke(): 参数1 方法的调用者 参数2 给方法赋值的形参</span></span><br><span class="line"><span class="comment">        * invoke() 的返回值即为对应类中调用的方法的返回值</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       Object chn = show.invoke(p, <span class="string">&quot;chn&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 调用指定的构造器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">TestConstructor</span><span class="params">()</span> <span class="keyword">throws</span> NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException </span>&#123;</span><br><span class="line">       Class cla  = Person.class;</span><br><span class="line">       Constructor declaredConstructor = cla.getDeclaredConstructor(String.class);</span><br><span class="line"><span class="comment">//        2、b保证构造器是可以进行访问的</span></span><br><span class="line"><span class="comment">//       3、调用此构造器创建运行时类的对象</span></span><br><span class="line">       declaredConstructor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"><span class="comment">//       3、调用此构造器创建运行时类的对象</span></span><br><span class="line">       Person tom = (Person)declaredConstructor.newInstance(<span class="string">&quot;tom&quot;</span>);</span><br><span class="line"><span class="comment">//       输出的是地址值</span></span><br><span class="line">       System.out.println(<span class="string">&quot;tom = &quot;</span> + tom);</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>### 1.写出获取Class实例的三种常见方式  Class clazz =String.ClassClass clazz =person.getClass();//sout(person)Class.forname(String classPath)//体现反射的动态性### 2.谈谈你对Class类的理解Class 实例对应着加载到内存中的一个运行时类## 反射的应用：动态代理### 代理设计模式的原理：   使用代理将对象包装起来然后用该对象取代原始的对象。任何对原始的对象都要通过代理。代理对象决定是否以何时将方法调用转到原始对象上在编译期间就将代理类和目标确定下来了，不利于程序的扩展。同时，每个代理只能为一个接口服务。这样就会导致开发过程中产生很多的代理。最好可以通过一个代理类完成全部的代理的功能 **主要区别就是在编译期间确定对象 还是在运行期间进行动态的创建**动态代理是指客户通过代理类来调用其他对象的方法，并且在运行时根据需要创建目标类的代理对象使用场合：​              调试​                远程方法的调用#### 动态代理相比于静态代理的优点:  抽象角色（接口中）声明的对象的方法都被转移到调用处理器一个集中的方法中去处理这样可以更加灵活的处理更多的方法#### 动态代理样例：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> wz.Reflection.Proxy;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">getBelief</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">(String food)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//被代理</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SuperMan</span> <span class="keyword">implements</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getBelief</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;I believe I can fly !&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">(String food)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;小&quot;</span> + food);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 要想实现动态代理，需要解决的问题？</span></span><br><span class="line"><span class="comment"> * 问题一： 如何解决根据加载到内存中的被代理类，动态的创建一个代理类及其对象</span></span><br><span class="line"><span class="comment"> * 问题二： 通过代理类的对象调用方法时，如何动态的去调用被代理类中的同名方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyFactory</span> </span>&#123;</span><br><span class="line">    <span class="comment">//调用此方法 返回一个代理类的对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getProxyInstance</span><span class="params">(Object obj)</span> </span>&#123;<span class="comment">//obj:被代理类的对象</span></span><br><span class="line">        MyInvocationHandler handler = <span class="keyword">new</span> MyInvocationHandler();</span><br><span class="line"><span class="comment">//        先进行对象的实例化</span></span><br><span class="line">        handler.bind(obj);</span><br><span class="line"><span class="comment">// 获取类加载器，创建代理类的对象，需要同代理类使用同样的接口，</span></span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(obj.getClass().getClassLoader(), obj.getClass().getInterfaces(), handler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyInvocationHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="comment">//    当我们通过代理类的对象，调用方法 a 时，就是自动的调用如下的方法：invoke()</span></span><br><span class="line">    <span class="comment">//    将被代理类要执行的方法a的功能就声明在invoke()中</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object object;<span class="comment">//赋值时,也需要使用被代理类的对象进赋值</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bind</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.object = o;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//    proxy调用者的对象，调用的方法，</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    method  代理类对象的调用的方法，此方法也就作为被代理类对象的方法</span></span><br><span class="line"><span class="comment">//    obj : 被代理类的对象</span></span><br><span class="line">        Object invoke = method.invoke(object, args);</span><br><span class="line"><span class="comment">//        上述方法的返回值就作为当前类中的invoke()返回值</span></span><br><span class="line">        <span class="keyword">return</span> invoke;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span>  <span class="class"><span class="keyword">class</span>  <span class="title">ProxyTest</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">            SuperMan superMan = <span class="keyword">new</span> SuperMan();</span><br><span class="line"><span class="comment">//            proxyInstance； 代理类的对象</span></span><br><span class="line">            Human proxyInstance = (Human) ProxyFactory.getProxyInstance(superMan);</span><br><span class="line">            proxyInstance.getBelief();</span><br><span class="line">            proxyInstance.eat(<span class="string">&quot;麻辣烫&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>#### 动态代理与AOP：、![image-20210901105249112](https://gitee.com/jwz--jwz/cloud-img/raw/master/image/202201222324606.png)​        ![image-20210901105209703](https://gitee.com/jwz--jwz/cloud-img/raw/master/image/202201222324838.png)以硬编码的方式就是在程序中将代码在编译期间就已经写死了,![image-20210901105603807](https://gitee.com/jwz--jwz/cloud-img/raw/master/image/202201222324621.png)## 常用类： ### 时间日期APL:jdk-8之前的日期APL:![image-20210901120406801](https://gitee.com/jwz--jwz/cloud-img/raw/master/image/202201222324841.png)#### java.lang.System​       ![image-20210901120353495](https://gitee.com/jwz--jwz/cloud-img/raw/master/image/202201222324592.png)<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestCurrent</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//        代表1970年1月1日到当前时间的时间差，常用于时间戳，精确到了毫秒</span></span><br><span class="line">        <span class="keyword">long</span> time = System.currentTimeMillis();</span><br><span class="line"><span class="comment">//        时间戳</span></span><br><span class="line">        System.out.println(time);</span><br><span class="line"><span class="comment">//        1630469278535</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>####    2、java.util.Date![image-20210901123245640](https://gitee.com/jwz--jwz/cloud-img/raw/master/image/202201222324208.png)#### 3、java.text.SimpleDateformat![image-20210903182720331](https://gitee.com/jwz--jwz/cloud-img/raw/master/image/202201222324773.png)# java 多线程：## 线程池的使用：> 当执行大量的异步操作的时候，线程池能够提供较好的性能。在不使用线程池的情况之下，线程的创建是需要进行销毁的，需要很大的开销。线程池里面的线程是可以进行复用的，不需要每次异步任务去重新的创建线程池提供一种可以管理的手段，比如限制线程的个数、动态新增线程等### 线程的分类有：- newCachedThreadPool创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。- newFixedThreadPool 创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。- newScheduledThreadPool 创建一个定长线程池，支持定时及周期性任务执行。  newSingleThreadExecutor 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。1在我们每次使用new Thread去创建线程的时候()]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java8</title>
      <link href="/2022/01/16/java8/"/>
      <url>/2022/01/16/java8/</url>
      
        <content type="html"><![CDATA[<h3 id="java8学习"><a href="#java8学习" class="headerlink" title="java8学习:"></a>java8学习:</h3><p>​                                                    返回类型</p><p>consumer<T> 消费型接口                  void              对类型为T的对象进行应用操作，包含方法 void accept(T t)</p><p>supplier<T> 供给型接口                    T                     返回类型为T的对象，包含方法： T  get()</p><p>function&lt;T,R&gt;函数型接口                R                      对类型为T 的对象应用操作，并返回结果。结果类型为R类型的 的对象  R apply(T t)  </p><p>perdicate<T> 断定型接口          boolean                  确定类型为T的对象是否满足某约束条件，并返回boolean</p><p>包含方法   Boolean test（T t）</p><p><img src="https://gitee.com/jwz--jwz/cloud-img/raw/master/image/202201222332064.png" alt="image-20210730214729591"></p><p>表达式：</p><p>（parameters）-&gt;expression</p><p>  (parameters) -&gt;(statments;)</p><p>()-&gt;{return “hello”;}</p><p>()-&gt;{return “hello world”;}</p><p>(integer i) -&gt; {return “Alex”+i} </p><p>(String s)-&gt; {return “hello Alex”;}</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">    Comparator&lt;Apple&gt; byColor  = <span class="keyword">new</span> Comparator&lt;Apple&gt;() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Apple o1, Apple o2)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> o1.getColor().compareTo(o2.getColor());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">        List&lt;Apple&gt; list= Collections.emptyList();</span><br><span class="line">        list.sort(byColor);</span><br><span class="line"><span class="comment">//        parameter list                arrow    lambda body</span></span><br><span class="line">        Comparator&lt;Apple&gt; byColor2 = (o1,o2)-&gt; o1.getColor().compareTo(o2.getColor());</span><br><span class="line">        Function&lt;String,Integer&gt; flambe= s -&gt; s.length();</span><br></pre></td></tr></table></figure><p>函数式接口：</p><h4 id="Consumer接口"><a href="#Consumer接口" class="headerlink" title="Consumer接口"></a>Consumer接口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Consumer</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Performs this operation on the given argument.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 可实现方法，接受一个参数且没有返回值</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t the input argument</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">accept</span><span class="params">(T t)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a composed &#123;<span class="doctag">@code</span> Consumer&#125; that performs, in sequence, this</span></span><br><span class="line"><span class="comment">     * operation followed by the &#123;<span class="doctag">@code</span> after&#125; operation. If performing either</span></span><br><span class="line"><span class="comment">     * operation throws an exception, it is relayed to the caller of the</span></span><br><span class="line"><span class="comment">     * composed operation.  If performing this operation throws an exception,</span></span><br><span class="line"><span class="comment">     * the &#123;<span class="doctag">@code</span> after&#125; operation will not be performed.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 默认方法，提供链式调用方式执行。执行流程：先执行本身的accept在执行传入参数after.accept方法。</span></span><br><span class="line"><span class="comment">     * 该方法会抛出NullPointerException异常。</span></span><br><span class="line"><span class="comment">     * 如果在执行调用链时出现异常，会将异常传递给调用链功能的调用者，且发生异常后的after将不会在调用。</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> after the operation to perform after this operation</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a composed &#123;<span class="doctag">@code</span> Consumer&#125; that performs in sequence this</span></span><br><span class="line"><span class="comment">     * operation followed by the &#123;<span class="doctag">@code</span> after&#125; operation</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if &#123;<span class="doctag">@code</span> after&#125; is null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> Consumer&lt;T&gt; <span class="title">andThen</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; after)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(after);</span><br><span class="line">        <span class="keyword">return</span> (T t) -&gt; &#123; accept(t); after.accept(t); &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="Predicate"><a href="#Predicate" class="headerlink" title="Predicate  :"></a>Predicate  :</h4><p>​    根据给定的规则，过滤集合中的字符串，规则由predicate的方法决定</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">private</span>  <span class="keyword">static</span> List&lt;Apple&gt; <span class="title">filterByWeight</span><span class="params">(List&lt;Apple&gt; source , LongPredicate  predicate)</span></span>&#123;</span><br><span class="line">      List&lt;Apple&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">      <span class="keyword">for</span> (Apple apple:source)&#123;</span><br><span class="line">          <span class="keyword">if</span>(predicate.test(apple.getWeight()))&#123;</span><br><span class="line">              result.add(apple);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">return</span>  result;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">testFilterByWeight</span><span class="params">()</span></span>&#123;</span><br><span class="line">    List&lt;Apple&gt; list = Arrays.asList(<span class="keyword">new</span> Apple(<span class="string">&quot;green&quot;</span>, <span class="number">150</span>), <span class="keyword">new</span> Apple(<span class="string">&quot;yellow&quot;</span>, <span class="number">120</span>), <span class="keyword">new</span> Apple(<span class="string">&quot;green&quot;</span>, <span class="number">120</span>));</span><br><span class="line">    List&lt;Apple&gt; appleList = filterByWeight(list, w -&gt; w&gt;<span class="number">100</span>);</span><br><span class="line">    System.out.println(appleList);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Test</span></span><br></pre></td></tr></table></figure><p>传入两个参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span>  <span class="keyword">static</span> List&lt;Apple&gt; <span class="title">filterBiPredicate</span><span class="params">(List&lt;Apple&gt; source , BiPredicate&lt;String,Long&gt; predicate)</span></span>&#123;</span><br><span class="line">    List&lt;Apple&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Apple apple:source)&#123;</span><br><span class="line">        <span class="keyword">if</span>(predicate.test(apple.getColor(),apple.getWeight()))&#123;</span><br><span class="line">            result.add(apple);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>  result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">testFilterBiPredicate</span><span class="params">()</span></span>&#123;</span><br><span class="line">    List&lt;Apple&gt; list = Arrays.asList(<span class="keyword">new</span> Apple(<span class="string">&quot;green&quot;</span>, <span class="number">150</span>), <span class="keyword">new</span> Apple(<span class="string">&quot;yellow&quot;</span>, <span class="number">120</span>), <span class="keyword">new</span> Apple(<span class="string">&quot;green&quot;</span>, <span class="number">120</span>));</span><br><span class="line">    List&lt;Apple&gt; appleList = filterBiPredicate(list,(s,w)-&gt;s.equals(<span class="string">&quot;green&quot;</span>)&amp;&amp;w&gt;<span class="number">100</span>);</span><br><span class="line">    System.out.println(appleList);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Test</span></span><br></pre></td></tr></table></figure><h6 id="创建并行流与创建串行流"><a href="#创建并行流与创建串行流" class="headerlink" title="创建并行流与创建串行流:"></a>创建并行流与创建串行流:</h6><p>​      对使用排序、过滤和分组等操作，充分发挥操作系统的多核的架构优势，在速度、新能上能够提高书别</p><p> BA:47:6D:66:DD:16:FC:43:91:51:5B:38:ED:18:24:26:27:F1:9A:B8</p><p>io.dcloud.app</p><p>方法体的引用与构造器 的引用 ：</p><p><img src="https://gitee.com/jwz--jwz/cloud-img/raw/master/image/202201222332664.png" alt="image-20210730223509749">  </p><p><img src="C:\Users\jinweizhuo\AppData\Roaming\Typora\typora-user-images\image-20210730235551315.png" alt="image-20210730235551315"></p><p><img src="C:\Users\wz\AppData\Roaming\Typora\typora-user-images\image-20210731000349926.png" alt="image-20210731000349926"></p><p>collection是一种静态的内存的数据结构，讲的是数据，而Steam是有关计算的与cpu</p><p><img src="C:\Users\jinweizhuo\AppData\Roaming\Typora\typora-user-images\image-20210731000712204.png" alt="image-20210731000712204"></p><p><img src="C:\Users\jinweizhuo\AppData\Roaming\Typora\typora-user-images\image-20210731000806859.png" alt="image-20210731000806859"></p><p>没有中间操作不会执行延迟操作</p><h3 id="创建Stream"><a href="#创建Stream" class="headerlink" title="创建Stream"></a>创建Stream</h3><p>创建Stream 方式一：通过集合</p><p><img src="C:\Users\wz\AppData\Roaming\Typora\typora-user-images\image-20210731172812485.png" alt="image-20210731172812485"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//    通过集合方式进行创建</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        List&lt;Employee&gt;  employees = EmployeeData.getEmployees();</span><br><span class="line"><span class="comment">//        default Stream&lt;E&gt; stream():返回一个顺序流</span></span><br><span class="line">        Stream&lt;Employee&gt; stream =employees.stream();</span><br><span class="line"><span class="comment">//        default Stream&lt;E&gt; parallelStream():返回一个并行流</span></span><br><span class="line">        Stream&lt;Employee&gt; employeeStream = employees.parallelStream();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>通过并行流可以对数组元素进行快速的排序过滤和分组</p><p>1.使用多核对数组进行排序</p><p> Arrays.paralleSort(numbers);</p><p>2.根据特定的条件（比如素数 和非素数）对数组进行分组</p><h4 id="方式二：通过数组："><a href="#方式二：通过数组：" class="headerlink" title="方式二：通过数组："></a>方式二：通过数组：</h4><p>Java8中的Arrays的静态方法stream()可以获取数组流:</p><ul><li>static <T> Stream<T> stream(Tarray):返回一个流<br>重载形式，能够处理对应基本类型的数组:</li><li>public static IntStream stream(int[]array)</li><li>public static LongStream stream(long[] array)</li><li>public static DoubleStream stream(double[] array)</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//    创建Stream方式二： 通过数组</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//        static &lt;T&gt; Stream&lt;T&gt; stream(Tarray):返回一个流</span></span><br><span class="line"><span class="comment">//        int []arr = new int[](1,2,3,4,5,6);</span></span><br><span class="line"><span class="comment">//        IntStream stream = Arrays.stream(arr);</span></span><br><span class="line">        Employee e1 =<span class="keyword">new</span> Employee(<span class="number">1001</span>,<span class="string">&quot;马化腾&quot;</span>,<span class="number">25</span>,<span class="number">1000.4</span>);</span><br><span class="line">        Employee employee = <span class="keyword">new</span> Employee(<span class="number">1003</span>, <span class="string">&quot;刘强东&quot;</span>, <span class="number">38</span>, <span class="number">9000.4</span>);</span><br><span class="line">        Employee[] employees = &#123;e1, employee&#125;;</span><br><span class="line">        Stream&lt;Employee&gt; stream1 = Arrays.stream(employees);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="方式三：通过Stream的of"><a href="#方式三：通过Stream的of" class="headerlink" title="方式三：通过Stream的of()"></a>方式三：通过Stream的of()</h4><p>可以调用Stream类静态方法 of(),通过显示值创建一个流。它可以接收任意数量的参数。</p><ul><li>public static<T> Stream<T> of(T… values):返回一个流</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  创建Stream 方式四：创建无限流</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Stream&lt;Integer&gt; integerStream = Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">12</span>);</span><br><span class="line"><span class="comment">//        public static&lt;T&gt; Stream&lt;T&gt;iterate(final T seed, final UnaryOperator&lt;T&gt; f)·生成</span></span><br><span class="line"><span class="comment">//        public static&lt;T&gt; Stream&lt;T&gt;generate(Supplier&lt;T&gt;s)</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="方式四：创建无限流"><a href="#方式四：创建无限流" class="headerlink" title="方式四：创建无限流"></a>方式四：创建无限流</h4><p>创建Stream方式四:创建无限流<br>可以使用静态方法 Stream.iterate()和 Stream.generate(),创建无限流。<br>●迭代<br>      public static<T> Stream<T>iterate(final T seed, final UnaryOperator<T> f) </p><ul><li><p>生成</p><p>public static<T> Stream<T>generate(Supplier<T>s)</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//    创建无限流</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">test5</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//        遍历前10个偶数</span></span><br><span class="line">     Stream.iterate(<span class="number">0</span>,t-&gt;t+<span class="number">2</span>).limit(<span class="number">10</span>).forEach(System.out::println);</span><br><span class="line"><span class="comment">//     生成</span></span><br><span class="line">    Stream.generate(Math::random).limit(<span class="number">10</span>).forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Stream中间操作："><a href="#Stream中间操作：" class="headerlink" title="Stream中间操作："></a>Stream中间操作：</h3><h4 id="1、筛选切片"><a href="#1、筛选切片" class="headerlink" title="1、筛选切片"></a>1、筛选切片</h4><p>多个中间操作可以连接起来形成一个流水线，除非流水线上触发终止操作，否则中间操作不会执行任何的处理!而在终止操作时一次性全部处理,称为“惰性求值”。</p><p>filter(Predicate p)     接收Lambda，从流中排除某些元素</p><p>distinct()                      筛选,通过流所生成元素的hashCode()和equals()去除重复元素</p><p>limit(long maxsize)    截断流,使其元素不超过给定数量</p><p>skip(long n)                跳过元素，返回一个扔掉了前n个元素的流。若流中元素不足n个，则返回一个空流。与                         </p><p>、                                 limit(n)互补</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">//    1、筛选与切片</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        List&lt;Employee&gt; employeeList = EmployeeData.getEmployees();</span><br><span class="line">        Stream&lt;Employee&gt; employeeStream = employeeList.stream();</span><br><span class="line"><span class="comment">//        filter(Predicate p)     接收Lambda，从流中排除某些元素</span></span><br><span class="line">        employeeStream.filter(e-&gt;e.getSalary()&gt;<span class="number">7000</span>).forEach(System.out::println);</span><br><span class="line"><span class="comment">//        limit(long maxsize)    截断流,使其元素不超过给定数量</span></span><br><span class="line">        employeeList.stream().limit(<span class="number">3</span>).forEach(System.out::println);</span><br><span class="line">        System.out.println(<span class="string">&quot;----------&quot;</span>);</span><br><span class="line">        employeeList.stream().skip(<span class="number">3</span>).forEach(System.out::println);</span><br><span class="line"><span class="comment">//        distinct() 筛选,通过流所生成元素的hashCode()和equals()去除重复元素</span></span><br><span class="line">        employeeList.stream().distinct().forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="2、映射"><a href="#2、映射" class="headerlink" title="2、映射"></a>2、映射</h4><p> map(Function f)    接收一个函数作为参数，该函数会被应用到每个元素上，并将其映射成一个新的元素。</p><p>mapToDouble(ToDoubleFunction f)  接收一个函数作为参数,该函数会被应用到每个元素上，产生一个新的 DoubleStream。</p><p>map Tolnt( TolntFunction f)     接收一个函数作为参数，该函数会被应用到每个元素上，产生一个新的IntStream。</p><p>map ToLong( ToLongFunction f)  接收一个函数作为参数，该函数会被应用到每个元素上，产生一个新的 LongStream。</p><p>flatMap(Function f）         接收一个函数作为参数，将流中的每个值都换成另一个流，然后把所有流连接成一个流</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        List&lt;String&gt;  list =Arrays.asList(<span class="string">&quot;aaa&quot;</span>,<span class="string">&quot;bbbb&quot;</span>,<span class="string">&quot;cc&quot;</span>);</span><br><span class="line"><span class="comment">//        map(function f)</span></span><br><span class="line">        list.stream().map(String::toUpperCase).forEach(System.out::println);</span><br><span class="line">        List&lt;Employee&gt; employees = EmployeeData.getEmployees();</span><br><span class="line">               employees.stream().map(Employee::getName)</span><br><span class="line">                .filter(name-&gt;name.length()&gt;<span class="number">3</span>).forEach(System.out::println);</span><br><span class="line"><span class="comment">//       flatMap(Function f)</span></span><br><span class="line"><span class="comment">//        flatMap(</span></span><br><span class="line"><span class="comment">//        Function f）         接收一个函数作为参数，将流中的每个值都换成另一个流，然后把所有流连接成一个流</span></span><br><span class="line">        Stream&lt;Stream&lt;Character&gt;&gt; streamStream = list.stream().map(StreamAPITest1::fromStringToStream);</span><br><span class="line">        streamStream.forEach(s-&gt;s.forEach(System.out::println));</span><br><span class="line"><span class="comment">//       直接接受</span></span><br><span class="line">  list.stream().flatMap(StreamAPITest1::fromStringToStream).forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Stream&lt;Character&gt; <span class="title">fromStringToStream</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">        ArrayList&lt;Character&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Character c: str.toCharArray())&#123;</span><br><span class="line">            list.add(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>  list.stream();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="3、排序"><a href="#3、排序" class="headerlink" title="3、排序"></a>3、排序</h4><p>sorted()：产生一个新流，其中按自然顺序排序</p><p>sorted(Comparator com)：产生一个新流，其中按比较器顺序排序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//        sorted()：产生一个新流，其中按自然顺序排序</span></span><br><span class="line">        List&lt;Integer&gt; list = Arrays.asList(<span class="number">12</span>, <span class="number">43</span>, <span class="number">2</span>, <span class="number">56</span>, <span class="number">7</span>, <span class="number">84</span>, <span class="number">14</span>);</span><br><span class="line">        list.stream().sorted().forEach(System.out::println);</span><br><span class="line">        EmployeeData.getEmployees().stream().sorted((e1,e2)-&gt;</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">int</span> ageratum= Integer.compare(e1.getAge(),e2.getAge());</span><br><span class="line">                    <span class="keyword">if</span> (ageratum!=<span class="number">0</span>)&#123;</span><br><span class="line">                        <span class="keyword">return</span>  ageratum;</span><br><span class="line">                    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span>  Double.compare(e1.getSalary(),e2.getSalary());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">               )</span><br><span class="line">                .forEach(System.out::println);</span><br><span class="line">        EmployeeData.getEmployees().stream().sorted((e1,e2)-&gt;Integer.compare(e1.getAge(),e2.getAge()))</span><br><span class="line">                .forEach(System.out::println);</span><br><span class="line"><span class="comment">//        sorted(Comparator com)：产生一个新流，其中按比较器顺序排序</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="4、Stream的终止操作"><a href="#4、Stream的终止操作" class="headerlink" title="4、Stream的终止操作"></a>4、Stream的终止操作</h4><ul><li><p>终端操作会从流的流水线生成结果。其结果可以是任何不是流的值，例如:List. Integer，甚至是void .</p></li><li><p>流进行了终止操作后,不能再次使用。1-匹配与查找</p></li></ul><p>流进行了终止操作后,不能再次使用。</p><p>1-匹配与查找:</p><p>allMatch(Predicate p)                   检查是否匹配所有元素</p><p>anyMatch(Predicate p)                  检查是否至少匹配一个元素</p><p>noneMatch(Predicate p)                 检查是否没有匹配所有元素</p><p>findFirst()                                            返回第一个元素</p><p>findAny()                                            返回当前流中的任意元素</p><p>count()                                                返回流中元素总数</p><p>max(Comparator c)                           返回流中最大值</p><p>min(Comparator c)                             返回流中最小值</p><p>forEach(Consumer c)                              称为外部迭代。相反，Stream API使用内普迭代——它帮你把迭代做了)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;Employee&gt; employees = EmployeeData.getEmployees();</span><br><span class="line"><span class="comment">//            任意员工的值都大于18</span></span><br><span class="line">        <span class="keyword">boolean</span> match = employees.stream().allMatch(e -&gt; e.getAge() &gt; <span class="number">30</span>);</span><br><span class="line">        System.out.println(match);</span><br><span class="line"><span class="comment">//           是否存在员工工资大于10000</span></span><br><span class="line">        <span class="keyword">boolean</span> b = employees.stream().anyMatch(e -&gt; e.getSalary() &gt; <span class="number">10000</span>);</span><br><span class="line">        System.out.println(b);</span><br><span class="line"><span class="comment">//          是否存在员工姓雷</span></span><br><span class="line">        <span class="keyword">boolean</span> b1 = employees.stream().noneMatch(e -&gt; e.getName().startsWith(<span class="string">&quot;1&amp;&quot;</span>));</span><br><span class="line">        System.out.println(b1);</span><br><span class="line">        <span class="comment">//        返回第一个元素</span></span><br><span class="line">        Optional&lt;Employee&gt; first = employees.stream().findFirst();</span><br><span class="line">        System.out.println(first);</span><br><span class="line"><span class="comment">//        求个数</span></span><br><span class="line">        <span class="keyword">long</span> count = employees.stream().filter(e -&gt; e.getSalary() &gt; <span class="number">5000</span>).count();</span><br><span class="line">        System.out.println(<span class="string">&quot;count = &quot;</span> + count);</span><br><span class="line">        Optional&lt;Double&gt; max = employees.stream().map(e -&gt; e.getSalary()).max(Double::compare);</span><br><span class="line">        System.out.println(<span class="string">&quot;max = &quot;</span> + max);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="5、归约："><a href="#5、归约：" class="headerlink" title="5、归约："></a>5、归约：</h4><p>reduce(T iden, Binaryoperator b)       可以将流中元素反复结合起来,得到一个值。返回T</p><p>reduce(Binaryoperator b)                     可以将流中元素反复结合起来,得到一个值。返回Optional<T></p><p>备注:map 和reduce 的连接通常称为map-reduce模式，因Google用它来进行网络搜索而出名。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//        计算1-10的自然数的和</span></span><br><span class="line">        List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>);</span><br><span class="line">        Integer reduce = list.stream().reduce(<span class="number">0</span>, Integer::sum);</span><br><span class="line">        System.out.println(<span class="string">&quot;reduce = &quot;</span> + reduce);</span><br><span class="line"><span class="comment">//      计算所有公司员工的工资的总和</span></span><br><span class="line">    List&lt;Employee&gt; employees = EmployeeData.getEmployees();</span><br><span class="line">    Stream&lt;Double&gt; doubleStream = employees.stream().map(Employee::getSalary);</span><br><span class="line">    Optional&lt;Double&gt; reduce1 = doubleStream.reduce(Double::sum);</span><br><span class="line">    System.out.println(<span class="string">&quot;reduce1 = &quot;</span> + reduce1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6、收集："><a href="#6、收集：" class="headerlink" title="6、收集："></a>6、收集：</h4><p>Stream的终止操作<br>3-收集<br>方法<br>播述</p><table><thead><tr><th>collect(Collector c)</th><th>将流转换为其他形式。接收一个Collector,接口的实现,用于给Stream中元素做汇总的方法</th></tr></thead></table><p>接口的实现,用于给Stream中元素做汇总的方法,Collector接口中方法的实现决定了如何对流执行收集的操作(如收集到List、Set、Map).<br>另外，Collectors实用类提供了很多静态方法，可以方便地创建常见收集器实例，具体方法与实例如下表:</p><table><thead><tr><th>方法</th><th>返回类型</th><th>作用</th></tr></thead><tbody><tr><td>toList</td><td>List<T></td><td>把流中元素收集到List</td></tr><tr><td>List<Employee> emps= list.stream().collect(Collectors.toList());</td><td></td><td></td></tr><tr><td>toSet</td><td>Set<T></td><td>把流中元素收集到Set</td></tr><tr><td>Set<Employee> emps= list.stream().collect(Collectors.toSet());</td><td></td><td></td></tr><tr><td>toCollection</td><td>Collection<T></td><td>把流中元素收集到创建的集合</td></tr><tr><td>Collection<Employee> emps =list.stream().collect(Collectors.toCollection(ArrayList:new);</td><td></td><td></td></tr><tr><td>counting</td><td>Long</td><td>计算流中元素的个数</td></tr><tr><td>long count = list.stream().collect(Collectors.counting0;</td><td></td><td></td></tr><tr><td>summinglnt</td><td>lnteger</td><td>对流中元素的整数属性求和</td></tr><tr><td>int total=list.stream().collect(Collectors.summinglnt(Employee..getSalary));</td><td></td><td></td></tr><tr><td>averaginglnt</td><td>Double</td><td>计算流中元素Integer属性的平均值</td></tr><tr><td>double avg = list.stream().collect(Collectors.averagingInt(Employee:getSalary));</td><td></td><td></td></tr><tr><td>summarizinglnt</td><td>IntSummaryStatistics</td><td>收集流中lnteger属性的统计值。如:平均值</td></tr><tr><td>int SummaryStatisticsiss= list.stream().collect(Collectors.summarizingInt(Employee:getSalary);</td><td></td><td></td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test6</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//        将流转换为其他形式。接收一个Collector,接口的实现,用于给Stream中元素做汇总的方法</span></span><br><span class="line">        List&lt;Employee&gt; employees = EmployeeData.getEmployees();</span><br><span class="line">        List&lt;Employee&gt; collect = employees.stream().filter(e -&gt; e.getSalary() &gt; <span class="number">1000</span>)</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line">        System.out.println(<span class="string">&quot;collect = &quot;</span> + collect);</span><br><span class="line"><span class="comment">//       无序的</span></span><br><span class="line">        Set&lt;Employee&gt; collect1 = employees.stream().filter(e -&gt; e.getSalary() &gt; <span class="number">1000</span>)</span><br><span class="line">                .collect(Collectors.toSet());</span><br><span class="line">        collect1.forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Optional类："><a href="#Optional类：" class="headerlink" title="Optional类："></a>Optional类：</h3><p>​        到目前为止，臭名昭著的空指针异常是导致Java应用程序失败的最常见原因。以前，为了解决空指针异常，Google公司著名的Guava项目引入了Optional类，Guava通过使用检查空值的方式来防止代码污染，它鼓励程序员写更干净的代码。受到Google Guava的启发，Optional类已经成为Java8类库的一部分。</p><p>​        Optional<T>类(java.util.Optional)是一个容器类，它可以保存类型T的值，代表这个值存在。或者仅仅保存null，表示这个值不存在。原来用null表示一个值不存在，现在 Optional可以更好的表达这个概念。并且可以避免空指针异常。</p><p>Optional类的Javadoc描述如下:</p><p>​        这是一个可以为null的容器对象。如果值存在则isPresent()方法会返回true，调用get()方法会返回该对象。</p><p><strong>创建Optional类对象的方法</strong>:</p><ul><li><p>Optional.of(T t):     创建一个Optional 实例,t必须非空;</p></li><li><p>Optional.empty():  创建一个空的Optional 实例</p></li><li><p>Optional.ofNullable(T t):t可以为null</p></li></ul><p><strong>判晰Optional容器中是否包含对象:</strong></p><ul><li><p> boolean isPresent(:判断是否包含对象</p></li><li><p> void ifPresent(Consumer&lt;? super T&gt;consumer):如果有值，就执行Consumer接口的实现代码，并且该值会作为参数传给它。</p></li></ul><p><strong>获取Optional容器的对象</strong>:</p><ul><li>T get(:如果调用对象包含值,返回该值，否则抛异常</li><li>T orElse(T other):如果有值则将其返回，否则返回指定的other对象。</li><li>T orEiseGet(Supplier&lt;? extends T&gt; other):如果有值则将其返回，否则返回由Supplier接口实现提供的对象。</li><li>T orElse Throw(Supplier&lt;? extends X&gt;exceptionSupplier):如果有值则将其返回，否则抛出由Supplier接口实现提供的异常。</li></ul><hr><hr><h3 id="方法引用"><a href="#方法引用" class="headerlink" title="::方法引用"></a>::方法引用</h3><p>可以应用于静态、实例以及构造方法</p><p>类名::静态方法名</p><p>实例::实例方法名</p><p>类名::new </p><h3 id="java8案例："><a href="#java8案例：" class="headerlink" title="java8案例："></a>java8案例：</h3>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>19 个高逼格 Linux 命令</title>
      <link href="/2022/01/16/19%20%E4%B8%AA%E9%AB%98%E9%80%BC%E6%A0%BC%20Linux%20%E5%91%BD%E4%BB%A4%EF%BC%8C%E8%B5%B6%E7%B4%A7%E6%8B%BF%E5%8E%BB%E7%94%A8%EF%BC%81/"/>
      <url>/2022/01/16/19%20%E4%B8%AA%E9%AB%98%E9%80%BC%E6%A0%BC%20Linux%20%E5%91%BD%E4%BB%A4%EF%BC%8C%E8%B5%B6%E7%B4%A7%E6%8B%BF%E5%8E%BB%E7%94%A8%EF%BC%81/</url>
      
        <content type="html"><![CDATA[<h1 id="19-个高逼格-Linux-命令"><a href="#19-个高逼格-Linux-命令" class="headerlink" title="19 个高逼格 Linux 命令"></a>19 个高逼格 Linux 命令</h1><p><img src="https://mmbiz.qpic.cn/sz_mmbiz_jpg/knmrNHnmCLFAXIXePIh9yUuO2BWE2KAdQMXuOyjc45iahJcFyGGX0pNaattEZrgIiaVibFZewdc4wtH1P40I1vExw/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><h1 id="1-sl-命令"><a href="#1-sl-命令" class="headerlink" title="1. sl 命令"></a><strong>1. sl 命令</strong></h1><p>你会看到一辆火车从屏幕右边开往左边……</p><p>安装</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install sl</span><br></pre></td></tr></table></figure><p>运行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sl</span><br></pre></td></tr></table></figure><p>命令有 -a l F e 几个选项，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-a An accident seems to happen. You&#x27;ll feel pity for people who cry for help.</span><br><span class="line"></span><br><span class="line">-l shows little one.</span><br><span class="line"></span><br><span class="line">-F It flies.</span><br><span class="line"></span><br><span class="line">-e Allow interrupt by Ctrl+C.</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/jwz--jwz/cloud-img/raw/master/image/202201201711937.webp" alt="图片"></p><p>可以给别人来个恶作剧，他一敲ls，不知道的肯定很有效果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$alias ls=sl</span><br></pre></td></tr></table></figure><h1 id="2-fortune-命令"><a href="#2-fortune-命令" class="headerlink" title="2. fortune 命令"></a><strong>2. fortune 命令</strong></h1><p>输出一句话，有笑话，名言什么的 (还有唐诗宋词sudo apt-get install fortune-zh)</p><p>安装</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$sudo apt-get install fortune</span><br></pre></td></tr></table></figure><p>运行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$fortune</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/jwz--jwz/cloud-img/raw/master/image/202201201712892.webp" alt="图片">img</p><h1 id="3-cowsay-命令"><a href="#3-cowsay-命令" class="headerlink" title="3. cowsay 命令"></a><strong>3. cowsay 命令</strong></h1><p>用ASCII字符打印牛，羊等动物，还有个cowthink，这个是奶牛想，那个是奶牛说，哈哈，差不多</p><p>安装</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$sudo apt-get install cowsay</span><br></pre></td></tr></table></figure><p>运行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$cowsay &quot;I am not a cow, hahaha&quot;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/jwz--jwz/cloud-img/raw/master/image/202201201712150.webp" alt="图片">img</p><p>$cowsay -l 查看其它动物的名字，然后 -f 跟上动物名，如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$cowsay -f tux &quot;坑爹啊&quot;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/jwz--jwz/cloud-img/raw/master/image/202201201712843.webp" alt="图片">img</p><p>还可以让cowsay说出fortune的内容，就像这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$fortune | cowsay</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/jwz--jwz/cloud-img/raw/master/image/202201201712751.webp" alt="图片">img</p><h1 id="4-cmatrix-命令"><a href="#4-cmatrix-命令" class="headerlink" title="4. cmatrix 命令"></a><strong>4. cmatrix 命令</strong></h1><p>这个很酷！《黑客帝国》那种矩阵风格的动画效果</p><p>安装</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install cmatrix</span><br></pre></td></tr></table></figure><p>运行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$cmatrix</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/jwz--jwz/cloud-img/raw/master/image/202201201712999.webp" alt="图片">img</p><h1 id="5-figlet-、toilet命令"><a href="#5-figlet-、toilet命令" class="headerlink" title="5. figlet 、toilet命令"></a><strong>5. figlet 、toilet命令</strong></h1><p>艺术字生成器，由ASCII字符组成，把文本显示成标题栏。此外还有banner这个命令</p><p>安装</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$sudo apt-get install figlet</span><br><span class="line"></span><br><span class="line">$sudo apt-get install toilet</span><br></pre></td></tr></table></figure><p>运行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$figlet fuck you !</span><br><span class="line"></span><br><span class="line">$toilet i love you</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/jwz--jwz/cloud-img/raw/master/image/202201201712785.webp" alt="图片">img</p><p>toilet 还可以添加颜色，里面的选项请自己 man 一下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ toilet -f mono12 -F gay a girl</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/jwz--jwz/cloud-img/raw/master/image/202201201712000.webp" alt="图片"></p><h1 id="6-oneko-命令"><a href="#6-oneko-命令" class="headerlink" title="6. oneko 命令"></a><strong>6. oneko 命令</strong></h1><p>桌面上出现一直喵星人，跟着你的鼠标跑，你不动了它就睡觉。哈哈，这个挺不错。</p><p>安装</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$sudo apt-get install oneko</span><br></pre></td></tr></table></figure><p>运行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$oneko</span><br></pre></td></tr></table></figure><p>要关掉这家伙，按ctrl+c 结束</p><p><img src="https://gitee.com/jwz--jwz/cloud-img/raw/master/image/202201201714002.webp" alt="图片">img</p><h1 id="7-xeyes-命令"><a href="#7-xeyes-命令" class="headerlink" title="7. xeyes 命令"></a><strong>7. xeyes 命令</strong></h1><p>在屏幕上出现一双眼睛，盯着你的鼠标指针</p><p>安装运行同上</p><p><img src="https://gitee.com/jwz--jwz/cloud-img/raw/master/image/202201201713943.webp" alt="图片">img</p><h1 id="8-yes-命令"><a href="#8-yes-命令" class="headerlink" title="8. yes 命令"></a><strong>8. yes 命令</strong></h1><p>输出无穷无尽的字符，按ctrl+c结束，如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$yes 我很NB</span><br></pre></td></tr></table></figure><h1 id="9-cal-9-1752"><a href="#9-cal-9-1752" class="headerlink" title="9. cal 9 1752"></a><strong>9. cal 9 1752</strong></h1><p>cal是打印日历，不过这个是很奇葩的一个月，</p><p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片">img</p><h1 id="10-shred"><a href="#10-shred" class="headerlink" title="10. shred"></a><strong>10. shred</strong></h1><p>覆盖搞乱文件，就是文档粉碎，哈哈，要把你私藏的大片种子和电影销毁，不被恢复出来，就靠它了</p><h1 id="11-factor"><a href="#11-factor" class="headerlink" title="11. factor"></a><strong>11. factor</strong></h1><p>分解因数，这个……小学生可以用一下</p><p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片"></p><h1 id="12-挨个敲下面这一堆，aptitude-没有的可以安装上"><a href="#12-挨个敲下面这一堆，aptitude-没有的可以安装上" class="headerlink" title="12. 挨个敲下面这一堆，aptitude 没有的可以安装上"></a><strong>12. 挨个敲下面这一堆，aptitude 没有的可以安装上</strong></h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">aptitude moo</span><br><span class="line"></span><br><span class="line">aptitude -v moo</span><br><span class="line"></span><br><span class="line">aptitude -vv moo</span><br><span class="line"></span><br><span class="line">aptitude -vvv moo</span><br><span class="line"></span><br><span class="line">aptitude -vvvv moo</span><br><span class="line"></span><br><span class="line">aptitude -vvvvv moo</span><br><span class="line"></span><br><span class="line">aptitude -vvvvvv moo</span><br><span class="line"></span><br><span class="line">aptitude -vvvvvvv moo</span><br></pre></td></tr></table></figure><h1 id="13、高大上仪表盘blessed-contrib——假装自己指点江山，纵横捭阖"><a href="#13、高大上仪表盘blessed-contrib——假装自己指点江山，纵横捭阖" class="headerlink" title="13、高大上仪表盘blessed-contrib——假装自己指点江山，纵横捭阖"></a><strong>13、高大上仪表盘blessed-contrib——假装自己指点江山，纵横捭阖</strong></h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install npm</span><br><span class="line">sudo apt install nodejs-legacy</span><br><span class="line">git clone https://github.com/yaronn/blessed-contrib.git</span><br><span class="line">cd blessed-contrib</span><br><span class="line">npm install</span><br><span class="line">node ./examples/dashboard.js</span><br></pre></td></tr></table></figure><p>高大上黑客仪表盘</p><p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片">img</p><h1 id="14、高大上仪表盘hollywood——假装自己日理万机，宵衣旰食"><a href="#14、高大上仪表盘hollywood——假装自己日理万机，宵衣旰食" class="headerlink" title="14、高大上仪表盘hollywood——假装自己日理万机，宵衣旰食"></a><strong>14、高大上仪表盘hollywood——假装自己日理万机，宵衣旰食</strong></h1><p>Dustin Kirkland 利用一个长途飞行的时间，编写了这个炫酷、有趣但也没什么实际作用的软件。</p><p>在其它Linux发行版中，可以通过以下命令安装并运行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-add-repository ppa:hollywood/ppa</span><br><span class="line">sudo apt-get install hollywood</span><br><span class="line">sudo apt-get install byobu</span><br><span class="line">hollywood</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片">img</p><h1 id="15、追逐鼠标的小猫oneko"><a href="#15、追逐鼠标的小猫oneko" class="headerlink" title="15、追逐鼠标的小猫oneko"></a><strong>15、追逐鼠标的小猫oneko</strong></h1><p>在桌面的命令行界面输入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install oneko</span><br><span class="line">oneko</span><br></pre></td></tr></table></figure><p>然后输入oneko，即可看到效果。</p><p><img src="https://gitee.com/jwz--jwz/cloud-img/raw/master/image/202201201715114.gif" alt="图片">img</p><h1 id="16、ASCII艺术框：box命令"><a href="#16、ASCII艺术框：box命令" class="headerlink" title="16、ASCII艺术框：box命令"></a><strong>16、ASCII艺术框：box命令</strong></h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install boxes</span><br><span class="line">echo &quot;Tongji Univerisity&quot; | boxes</span><br><span class="line">echo &quot;Tongji Univerisity&quot; | boxes -d dog</span><br><span class="line">fortune | boxes -d cat | lolcat</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/jwz--jwz/cloud-img/raw/master/image/202201201715900.webp" alt="图片">img</p><h1 id="17、燃起字符串大火aafire在命令行界面输入"><a href="#17、燃起字符串大火aafire在命令行界面输入" class="headerlink" title="17、燃起字符串大火aafire在命令行界面输入"></a><strong>17、燃起字符串大火aafire在命令行界面输入</strong></h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install libaa-bin</span><br><span class="line">aafire</span><br></pre></td></tr></table></figure><p>然后输入 aafire，即可看到效果</p><p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片">img</p><p>aafire字符串大火</p><h1 id="18、图片转字符串"><a href="#18、图片转字符串" class="headerlink" title="18、图片转字符串"></a><strong>18、图片转字符串</strong></h1><p>这条命令在树莓派上运行会出问题，建议在云主机或虚拟机上运行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install aview imagemagick</span><br><span class="line">wget http://labfile.oss.aliyuncs.com/courses/1/Linus.png</span><br><span class="line">asciiview Linus.png</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/jwz--jwz/cloud-img/raw/master/image/202201201715587.webp" alt="图片">img</p><h1 id="19、从删库到跑路-sudo-rm-rf"><a href="#19、从删库到跑路-sudo-rm-rf" class="headerlink" title="**19、从删库到跑路 sudo rm -rf /\"></a>**19、从删库到跑路 sudo rm -rf /\</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sudo rm -rf /*</span><br><span class="line">sudo：获取root管理员权限</span><br><span class="line">rm：remove，即删除</span><br><span class="line">-rf：r表示递归删除，即删除所有的子目录，f表示不需要再进行确认</span><br><span class="line">/：根目录</span><br><span class="line">*：所有文件</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/jwz--jwz/cloud-img/raw/master/image/202201201715769.gif" alt="图片">img</p><p>友情提示：千万不要轻易尝试这个命令，特别是在运行有网站服务器、数据库的Linux主机上 。</p><p>这些好玩的命令可以通过查 man 手册，然后在加上自己想出来的创意，改编成更多有趣的东西，哈哈，给别</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux指令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>blog</title>
      <link href="/2022/01/05/blog/"/>
      <url>/2022/01/05/blog/</url>
      
        <content type="html"><![CDATA[<h1 id="blog"><a href="#blog" class="headerlink" title="blog"></a>blog</h1><h1 id="安装hexo出现问题"><a href="#安装hexo出现问题" class="headerlink" title="安装hexo出现问题"></a>安装hexo出现问题</h1><p><img src="https://gitee.com/jwz--jwz/cloud-img/raw/master/image/202201051725679.png" alt="image-20220105172513638"></p><h2 id="解决办法："><a href="#解决办法：" class="headerlink" title="解决办法："></a>解决办法：</h2><p> <strong>nodejs没有配置全局变量</strong></p><p><strong>获取全局变量配置</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config get prefix</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/jwz--jwz/cloud-img/raw/master/image/202201051727741.png" alt="image-20220105172739717"></p><p><strong>配置系统变量（如下图所示）:</strong></p><img src="https://gitee.com/jwz--jwz/cloud-img/raw/master/image/202201051729183.png" alt="image-20220105172905149" style="zoom: 67%;" /><p><strong>安装：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli </span><br></pre></td></tr></table></figure><p><strong>测试是否成功：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo -v </span><br></pre></td></tr></table></figure><img src="https://gitee.com/jwz--jwz/cloud-img/raw/master/image/202201051730000.png" alt="image-20220105173021966" style="zoom:80%;" /><h3 id="参考教程："><a href="#参考教程：" class="headerlink" title="参考教程："></a>参考教程：</h3><p><a href="https://blog.csdn.net/qq_35280588/article/details/105787423">(30条消息) nodeJS全局环境变量的配置（windows10）_qq_35280588的博客-CSDN博客_nodejs配置环境变量 win10</a></p><h1 id="VScode管理博客分类与标签"><a href="#VScode管理博客分类与标签" class="headerlink" title="VScode管理博客分类与标签"></a>VScode管理博客分类与标签</h1><blockquote><p>应用商店搜索：vscode-hexo-utils ，点击安装即可</p></blockquote><p><img src="https://gitee.com/jwz--jwz/cloud-img/raw/master/image/202201051733412.png" alt="image-20220105173327385"></p><p>效果图展示：</p><img src="https://gitee.com/jwz--jwz/cloud-img/raw/master/image/202201051739143.png" alt="image-20220105173956092" style="zoom:80%;" /><h1 id="看板娘收集："><a href="#看板娘收集：" class="headerlink" title="看板娘收集："></a>看板娘收集：</h1><h2 id="看板娘："><a href="#看板娘：" class="headerlink" title="看板娘："></a>看板娘：</h2><blockquote><p>看板娘是一种职业和习惯称呼，也是ACGN次文化中的萌属性之一。简而言之就是小店的女服务生，也有“吸引顾客，招揽生意，提高人气”等作用类似品牌形象代言人的含义。</p><p>资源（.moc）全部收集自互联网，目前合集包括海王星系列、初音未来、雷姆、凉风青叶、尼禄、薇尔莉特、小埋、樱花庄、玉藻前。</p></blockquote><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h2 id="hexo配置："><a href="#hexo配置：" class="headerlink" title="hexo配置："></a>hexo配置：</h2><h3 id="安装："><a href="#安装：" class="headerlink" title="安装："></a>安装：</h3><blockquote><p>使用<code>helper-live2d</code>的Live2d插件<a href="https://github.com/EYHN/hexo-helper-live2d">https://github.com/EYHN/hexo-helper-live2d</a></p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install --save hexo-helper-live2d</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="配置"><a href="#配置" class="headerlink" title="配置:"></a>配置:</h3><blockquote><p>安装成功后，在hexo根目录的<code>_config.yml</code>添加如下配置(可以写在主题配置文件里)</p></blockquote><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Live2D</span></span><br><span class="line"><span class="comment">## https://github.com/EYHN/hexo-helper-live2d</span></span><br><span class="line"><span class="attr">live2d:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span> <span class="comment"># 开启live2d</span></span><br><span class="line">  <span class="comment"># enable: false</span></span><br><span class="line">  <span class="attr">scriptFrom:</span> <span class="string">local</span> <span class="comment"># 默认</span></span><br><span class="line">  <span class="attr">pluginRootPath:</span> <span class="string">live2d_models/</span> <span class="comment"># 插件在站点上的根目录(相对路径)</span></span><br><span class="line">  <span class="attr">pluginJsPath:</span> <span class="string">lib/</span> <span class="comment"># 脚本文件相对与插件根目录路径</span></span><br><span class="line">  <span class="attr">pluginModelPath:</span> <span class="string">assets/</span> <span class="comment"># 模型文件相对与插件根目录路径</span></span><br><span class="line">  <span class="comment"># scriptFrom: jsdelivr # jsdelivr CDN</span></span><br><span class="line">  <span class="comment"># scriptFrom: unpkg # unpkg CDN</span></span><br><span class="line">  <span class="comment"># scriptFrom: https://cdn.jsdelivr.net/npm/live2d-widget@3.x/lib/L2Dwidget.min.js # 你的自定义 url</span></span><br><span class="line">  <span class="attr">tagMode:</span> <span class="literal">false</span> <span class="comment"># 标签模式, 是否仅替换 live2d tag标签而非插入到所有页面中</span></span><br><span class="line">  <span class="attr">debug:</span> <span class="literal">false</span> <span class="comment"># 调试, 是否在控制台输出日志</span></span><br><span class="line">  <span class="attr">display:</span></span><br><span class="line">     <span class="attr">position:</span> <span class="string">right</span></span><br><span class="line">  <span class="attr">mobile:</span></span><br><span class="line">     <span class="attr">show:</span> <span class="literal">false</span>   </span><br><span class="line">  <span class="attr">model:</span></span><br><span class="line">     <span class="attr">scale:</span> <span class="number">1.2</span></span><br><span class="line">     <span class="attr">use:</span> <span class="string">violet</span></span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/jwz--jwz/cloud-img/raw/master/image/202201052100966.png"></p><blockquote><p>将<code>薇尔莉特·伊芙加登</code>复制到刚从新建的<code>live2d_models</code>文件夹内，然后重命名为<code>violet</code>(当然这个名字是你自定义的)，然后进入<code>violet</code>文件夹，里面有个<code>14.json</code>文件，将他重命名为<code>violet.model.json</code>其他文件无需修改，最后在<code>live2d</code>配置里的<code>model:</code>下的<code>use:</code>输入模型文件夹名(violet)</p><p><img src="https://gitee.com/jwz--jwz/cloud-img/raw/master/image/202201052104094.png" alt="image-20220105210408068"></p></blockquote><p><img src="https://gitee.com/jwz--jwz/cloud-img/raw/master/image/202201052103997.png" alt="image-20220105210324967"></p><blockquote><p>使用hexo g 生成代码 ，hexo s 运行</p></blockquote><h2 id="资源链接地址："><a href="#资源链接地址：" class="headerlink" title="资源链接地址："></a>资源链接地址：</h2><blockquote><p><a href="https://www.wikimoe.com/?post=158&comment-page=2#comments">Live2d模型合集分享 | FaceRig | 海王星系列 | 初音未来 | 雷姆 | 凉风青叶 | 尼禄 | 薇尔莉特 | 小埋 | 樱花庄 | 玉藻前 (wikimoe.com)</a></p><p>链接: <a href="https://pan.baidu.com/s/1Knwp-BKa393zF93QEQNDnw?pwd=29kh">https://pan.baidu.com/s/1Knwp-BKa393zF93QEQNDnw?pwd=29kh</a> 提取码: 29kh</p></blockquote><blockquote><p><a href="https://yilia.imlete.cn/article/Live2d-Config.html">Hexo-Live2d安装教程(自定义Live2d) | Lete乐特 ‘s Blog (imlete.cn)</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> blog搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>代码演示</title>
      <link href="/2022/01/05/Sqlserver/"/>
      <url>/2022/01/05/Sqlserver/</url>
      
        <content type="html"><![CDATA[<h1 id="Sqlserver"><a href="#Sqlserver" class="headerlink" title="Sqlserver"></a>Sqlserver</h1><h1 id="1-约束"><a href="#1-约束" class="headerlink" title="1 约束"></a>1 约束</h1><h2 id="1-2为表添加约束"><a href="#1-2为表添加约束" class="headerlink" title="1.2为表添加约束"></a>1.2为表添加约束</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> S <span class="keyword">with</span> <span class="keyword">check</span> </span><br><span class="line"> <span class="keyword">add</span> <span class="keyword">constraint</span> check_age <span class="keyword">check</span>( age <span class="operator">&gt;</span> <span class="number">14</span> <span class="keyword">and</span> age <span class="operator">&lt;=</span><span class="number">40</span>)</span><br></pre></td></tr></table></figure><h2 id="1-3-删除约束"><a href="#1-3-删除约束" class="headerlink" title="1.3 删除约束"></a>1.3 删除约束</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">go</span><br><span class="line"> <span class="keyword">alter</span> <span class="keyword">table</span> T </span><br><span class="line">  <span class="keyword">drop</span> <span class="keyword">constraint</span> check_t</span><br><span class="line">go </span><br></pre></td></tr></table></figure><p><img src="C:\Users\wz\AppData\Roaming\Typora\typora-user-images\image-20211128111640493.png" alt="image-20211128111640493"></p><h2 id="1-4-使用交互式创建约束"><a href="#1-4-使用交互式创建约束" class="headerlink" title="1.4 使用交互式创建约束"></a>1.4 使用交互式创建约束</h2><img src="C:\Users\wz\AppData\Roaming\Typora\typora-user-images\image-20211128111828984.png" alt="image-20211128111828984" style="zoom: 80%;" /><h2 id="1-5-参照性完整约束"><a href="#1-5-参照性完整约束" class="headerlink" title="1.5 参照性完整约束"></a>1.5 参照性完整约束</h2><hr><img src="C:\Users\wz\AppData\Roaming\Typora\typora-user-images\image-20211128123534629.png" alt="image-20211128123534629" style="zoom:67%;" /><p>使用外键进行级联操作：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">go</span><br><span class="line">use 金伟卓</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> TC <span class="keyword">with</span> nocheck</span><br><span class="line"> <span class="keyword">add</span> <span class="keyword">constraint</span> FK_T_TC <span class="keyword">foreign</span> key(TNO) <span class="keyword">references</span> T(TNO)</span><br><span class="line"> <span class="keyword">on</span> <span class="keyword">delete</span> cascade</span><br><span class="line">go </span><br></pre></td></tr></table></figure><p><img src="C:\Users\wz\AppData\Roaming\Typora\typora-user-images\image-20211128130844941.png" alt="image-20211128130844941"></p><h1 id="2-索引"><a href="#2-索引" class="headerlink" title="2 索引"></a>2 索引</h1><p>   索引是对数据库表中一个或者多个列的值进行排序的逻辑结构</p><p>   每个索引都有一个特定的搜索码与表中的记录关联</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>大数据技术</title>
      <link href="/2022/01/05/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%EF%BC%9A/"/>
      <url>/2022/01/05/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%EF%BC%9A/</url>
      
        <content type="html"><![CDATA[<h1 id="大数据技术："><a href="#大数据技术：" class="headerlink" title="大数据技术："></a>大数据技术：</h1><p>阿里云+ 腾讯云</p><p>权限分配：</p><p>启动所有结点： </p><p>hbase shell</p><p>hbase网页查看：</p><table><thead><tr><th>jdk</th><th>jdk-8u291</th><th></th></tr></thead><tbody><tr><td>项</td><td>版本</td><td></td></tr><tr><td>hbase</td><td>hbase-2.4.8-bin.tar.gz</td><td></td></tr><tr><td>hadoop</td><td>Hadoop 3.2.2</td><td></td></tr><tr><td>zookeeper</td><td>apache-zookeeper-3.7.0-bin.tar.gz</td><td></td></tr><tr><td>机器</td><td>120.26.160.122 jin 主  阿里云</td><td></td></tr><tr><td></td><td>121.43.229.146  liwei 阿里云</td><td></td></tr><tr><td></td><td>81.71.122.141   zcs    腾讯云</td><td></td></tr><tr><td>远程连接工具</td><td>xshell、xftp</td><td></td></tr><tr><td>项目结构</td><td>jdk1.8+ maven</td><td></td></tr></tbody></table><h1 id="Hadoop："><a href="#Hadoop：" class="headerlink" title="Hadoop："></a>Hadoop：</h1><h3 id="启动后网站访问："><a href="#启动后网站访问：" class="headerlink" title="启动后网站访问："></a>启动后网站访问：</h3><p><a href="http://120.26.160.122:9870/explorer.html#/">Browsing HDFS</a></p><p>hadoop 网站记录访问</p><p><a href="http://120.26.160.122:9870/dfshealth.html#tab-overview">Namenode information</a></p><h3 id="启动指令"><a href="#启动指令" class="headerlink" title="启动指令"></a>启动指令</h3><p>start-all.sh  </p><p>stop-all.sh</p><p>start-yarn.sh </p><p> stop-yarn.sh</p><h3 id="端口："><a href="#端口：" class="headerlink" title="端口："></a>端口：</h3><p><a href="https://www.cnblogs.com/jancco/p/4447756.html">Hadoop 2.x常用端口及查看方法 - FryFish - 博客园 (cnblogs.com)</a></p><p><img src="https://gitee.com/jwz--jwz/cloud-img/raw/master/piggo/202201041357775.png" alt="image-20211220225523476"></p><h1 id="HBase："><a href="#HBase：" class="headerlink" title="HBase："></a>HBase：</h1><h2 id="基本指令："><a href="#基本指令：" class="headerlink" title="基本指令："></a>基本指令：</h2><p>  start-hbase.sh 开启hbase</p><p>  hbase shell        开启控制面板</p><h3 id="启动访问网站："><a href="#启动访问网站：" class="headerlink" title="启动访问网站："></a>启动访问网站：</h3><p><a href="http://120.26.160.122:16010/master-status">Master: jin</a></p><p><a href="https://blog.csdn.net/itcats_cn/article/details/89034182">(30条消息) HDFS 原理详解【读写数据流程、NameNode与DataNode工作机制、checkpoint】_zp的博客-CSDN博客_简述hdfs读数据的原理</a></p><p><a href="https://zhuanlan.zhihu.com/p/51202200">Hadoop（一）Hadoop&amp;HDFS简单介绍 - 知乎 (zhihu.com)</a></p><p><a href="https://blog.csdn.net/qq_32579557/article/details/80450595">(30条消息) HBase分布式架构处理大数据量（高并发和实时处理）_猪大肠的世界-CSDN博客_hbase支持多大的并发查询</a></p><p><a href="https://zhuanlan.zhihu.com/p/365858885">干货分享 | HBase底层存储结构，HBase快速读取，Hadoop的高可用和zk作用 - 知乎 (zhihu.com)</a></p><p><img src="C:\Users\wz\AppData\Roaming\Typora\typora-user-images\image-20211220155423954.png" alt="image-20211220155423954"></p><p>hdfs封装：</p><p><a href="https://blog.csdn.net/ypp91zr/article/details/108280860">(30条消息) JAVA 上传本地文件到HDFS_程序员-CSDN博客_java上传文件到hdfs</a></p><p>[(30条消息) 前端上传文件到HDFS_rsj760337874的博客-CSDN博客](<a href="https://blog.csdn.net/rsj760337874/article/details/107937197">https://blog.csdn.net/rsj760337874/article/details/107937197</a></p><p><a href="https://blog.csdn.net/rsj760337874/article/details/107937197">(30条消息) 前端上传文件到HDFS_rsj760337874的博客-CSDN博客</a></p><p><a href="https://blog.csdn.net/shuyv/article/details/110391099">(30条消息) HDFS的Java Api操作【获取Hdfs文件系统、遍历、创建文件和文件夹、上传、下载、权限访问控制、合并上传或下载】_shuyv的博客-CSDN博客_hdfs文件下载</a></p><p>权限区别：</p><p><a href="https://blog.csdn.net/u014316462/article/details/52241685">(30条消息) linux系统644、755、777权限详解_betterAndroider的博客-CSDN博客_644权限</a></p><p><img src="https://gitee.com/jwz--jwz/cloud-img/raw/master/piggo/202201041404083.png" alt="image-20211224011439680"></p><p><img src="https://gitee.com/jwz--jwz/cloud-img/raw/master/piggo/202201041404926.png" alt="image-20211224011447711"></p><p><img src="https://gitee.com/jwz--jwz/cloud-img/raw/master/piggo/202201041403669.png" alt="image-20211224011528863"></p>]]></content>
      
      
      <categories>
          
          <category> 大数据技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hbase </tag>
            
            <tag> hadoop </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/01/05/hello-world/"/>
      <url>/2022/01/05/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
